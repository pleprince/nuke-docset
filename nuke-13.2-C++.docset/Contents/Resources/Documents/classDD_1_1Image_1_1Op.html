<html><head><link href="doxygen.css" rel="stylesheet" type="text/css">
<title>Nuke Developer Kit (NDK) 13.2.4: DD::Image::Op Class Reference</title></head><body>
<!-- Generated by Doxygen 1.8.10 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classDD_1_1Image_1_1Op.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classDD_1_1Image_1_1Op-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">DD::Image::Op Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Base class of all the things that can be created by Nuke nodes.  
 <a href="classDD_1_1Image_1_1Op.html#details">More...</a></p>

<p>Inherited by <a class="el" href="classDD_1_1Image_1_1AxisOp.html">DD::Image::AxisOp</a>, <a class="el" href="classDD_1_1Image_1_1DeepOnlyOp.html">DD::Image::DeepOnlyOp</a>, <a class="el" href="classDD_1_1Image_1_1GeoOp.html">DD::Image::GeoOp</a>, and <a class="el" href="classDD_1_1Image_1_1Iop.html">DD::Image::Iop</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op_1_1Description.html">Description</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aaec7731a5d44a5b3db2fdd6aa6549f00"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#aaec7731a5d44a5b3db2fdd6aa6549f00">HandlesMode</a> { <b>eNoHandles</b>, 
<a class="el" href="classDD_1_1Image_1_1Op.html#aaec7731a5d44a5b3db2fdd6aa6549f00ae9d9022e0abaa22879a38049d6d6aaf3">eHandlesUncooked</a>, 
<a class="el" href="classDD_1_1Image_1_1Op.html#aaec7731a5d44a5b3db2fdd6aa6549f00a4b0ee513512bceedee8e2515f2df94bb">eHandlesCooked</a>, 
<a class="el" href="classDD_1_1Image_1_1Op.html#aaec7731a5d44a5b3db2fdd6aa6549f00aa600e9311456487905305a75f39da2b7">eHandlesMax</a>
 }<tr class="separator:aaec7731a5d44a5b3db2fdd6aa6549f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:a896b162a5d1b1d07f9397b667362ce49"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a896b162a5d1b1d07f9397b667362ce49"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a896b162a5d1b1d07f9397b667362ce49">PrevalidateResult</a> { <b>eFinished</b>, 
<b>eCancelled</b>, 
<b>eAbandoned</b>
 }<tr class="memdesc:a896b162a5d1b1d07f9397b667362ce49"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a tribool return value. Do not extend. <br /></td></tr>
<tr class="separator:a896b162a5d1b1d07f9397b667362ce49"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:a93898fa563bd7d952c90c3aca59b567b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93898fa563bd7d952c90c3aca59b567b"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>HandleType</b> { <br />
&#160;&#160;<b>eNone</b>, 
<b>eMouseLeftClick</b>, 
<b>eMouseRightClick</b>, 
<b>eMouseMove</b>, 
<br />
&#160;&#160;<b>eMouseDrag</b>, 
<b>eMouseRelease</b>, 
<b>eSelectionChanged</b>, 
<b>eSelectionChangeFinished</b>, 
<br />
&#160;&#160;<b>eHandleDragTranslate</b>, 
<b>eHandleDragRotate</b>, 
<b>eHandleDragScale</b>, 
<b>eHandleDragPivot</b>, 
<br />
&#160;&#160;<b>eAllHandles</b>
<br />
 }<tr class="separator:a93898fa563bd7d952c90c3aca59b567b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:a5aea4d307e94fe59bfa2f66b56559030"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a5aea4d307e94fe59bfa2f66b56559030">ViewableModes</a> { <a class="el" href="classDD_1_1Image_1_1Op.html#a5aea4d307e94fe59bfa2f66b56559030a4880af4193d306883e9051c3bf2dc043">eViewableMode2D</a>, 
<a class="el" href="classDD_1_1Image_1_1Op.html#a5aea4d307e94fe59bfa2f66b56559030a26b127ee376127e56cf3e8c724746264">eViewableMode3D</a>, 
<a class="el" href="classDD_1_1Image_1_1Op.html#a5aea4d307e94fe59bfa2f66b56559030a07643cfd78e09723b2a9640e51416a73">eViewableMode3D_2DReference</a>
 }<tr class="separator:a5aea4d307e94fe59bfa2f66b56559030"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:a7143e1bbe81a3903c73fbae0161bcfe6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a7143e1bbe81a3903c73fbae0161bcfe6">GenerateType</a> { <br />
&#160;&#160;<a class="el" href="classDD_1_1Image_1_1Op.html#a7143e1bbe81a3903c73fbae0161bcfe6af5c264e7de144944fffb68f98029f0e0">OUTPUT_OP</a>, 
<a class="el" href="classDD_1_1Image_1_1Op.html#a7143e1bbe81a3903c73fbae0161bcfe6a829454cb678ec06c8c3317568546fdf4">ANY_CONTEXT</a>, 
<a class="el" href="classDD_1_1Image_1_1Op.html#a7143e1bbe81a3903c73fbae0161bcfe6a10d859f897448e28792026f0986b35c9">INPUT_OP</a>, 
<a class="el" href="classDD_1_1Image_1_1Op.html#a7143e1bbe81a3903c73fbae0161bcfe6a545a54179f0f56984b4b903867d564bb">INPUT_OP_PEEK</a>, 
<br />
&#160;&#160;<a class="el" href="classDD_1_1Image_1_1Op.html#a7143e1bbe81a3903c73fbae0161bcfe6ad4d97afa4899876ffde41bd9299f731c">EXECUTABLE</a>, 
<a class="el" href="classDD_1_1Image_1_1Op.html#a7143e1bbe81a3903c73fbae0161bcfe6aa868cc46995008bb4f04e2f27103b183">EXECUTABLE_SKIP</a>, 
<a class="el" href="classDD_1_1Image_1_1Op.html#a7143e1bbe81a3903c73fbae0161bcfe6a75cd54701210e07bd9a3239d5cd02bed">EXECUTABLE_INPUT</a>, 
<a class="el" href="classDD_1_1Image_1_1Op.html#a7143e1bbe81a3903c73fbae0161bcfe6a8f47e2a92552bd42641f9f43c1be88f9">UICONTEXT_ONLY</a>
<br />
 }<tr class="separator:a7143e1bbe81a3903c73fbae0161bcfe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:ab7e6c22841d12d4b8f4e908b066bfe6a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#ab7e6c22841d12d4b8f4e908b066bfe6a">NodeContext</a> { <b>eNodeGraph</b>, 
<a class="el" href="classDD_1_1Image_1_1Op.html#ab7e6c22841d12d4b8f4e908b066bfe6aa08ac177353adfedb8c28210fae3022d2">eTimeline</a>, 
<a class="el" href="classDD_1_1Image_1_1Op.html#ab7e6c22841d12d4b8f4e908b066bfe6aad5156682159c44e082c8fcfd1f4be887">eOpGraph</a>
 }<tr class="separator:ab7e6c22841d12d4b8f4e908b066bfe6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:ad05eb8420166eff8fabdb30b8fe9c13c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#ad05eb8420166eff8fabdb30b8fe9c13c">StatusFlags</a> { <b>StatusNone</b>, 
<b>StatusModal</b>, 
<b>StatusUseCallback</b>
 }<tr class="separator:ad05eb8420166eff8fabdb30b8fe9c13c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:afbc2750a2e33057090759ec5844cd4bd"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#afbc2750a2e33057090759ec5844cd4bd">PopUpScheme</a> { <br />
&#160;&#160;<a class="el" href="classDD_1_1Image_1_1Op.html#afbc2750a2e33057090759ec5844cd4bdabc6e7073930e89bdc83adbb702927c9a">ePU_Never</a>, 
<a class="el" href="classDD_1_1Image_1_1Op.html#afbc2750a2e33057090759ec5844cd4bda1e89aea03a9191ebf883d71611069c2f">ePU_Done</a>, 
<a class="el" href="classDD_1_1Image_1_1Op.html#afbc2750a2e33057090759ec5844cd4bdab96b2ec349ff8d2809ffa3c9d8c12412">ePU_Once</a>, 
<a class="el" href="classDD_1_1Image_1_1Op.html#afbc2750a2e33057090759ec5844cd4bda6ac6d6e60881a4656348542da2bc3e74">ePU_Default</a>, 
<br />
&#160;&#160;<a class="el" href="classDD_1_1Image_1_1Op.html#afbc2750a2e33057090759ec5844cd4bdaae6bbcc472a54c6a676cf9835d7ae0ad">ePU_Always</a>
<br />
 }<tr class="memdesc:afbc2750a2e33057090759ec5844cd4bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop-up schemes determine when pop-up messages are displayed for op errors.  <a href="classDD_1_1Image_1_1Op.html#afbc2750a2e33057090759ec5844cd4bd">More...</a><br /></td></tr>
<tr class="separator:afbc2750a2e33057090759ec5844cd4bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:ac5ff1f1ed07a15531de905d7bab320af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac5ff1f1ed07a15531de905d7bab320af"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#ac5ff1f1ed07a15531de905d7bab320af">VersionComponents</a> { <b>eMajor</b>, 
<b>eMinor</b>, 
<b>ePoint</b>, 
<b>eRevision</b>
 }<tr class="memdesc:ac5ff1f1ed07a15531de905d7bab320af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum to help get the desired version component from the VersionInfo tuple. <br /></td></tr>
<tr class="separator:ac5ff1f1ed07a15531de905d7bab320af"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:a34f87dcb919c0f9cc47c661344502fde"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a34f87dcb919c0f9cc47c661344502fde"></a>
typedef std::pair&lt; int, <a class="el" href="classDD_1_1Image_1_1Op.html">DD::Image::Op</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a34f87dcb919c0f9cc47c661344502fde">Output</a></td></tr>
<tr class="memdesc:a34f87dcb919c0f9cc47c661344502fde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combination of input number and pointer to <a class="el" href="classDD_1_1Image_1_1Op.html" title="Base class of all the things that can be created by Nuke nodes. ">Op</a>. <br /></td></tr>
<tr class="separator:a34f87dcb919c0f9cc47c661344502fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab6e666fdc0030df83e5b5161ac63f05"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab6e666fdc0030df83e5b5161ac63f05"></a>
typedef std::set&lt; <a class="el" href="classDD_1_1Image_1_1Op.html#a34f87dcb919c0f9cc47c661344502fde">Output</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#aab6e666fdc0030df83e5b5161ac63f05">OutputSet</a></td></tr>
<tr class="memdesc:aab6e666fdc0030df83e5b5161ac63f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of all outputs from this <a class="el" href="classDD_1_1Image_1_1Op.html" title="Base class of all the things that can be created by Nuke nodes. ">Op</a>. <br /></td></tr>
<tr class="separator:aab6e666fdc0030df83e5b5161ac63f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e30323046f59045417065b91e55fea"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; <a class="el" href="classDD_1_1Image_1_1Hash.html">Hash</a>, std::vector&lt; unsigned int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a52e30323046f59045417065b91e55fea">ItemSelectionList</a></td></tr>
<tr class="separator:a52e30323046f59045417065b91e55fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab863a346bd04c1eae10290b5762ff6a2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab863a346bd04c1eae10290b5762ff6a2"></a>
typedef bool(&#160;</td><td class="memItemRight" valign="bottom"><b>EventCallback</b>) (<a class="el" href="classDD_1_1Image_1_1Op.html">Op</a> *op, EventContext eventCtx)</td></tr>
<tr class="separator:ab863a346bd04c1eae10290b5762ff6a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98542a0dc83294f62271afbc44e3d86b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a98542a0dc83294f62271afbc44e3d86b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a98542a0dc83294f62271afbc44e3d86b">VersionInfo</a> = std::tuple&lt; int, int, int, int &gt;</td></tr>
<tr class="memdesc:a98542a0dc83294f62271afbc44e3d86b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains version components with each index defined by the VersionComponents enum. <br /></td></tr>
<tr class="separator:a98542a0dc83294f62271afbc44e3d86b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a44f1e97f589ca7c7d16b5eb15ea94824"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDD_1_1Image_1_1Op.html#a896b162a5d1b1d07f9397b667362ce49">PrevalidateResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a44f1e97f589ca7c7d16b5eb15ea94824">preValidate</a> (<a class="el" href="classDD_1_1Image_1_1ViewerContext.html">ViewerContext</a> *ctx=nullptr, <a class="el" href="classDD_1_1Image_1_1PreValidateContext.html">PreValidateContext</a> *=nullptr)</td></tr>
<tr class="separator:a44f1e97f589ca7c7d16b5eb15ea94824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0f0dc1f231976d506e5444fb6ccc577"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDD_1_1Image_1_1Op.html">Op</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#ab0f0dc1f231976d506e5444fb6ccc577">rootOp</a> () const </td></tr>
<tr class="separator:ab0f0dc1f231976d506e5444fb6ccc577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c3627c3eb0de1e6e03be2bf51f14bcc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a0c3627c3eb0de1e6e03be2bf51f14bcc">preValidateAborted</a> (int treeStartingVersion, <a class="el" href="classDD_1_1Image_1_1Op.html#a896b162a5d1b1d07f9397b667362ce49">PrevalidateResult</a> &amp;result) const </td></tr>
<tr class="separator:a0c3627c3eb0de1e6e03be2bf51f14bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34bf6fd9ad66368a599015262640578"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab34bf6fd9ad66368a599015262640578"></a>
const <a class="el" href="classDD_1_1Image_1_1Op.html#aab6e666fdc0030df83e5b5161ac63f05">OutputSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#ab34bf6fd9ad66368a599015262640578">getOutputs</a> () const </td></tr>
<tr class="memdesc:ab34bf6fd9ad66368a599015262640578"><td class="mdescLeft">&#160;</td><td class="mdescRight">return all the outputs of this node <br /></td></tr>
<tr class="separator:ab34bf6fd9ad66368a599015262640578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc762f0d6147079394beeaced07f319c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc762f0d6147079394beeaced07f319c"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#acc762f0d6147079394beeaced07f319c">setInputsValid</a> (bool nowValid)</td></tr>
<tr class="memdesc:acc762f0d6147079394beeaced07f319c"><td class="mdescLeft">&#160;</td><td class="mdescRight">set whether the input ops are valid (are for the right context) <br /></td></tr>
<tr class="separator:acc762f0d6147079394beeaced07f319c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc37d825886dbf3b88dc9e8ade2d6361"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc37d825886dbf3b88dc9e8ade2d6361"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#adc37d825886dbf3b88dc9e8ade2d6361">inputsValid</a> () const </td></tr>
<tr class="memdesc:adc37d825886dbf3b88dc9e8ade2d6361"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether the input ops are valid (are for the right context) <br /></td></tr>
<tr class="separator:adc37d825886dbf3b88dc9e8ade2d6361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6815fd8e3a0b00d20fb4a78391269ab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6815fd8e3a0b00d20fb4a78391269ab"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#ae6815fd8e3a0b00d20fb4a78391269ab">can_clone</a> () const </td></tr>
<tr class="memdesc:ae6815fd8e3a0b00d20fb4a78391269ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns whether or not an op can be cloned in the dag <br /></td></tr>
<tr class="separator:ae6815fd8e3a0b00d20fb4a78391269ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8b8bd5354b60c25c83bcbd9b1ae191"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f8b8bd5354b60c25c83bcbd9b1ae191"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a1f8b8bd5354b60c25c83bcbd9b1ae191">haveHash</a> () const </td></tr>
<tr class="memdesc:a1f8b8bd5354b60c25c83bcbd9b1ae191"><td class="mdescLeft">&#160;</td><td class="mdescRight">return true if the <a class="el" href="classDD_1_1Image_1_1Op.html#a69dfe1facc10819d7dc561ae1b380d66">hash()</a> value is meaningful and globally unique <br /></td></tr>
<tr class="separator:a1f8b8bd5354b60c25c83bcbd9b1ae191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae722a1d8fccbbd2a12bdf2b4676d7757"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae722a1d8fccbbd2a12bdf2b4676d7757"></a>
virtual std::vector&lt; <a class="el" href="classDD_1_1Image_1_1OutputContext.html">DD::Image::OutputContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getPrevVersionsWanted</b> () const </td></tr>
<tr class="separator:ae722a1d8fccbbd2a12bdf2b4676d7757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac28ac7af905cc60ac6ed9ecce16d0d4"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classDD_1_1Image_1_1MetaData_1_1Bundle.html">MetaData::Bundle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#aac28ac7af905cc60ac6ed9ecce16d0d4">_fetchMetaData</a> (const char *keyname)</td></tr>
<tr class="separator:aac28ac7af905cc60ac6ed9ecce16d0d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15e7072f2282bb9fced37048aaf8ae11"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDD_1_1Image_1_1MetaData_1_1Bundle.html">MetaData::Bundle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a15e7072f2282bb9fced37048aaf8ae11">fetchMetaData</a> (const char *keyname)</td></tr>
<tr class="separator:a15e7072f2282bb9fced37048aaf8ae11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e65ba0209479090ca51fc3d0b60e8ea"><td class="memItemLeft" align="right" valign="top">Node *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a1e65ba0209479090ca51fc3d0b60e8ea">node</a> () const </td></tr>
<tr class="separator:a1e65ba0209479090ca51fc3d0b60e8ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6419807b5f05b85208614e3bc124eb7a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6419807b5f05b85208614e3bc124eb7a"></a>
DD::Image::NodeI *&#160;</td><td class="memItemRight" valign="bottom"><b>getNode</b> () const </td></tr>
<tr class="separator:a6419807b5f05b85208614e3bc124eb7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54449efe332353c5be370b8f43aab967"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a54449efe332353c5be370b8f43aab967">node</a> (Node *v)</td></tr>
<tr class="separator:a54449efe332353c5be370b8f43aab967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac22636e5c4151d8e85a0fb113817691b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac22636e5c4151d8e85a0fb113817691b"></a>
<a class="el" href="classDD_1_1Image_1_1Op.html">Op</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>firstOp</b> () const </td></tr>
<tr class="separator:ac22636e5c4151d8e85a0fb113817691b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba4fdc2b15189fa5930fb85a59f9d609"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba4fdc2b15189fa5930fb85a59f9d609"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>firstOp</b> (<a class="el" href="classDD_1_1Image_1_1Op.html">Op</a> *v)</td></tr>
<tr class="separator:aba4fdc2b15189fa5930fb85a59f9d609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d4340b2a813327a249698c0dee107bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDD_1_1Image_1_1Op.html">Op</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a0d4340b2a813327a249698c0dee107bb">parent</a> () const </td></tr>
<tr class="separator:a0d4340b2a813327a249698c0dee107bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a9a43748c5c825c628ff90e01b422a0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a9a43748c5c825c628ff90e01b422a0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>parent</b> (<a class="el" href="classDD_1_1Image_1_1Op.html">Op</a> *lpOp)</td></tr>
<tr class="separator:a7a9a43748c5c825c628ff90e01b422a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af015912871dd158f56dd2cc32b952256"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af015912871dd158f56dd2cc32b952256"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#af015912871dd158f56dd2cc32b952256">detach</a> ()</td></tr>
<tr class="memdesc:af015912871dd158f56dd2cc32b952256"><td class="mdescLeft">&#160;</td><td class="mdescRight">node has been deleted in DAG <br /></td></tr>
<tr class="separator:af015912871dd158f56dd2cc32b952256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add726784df366c4cf02702a70038bb53"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add726784df366c4cf02702a70038bb53"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#add726784df366c4cf02702a70038bb53">attach</a> ()</td></tr>
<tr class="memdesc:add726784df366c4cf02702a70038bb53"><td class="mdescLeft">&#160;</td><td class="mdescRight">node has been created in DAG <br /></td></tr>
<tr class="separator:add726784df366c4cf02702a70038bb53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ca3df15f9d7c72d92be83733a43b26"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7ca3df15f9d7c72d92be83733a43b26"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>pre_write_knobs</b> ()</td></tr>
<tr class="separator:af7ca3df15f9d7c72d92be83733a43b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74011be78d484b8241939c392ab9b653"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a74011be78d484b8241939c392ab9b653">knobs</a> (Knob_Callback)</td></tr>
<tr class="separator:a74011be78d484b8241939c392ab9b653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187563982c7ede588ba740fbcf9c38ae"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a187563982c7ede588ba740fbcf9c38ae">replace_knobs</a> (<a class="el" href="classDD_1_1Image_1_1Knob.html">Knob</a> *afterthis, int n, void(*f)(void *, Knob_Callback), void *, const char *fileExt=nullptr)</td></tr>
<tr class="separator:a187563982c7ede588ba740fbcf9c38ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04ac66fdaecffae7f30a5db5c2bfaf97"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a04ac66fdaecffae7f30a5db5c2bfaf97">add_knobs</a> (void(*f)(void *, Knob_Callback), void *, Knob_Callback)</td></tr>
<tr class="separator:a04ac66fdaecffae7f30a5db5c2bfaf97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb229f28d82696e0cee5bc5f7f11dda8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#acb229f28d82696e0cee5bc5f7f11dda8">set_unlicensed</a> ()</td></tr>
<tr class="separator:acb229f28d82696e0cee5bc5f7f11dda8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bbfe0c075c8844df6b49d5ea400c52a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDD_1_1Image_1_1Knob.html">Knob</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a3bbfe0c075c8844df6b49d5ea400c52a">knob</a> (const char *name) const </td></tr>
<tr class="separator:a3bbfe0c075c8844df6b49d5ea400c52a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070557fb167e36323190ccc0177306e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDD_1_1Image_1_1Knob.html">Knob</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a070557fb167e36323190ccc0177306e4">knob</a> (int) const </td></tr>
<tr class="separator:a070557fb167e36323190ccc0177306e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ed2bd29bf82944c20ce87f2b724dbc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#ad5ed2bd29bf82944c20ce87f2b724dbc">pushed</a> () const </td></tr>
<tr class="separator:ad5ed2bd29bf82944c20ce87f2b724dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8c65314eda731d9e09dadd293ae273b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#ae8c65314eda731d9e09dadd293ae273b">panel_visible</a> () const </td></tr>
<tr class="separator:ae8c65314eda731d9e09dadd293ae273b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae60d53348e4bccb9f32b09f911c86a4b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#ae60d53348e4bccb9f32b09f911c86a4b">node_disabled</a> () const </td></tr>
<tr class="separator:ae60d53348e4bccb9f32b09f911c86a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab402de75ab56921663b55f853587627b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#ab402de75ab56921663b55f853587627b">node_selected</a> () const </td></tr>
<tr class="separator:ab402de75ab56921663b55f853587627b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c243a7fa9b978742fc461cb4df23592"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a5c243a7fa9b978742fc461cb4df23592">node_gl_color</a> () const </td></tr>
<tr class="separator:a5c243a7fa9b978742fc461cb4df23592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e36f90d0838e7ac1b0e0dac9fa15ca3"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a1e36f90d0838e7ac1b0e0dac9fa15ca3">field</a> (const char *name)</td></tr>
<tr class="separator:a1e36f90d0838e7ac1b0e0dac9fa15ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed442e5319c28645301c7760072e412"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a4ed442e5319c28645301c7760072e412">field</a> (const char *name, int &amp;type)</td></tr>
<tr class="separator:a4ed442e5319c28645301c7760072e412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43260b9f61dc1ff269a93acab40b8b6c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a43260b9f61dc1ff269a93acab40b8b6c">set_field</a> (const char *name, const void *source, int size)</td></tr>
<tr class="separator:a43260b9f61dc1ff269a93acab40b8b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36806d21434105c3fce012d162b3ed94"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a36806d21434105c3fce012d162b3ed94">get_field</a> (const char *name, void *dest, int size)</td></tr>
<tr class="separator:a36806d21434105c3fce012d162b3ed94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0f128321842f15450b575aefedca602"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#ad0f128321842f15450b575aefedca602">beginHandle</a> (HandleType command, <a class="el" href="classDD_1_1Image_1_1ViewerContext.html">ViewerContext</a> *ctx, EventCallback *cb, int index, float x=0, float y=0, float z=0, <a class="el" href="classDD_1_1Image_1_1ViewerContext.html#ac9c915d433bdce7b6b47c0956c850f43">ViewerContext::Cursor</a> cursor=ViewerContext::kNoCursor)</td></tr>
<tr class="separator:ad0f128321842f15450b575aefedca602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a129212a7cd7260d909b1517e7727e161"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a129212a7cd7260d909b1517e7727e161"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>endHandle</b> (<a class="el" href="classDD_1_1Image_1_1ViewerContext.html">ViewerContext</a> *ctx)</td></tr>
<tr class="separator:a129212a7cd7260d909b1517e7727e161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac5d7e37ec7090d95e064575e648ae40"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#aac5d7e37ec7090d95e064575e648ae40">knob_changed</a> (<a class="el" href="classDD_1_1Image_1_1Knob.html">Knob</a> *)</td></tr>
<tr class="separator:aac5d7e37ec7090d95e064575e648ae40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8568c1539a3b06dbcbb2df05520faade"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8568c1539a3b06dbcbb2df05520faade"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>knob_change_finished</b> (<a class="el" href="classDD_1_1Image_1_1Knob.html">Knob</a> *<a class="el" href="classDD_1_1Image_1_1Op.html#a3bbfe0c075c8844df6b49d5ea400c52a">knob</a>, bool changedByUser=true)</td></tr>
<tr class="separator:a8568c1539a3b06dbcbb2df05520faade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a6acb4a433796a5b0c7940542b4db31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a5a6acb4a433796a5b0c7940542b4db31">addTime</a> (OpTimer::Category category, long long microsecondsCPU, long long microsecondsWall, bool isTopLevel=true)</td></tr>
<tr class="separator:a5a6acb4a433796a5b0c7940542b4db31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acebd8b50ba356f8d4487efcb4354dd9f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acebd8b50ba356f8d4487efcb4354dd9f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#acebd8b50ba356f8d4487efcb4354dd9f">getPerformanceInfo</a> (OpTimer::Category category, OpTimer::PerformanceInfo &amp;info) const </td></tr>
<tr class="memdesc:acebd8b50ba356f8d4487efcb4354dd9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the amount of CPU time taken by this op <br /></td></tr>
<tr class="separator:acebd8b50ba356f8d4487efcb4354dd9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae6ef3456a6ee5f08b593aaa3c726972"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae6ef3456a6ee5f08b593aaa3c726972"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#aae6ef3456a6ee5f08b593aaa3c726972">inputs_clockwise</a> () const </td></tr>
<tr class="memdesc:aae6ef3456a6ee5f08b593aaa3c726972"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether unconnected inputs on the DAG should be arranged clockwise or anticlockwise (default) <br /></td></tr>
<tr class="separator:aae6ef3456a6ee5f08b593aaa3c726972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a062ff8f0df286fe07bb2ac11d8118fb5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a062ff8f0df286fe07bb2ac11d8118fb5"></a>
virtual std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>input_order</b> () const </td></tr>
<tr class="separator:a062ff8f0df286fe07bb2ac11d8118fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1088a7c1e940c479bd74dae025fabb2"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#af1088a7c1e940c479bd74dae025fabb2">inputArrows</a> (int nodeInputs) const </td></tr>
<tr class="separator:af1088a7c1e940c479bd74dae025fabb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa01955aa08bcdfb41a9721c8cb427f3f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#aa01955aa08bcdfb41a9721c8cb427f3f">script_command</a> (const char *command, bool py=true, bool eval=true) const </td></tr>
<tr class="separator:aa01955aa08bcdfb41a9721c8cb427f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a697e2a3194de8f4444d09971db44ed0f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a697e2a3194de8f4444d09971db44ed0f">script_expand</a> (const char *str) const </td></tr>
<tr class="separator:a697e2a3194de8f4444d09971db44ed0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe577daac2fa0077ced2e318021c31f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aebe577daac2fa0077ced2e318021c31f"></a>
<a class="el" href="classDD_1_1Image_1_1Op.html#aaec7731a5d44a5b3db2fdd6aa6549f00">HandlesMode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>anyHandles</b> (<a class="el" href="classDD_1_1Image_1_1ViewerContext.html">ViewerContext</a> *ctx)</td></tr>
<tr class="separator:aebe577daac2fa0077ced2e318021c31f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a50f7c26535dd6c84390c67c08c5581"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a7a50f7c26535dd6c84390c67c08c5581">build_handles</a> (<a class="el" href="classDD_1_1Image_1_1ViewerContext.html">ViewerContext</a> *)</td></tr>
<tr class="separator:a7a50f7c26535dd6c84390c67c08c5581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba9abeaf38daf13cf9ff013192ddc3ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#aba9abeaf38daf13cf9ff013192ddc3ef">add_draw_handle</a> (<a class="el" href="classDD_1_1Image_1_1ViewerContext.html">ViewerContext</a> *)</td></tr>
<tr class="separator:aba9abeaf38daf13cf9ff013192ddc3ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf77566e651b87bb29483269b56e2b0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#abdf77566e651b87bb29483269b56e2b0">draw_handle</a> (<a class="el" href="classDD_1_1Image_1_1ViewerContext.html">ViewerContext</a> *)</td></tr>
<tr class="separator:abdf77566e651b87bb29483269b56e2b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c6dce4be81844688cda2cd19f4de5f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a31c6dce4be81844688cda2cd19f4de5f">add_input_handle</a> (int <a class="el" href="classDD_1_1Image_1_1Op.html#a3f8fb27d42f6da712722fa73eda6b5b0">input</a>, <a class="el" href="classDD_1_1Image_1_1ViewerContext.html">ViewerContext</a> *)</td></tr>
<tr class="separator:a31c6dce4be81844688cda2cd19f4de5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eb5d36240a3c65644be90df9497a556"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7eb5d36240a3c65644be90df9497a556"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>add_op_handle</b> (<a class="el" href="classDD_1_1Image_1_1ViewerContext.html">ViewerContext</a> *ctx)</td></tr>
<tr class="separator:a7eb5d36240a3c65644be90df9497a556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a448fc3791b6e2bb8339e023f2bb01ada"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a448fc3791b6e2bb8339e023f2bb01ada">add_knob_handle</a> (<a class="el" href="classDD_1_1Image_1_1Knob.html">Knob</a> *, <a class="el" href="classDD_1_1Image_1_1ViewerContext.html">ViewerContext</a> *)</td></tr>
<tr class="separator:a448fc3791b6e2bb8339e023f2bb01ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c47564f84fd480311d0f080839b0c95"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a8c47564f84fd480311d0f080839b0c95">getViewableModes</a> () const </td></tr>
<tr class="separator:a8c47564f84fd480311d0f080839b0c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7991d2e6e89553a657049e1273c86c21"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a7991d2e6e89553a657049e1273c86c21">optional_input</a> () const </td></tr>
<tr class="separator:a7991d2e6e89553a657049e1273c86c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7d2c60fe1d600584aacb9ffe8d900c"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#acd7d2c60fe1d600584aacb9ffe8d900c">minimum_inputs</a> () const </td></tr>
<tr class="separator:acd7d2c60fe1d600584aacb9ffe8d900c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a9392b9827e2f79f2bac7d3317b4065"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a7a9392b9827e2f79f2bac7d3317b4065">maximum_inputs</a> () const </td></tr>
<tr class="separator:a7a9392b9827e2f79f2bac7d3317b4065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f1298d78336302f857270898296703d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a3f1298d78336302f857270898296703d">test_input</a> (int, <a class="el" href="classDD_1_1Image_1_1Op.html">Op</a> *) const </td></tr>
<tr class="separator:a3f1298d78336302f857270898296703d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f2eaf5b7de5354cc5838e608cf25543"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a1f2eaf5b7de5354cc5838e608cf25543">inputs</a> () const </td></tr>
<tr class="separator:a1f2eaf5b7de5354cc5838e608cf25543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a478c5f12fe443a94630a6b1ecb9020d7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a478c5f12fe443a94630a6b1ecb9020d7">node_inputs</a> () const </td></tr>
<tr class="separator:a478c5f12fe443a94630a6b1ecb9020d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad60adcf8b3c3db91ee559210046e6d6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDD_1_1Image_1_1Op.html">Op</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#ad60adcf8b3c3db91ee559210046e6d6b">node_input</a> (int, <a class="el" href="classDD_1_1Image_1_1Op.html#a7143e1bbe81a3903c73fbae0161bcfe6">GenerateType</a>=<a class="el" href="classDD_1_1Image_1_1Op.html#a7143e1bbe81a3903c73fbae0161bcfe6af5c264e7de144944fffb68f98029f0e0">OUTPUT_OP</a>) const </td></tr>
<tr class="separator:ad60adcf8b3c3db91ee559210046e6d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e7b720900399722a7666ef1e4029e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8e7b720900399722a7666ef1e4029e5"></a>
<a class="el" href="classDD_1_1Image_1_1Op.html">Op</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>node_input</b> (int, <a class="el" href="classDD_1_1Image_1_1Op.html#a7143e1bbe81a3903c73fbae0161bcfe6">GenerateType</a>, const <a class="el" href="classDD_1_1Image_1_1OutputContext.html">DD::Image::OutputContext</a> *<a class="el" href="classDD_1_1Image_1_1Op.html#adb272858c40a05b35e6596f103377bb4">outputContext</a>) const </td></tr>
<tr class="separator:ad8e7b720900399722a7666ef1e4029e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29555dfdeb6d61fbf78011642417e0fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDD_1_1Image_1_1Op.html">Op</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a29555dfdeb6d61fbf78011642417e0fd">input_op</a> (int n=0) const </td></tr>
<tr class="separator:a29555dfdeb6d61fbf78011642417e0fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a4ce0ce33ec442202dd4e272e2a96b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a86a4ce0ce33ec442202dd4e272e2a96b">inputs</a> (int n)</td></tr>
<tr class="separator:a86a4ce0ce33ec442202dd4e272e2a96b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f8fb27d42f6da712722fa73eda6b5b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDD_1_1Image_1_1Op.html">Op</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a3f8fb27d42f6da712722fa73eda6b5b0">input</a> (int) const </td></tr>
<tr class="separator:a3f8fb27d42f6da712722fa73eda6b5b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b531b97920ff151b4cc07bdbf6cd283"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a4b531b97920ff151b4cc07bdbf6cd283">inputNumber</a> (int <a class="el" href="classDD_1_1Image_1_1Op.html#a3f8fb27d42f6da712722fa73eda6b5b0">input</a>, int offset) const </td></tr>
<tr class="separator:a4b531b97920ff151b4cc07bdbf6cd283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3311c9a30d1f582ab69aeb4e7a018e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDD_1_1Image_1_1Op.html">Op</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#ab3311c9a30d1f582ab69aeb4e7a018e7">input</a> (int input, int offset) const </td></tr>
<tr class="separator:ab3311c9a30d1f582ab69aeb4e7a018e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba15a593cfe65a8b150cfe442ebe64cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDD_1_1Image_1_1Op.html">Op</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#aba15a593cfe65a8b150cfe442ebe64cd">input0</a> () const </td></tr>
<tr class="memdesc:aba15a593cfe65a8b150cfe442ebe64cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the primary input  <a href="#aba15a593cfe65a8b150cfe442ebe64cd">More...</a><br /></td></tr>
<tr class="separator:aba15a593cfe65a8b150cfe442ebe64cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a879629bef50c0149cd4301219e7d3425"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDD_1_1Image_1_1Op.html">Op</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a879629bef50c0149cd4301219e7d3425">input1</a> () const </td></tr>
<tr class="memdesc:a879629bef50c0149cd4301219e7d3425"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the second input, if it exists  <a href="#a879629bef50c0149cd4301219e7d3425">More...</a><br /></td></tr>
<tr class="separator:a879629bef50c0149cd4301219e7d3425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf5ef411da25098a653238ee467804c"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classDD_1_1Image_1_1Op.html">Op</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#aadf5ef411da25098a653238ee467804c">getInputs</a> () const </td></tr>
<tr class="separator:aadf5ef411da25098a653238ee467804c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae632494cc8a61316fda1dc2213040079"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classDD_1_1Image_1_1Op.html">Op</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#ae632494cc8a61316fda1dc2213040079">getChildren</a> () const </td></tr>
<tr class="separator:ae632494cc8a61316fda1dc2213040079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b26296e171162ecf103fd75827bef6e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a3b26296e171162ecf103fd75827bef6e">set_input</a> (int i, <a class="el" href="classDD_1_1Image_1_1Op.html">Op</a> *op, int <a class="el" href="classDD_1_1Image_1_1Op.html#a3f8fb27d42f6da712722fa73eda6b5b0">input</a>, int offset)</td></tr>
<tr class="separator:a3b26296e171162ecf103fd75827bef6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22d3e1884fa063fd80a28df2b5d4b574"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a22d3e1884fa063fd80a28df2b5d4b574">set_input0</a> (<a class="el" href="classDD_1_1Image_1_1Op.html">Op</a> *op)</td></tr>
<tr class="separator:a22d3e1884fa063fd80a28df2b5d4b574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd046dd6ce1045ee5e350fe458673b14"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abd046dd6ce1045ee5e350fe458673b14"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_input</b> (int i, <a class="el" href="classDD_1_1Image_1_1Op.html">Op</a> *op)</td></tr>
<tr class="separator:abd046dd6ce1045ee5e350fe458673b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3d11dbfee9071b5b82d97f8cadd9d4a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa3d11dbfee9071b5b82d97f8cadd9d4a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_input</b> (int i, <a class="el" href="classDD_1_1Image_1_1Op.html">Op</a> &amp;op)</td></tr>
<tr class="separator:aa3d11dbfee9071b5b82d97f8cadd9d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e74b3d284d3fb34b448b8b52e18a54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a90e74b3d284d3fb34b448b8b52e18a54">set_input</a> (int <a class="el" href="classDD_1_1Image_1_1Op.html#a3f8fb27d42f6da712722fa73eda6b5b0">input</a>, int offset, <a class="el" href="classDD_1_1Image_1_1Op.html">Op</a> *op)</td></tr>
<tr class="separator:a90e74b3d284d3fb34b448b8b52e18a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb272858c40a05b35e6596f103377bb4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDD_1_1Image_1_1OutputContext.html">OutputContext</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#adb272858c40a05b35e6596f103377bb4">outputContext</a> () const </td></tr>
<tr class="separator:adb272858c40a05b35e6596f103377bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17945fe59b77fdaeb7450d424fe4a7e2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a17945fe59b77fdaeb7450d424fe4a7e2">setOutputContext</a> (const <a class="el" href="classDD_1_1Image_1_1OutputContext.html">OutputContext</a> &amp;c)</td></tr>
<tr class="separator:a17945fe59b77fdaeb7450d424fe4a7e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b2909bec5cfe8da41e9b7fb58764db"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#ac3b2909bec5cfe8da41e9b7fb58764db">append</a> (<a class="el" href="classDD_1_1Image_1_1Hash.html">Hash</a> &amp;)</td></tr>
<tr class="separator:ac3b2909bec5cfe8da41e9b7fb58764db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a814d71f7e6af7bbd10b771eb4439ee61"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a814d71f7e6af7bbd10b771eb4439ee61">uses_input</a> (int) const </td></tr>
<tr class="separator:a814d71f7e6af7bbd10b771eb4439ee61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a077c80394cd51b0e4fe0183fabfddd3c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a077c80394cd51b0e4fe0183fabfddd3c"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>build_splits</b> ()</td></tr>
<tr class="separator:a077c80394cd51b0e4fe0183fabfddd3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abef17d0f45fe7540c4893983d1b0e45e"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#abef17d0f45fe7540c4893983d1b0e45e">split_input</a> (int) const </td></tr>
<tr class="separator:abef17d0f45fe7540c4893983d1b0e45e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a843a2b11746037eecfa0686fd7215cc1"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classDD_1_1Image_1_1OutputContext.html">OutputContext</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a843a2b11746037eecfa0686fd7215cc1">inputContext</a> (int n, int offset, <a class="el" href="classDD_1_1Image_1_1OutputContext.html">OutputContext</a> &amp;) const </td></tr>
<tr class="separator:a843a2b11746037eecfa0686fd7215cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a157e98d1b2073ebdfa639192add847e4"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classDD_1_1Image_1_1OutputContext.html">OutputContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a157e98d1b2073ebdfa639192add847e4">inputUIContext</a> (int n, <a class="el" href="classDD_1_1Image_1_1OutputContext.html">OutputContext</a> &amp;) const </td></tr>
<tr class="separator:a157e98d1b2073ebdfa639192add847e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a1ce753b5e575eadf779b78e962bfd"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classDD_1_1Image_1_1Op.html">Op</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a18a1ce753b5e575eadf779b78e962bfd">default_input</a> (int) const </td></tr>
<tr class="separator:a18a1ce753b5e575eadf779b78e962bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69dfe1facc10819d7dc561ae1b380d66"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDD_1_1Image_1_1Hash.html">Hash</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a69dfe1facc10819d7dc561ae1b380d66">hash</a> () const </td></tr>
<tr class="separator:a69dfe1facc10819d7dc561ae1b380d66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d50fc5cf4180e79dae181db82667a47"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a7d50fc5cf4180e79dae181db82667a47">frameTransformImplemented</a> () const </td></tr>
<tr class="separator:a7d50fc5cf4180e79dae181db82667a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad266801e732054e3fc7fe4787d8c6d5f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad266801e732054e3fc7fe4787d8c6d5f"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>frameTransformDownstream</b> (const <a class="el" href="classDD_1_1Image_1_1OutputContext.html">OutputContext</a> &amp;context, unsigned int <a class="el" href="classDD_1_1Image_1_1Op.html#a3f8fb27d42f6da712722fa73eda6b5b0">input</a>, float inFrame, float &amp;outFrame) const </td></tr>
<tr class="separator:ad266801e732054e3fc7fe4787d8c6d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab35a6968e9404fd29cb724279fbb57b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab35a6968e9404fd29cb724279fbb57b1"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>frameTransformUpstream</b> (const <a class="el" href="classDD_1_1Image_1_1OutputContext.html">OutputContext</a> &amp;context, unsigned int <a class="el" href="classDD_1_1Image_1_1Op.html#a3f8fb27d42f6da712722fa73eda6b5b0">input</a>, float outFrame, float &amp;inFrame) const </td></tr>
<tr class="separator:ab35a6968e9404fd29cb724279fbb57b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acabdc67602b50ce49f970d284b9e2305"><td class="memItemLeft" align="right" valign="top">virtual DopeItemFlags::Mask&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#acabdc67602b50ce49f970d284b9e2305">getDopeItemFlags</a> () const </td></tr>
<tr class="separator:acabdc67602b50ce49f970d284b9e2305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f3c75489552f1d32351e270f7917675"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a2f3c75489552f1d32351e270f7917675">shouldHideInDopeSheet</a> (<a class="el" href="classDD_1_1Image_1_1Knob.html">Knob</a> *<a class="el" href="classDD_1_1Image_1_1Op.html#a3bbfe0c075c8844df6b49d5ea400c52a">knob</a>) const </td></tr>
<tr class="separator:a2f3c75489552f1d32351e270f7917675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae001b039dd47807c6a0efc4f202e99fe"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classDD_1_1Image_1_1Knob.html">DD::Image::Knob</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#ae001b039dd47807c6a0efc4f202e99fe">getDopeItemKnob</a> () const </td></tr>
<tr class="separator:ae001b039dd47807c6a0efc4f202e99fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5305258ab1835cf247e9729d489444f7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5305258ab1835cf247e9729d489444f7"></a>
virtual ViewSet&#160;</td><td class="memItemRight" valign="bottom"><b>viewsProduced</b> () const </td></tr>
<tr class="separator:a5305258ab1835cf247e9729d489444f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad444ba2a7766045a28f9b310eb6e092b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad444ba2a7766045a28f9b310eb6e092b"></a>
virtual ViewSet&#160;</td><td class="memItemRight" valign="bottom"><b>viewsWantOn</b> (int i) const </td></tr>
<tr class="separator:ad444ba2a7766045a28f9b310eb6e092b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e76098c9d2c4b22914bc85a93001219"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e76098c9d2c4b22914bc85a93001219"></a>
virtual ViewSet&#160;</td><td class="memItemRight" valign="bottom"><b>splitForViews</b> () const </td></tr>
<tr class="separator:a2e76098c9d2c4b22914bc85a93001219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af33cb4f5deaa72c22c13f5f9cdf0f8b9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#af33cb4f5deaa72c22c13f5f9cdf0f8b9">requested</a> () const </td></tr>
<tr class="separator:af33cb4f5deaa72c22c13f5f9cdf0f8b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3052f925ffc0c206fee2fef2092981f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a3052f925ffc0c206fee2fef2092981f5">setRequested</a> ()</td></tr>
<tr class="separator:a3052f925ffc0c206fee2fef2092981f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2937b3712f2ac3f405da1b4ef495116a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a2937b3712f2ac3f405da1b4ef495116a">forgetRequestShallow</a> ()</td></tr>
<tr class="separator:a2937b3712f2ac3f405da1b4ef495116a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b5f430e040277eb0dbf46d62c049fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48b5f430e040277eb0dbf46d62c049fa"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>forget_request</b> ()</td></tr>
<tr class="separator:a48b5f430e040277eb0dbf46d62c049fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9691f132bb2bc8cf3ed5c27e6a1ef4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#aa9691f132bb2bc8cf3ed5c27e6a1ef4f">forget_request</a> (std::set&lt; <a class="el" href="classDD_1_1Image_1_1Op.html">Op</a> * &gt; &amp;forgotten)</td></tr>
<tr class="separator:aa9691f132bb2bc8cf3ed5c27e6a1ef4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1533af7ee9d451c0661ce2754d00877"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#aa1533af7ee9d451c0661ce2754d00877">node_shape</a> () const </td></tr>
<tr class="separator:aa1533af7ee9d451c0661ce2754d00877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae3432e06653e5c2fa86456b92fb832"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ae3432e06653e5c2fa86456b92fb832"></a>
<a class="el" href="classDD_1_1Image_1_1Hash.html">DD::Image::Hash</a>&#160;</td><td class="memItemRight" valign="bottom"><b>curveHash</b> () const </td></tr>
<tr class="separator:a8ae3432e06653e5c2fa86456b92fb832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad276709951b6f42196bc3d8d74c81cca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad276709951b6f42196bc3d8d74c81cca"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>opCurrent</b> () const </td></tr>
<tr class="separator:ad276709951b6f42196bc3d8d74c81cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1302934ae109973f546ace0c05ea1ed2"><td class="memItemLeft" align="right" valign="top">virtual unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a1302934ae109973f546ace0c05ea1ed2">node_color</a> () const </td></tr>
<tr class="separator:a1302934ae109973f546ace0c05ea1ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d9f3157dced5cc944383f7bde273787"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a7d9f3157dced5cc944383f7bde273787">node_help</a> () const  =0</td></tr>
<tr class="separator:a7d9f3157dced5cc944383f7bde273787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a213156968fa2fc9bbe92f40e059ea3"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a2a213156968fa2fc9bbe92f40e059ea3">input_label</a> (int, char *) const </td></tr>
<tr class="separator:a2a213156968fa2fc9bbe92f40e059ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c86d87e39b6e09733942f239ec98e61"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a5c86d87e39b6e09733942f239ec98e61">input_longlabel</a> (int) const </td></tr>
<tr class="separator:a5c86d87e39b6e09733942f239ec98e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a29ea27d511f7074d053df864c5195"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#aa3a29ea27d511f7074d053df864c5195">node_redraw</a> ()</td></tr>
<tr class="separator:aa3a29ea27d511f7074d053df864c5195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae750a8ab437bef1c4d9996932c661b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a6ae750a8ab437bef1c4d9996932c661b">print_name</a> (std::ostream &amp;o) const </td></tr>
<tr class="separator:a6ae750a8ab437bef1c4d9996932c661b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeae75f67ceb4736a1c5a61ce8634641c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDD_1_1Image_1_1Op.html#ab7e6c22841d12d4b8f4e908b066bfe6a">NodeContext</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#aeae75f67ceb4736a1c5a61ce8634641c">nodeContext</a> () const </td></tr>
<tr class="separator:aeae75f67ceb4736a1c5a61ce8634641c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d842d7fddc50c14c62d858834a19567"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a9d842d7fddc50c14c62d858834a19567">node_name</a> () const </td></tr>
<tr class="separator:a9d842d7fddc50c14c62d858834a19567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd4f2bebb93a913641767f6435374ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a7cd4f2bebb93a913641767f6435374ba">invalidateSameHash</a> ()</td></tr>
<tr class="separator:a7cd4f2bebb93a913641767f6435374ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad19589f141ad102c40fab9c26a87c5c8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#ad19589f141ad102c40fab9c26a87c5c8">invalidate</a> ()</td></tr>
<tr class="separator:ad19589f141ad102c40fab9c26a87c5c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2caca27ce7fdd46a10aecf83f5eded5c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a2caca27ce7fdd46a10aecf83f5eded5c">invalidate</a> (const <a class="el" href="classDD_1_1Image_1_1Hash.html">Hash</a> &amp;<a class="el" href="classDD_1_1Image_1_1Op.html#a69dfe1facc10819d7dc561ae1b380d66">hash</a>)</td></tr>
<tr class="separator:a2caca27ce7fdd46a10aecf83f5eded5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55bc746ee3e202be40a7ee047f7ee34c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a55bc746ee3e202be40a7ee047f7ee34c">update</a> (const <a class="el" href="classDD_1_1Image_1_1Box.html">Box</a> *=nullptr)</td></tr>
<tr class="separator:a55bc746ee3e202be40a7ee047f7ee34c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e77c16a84a6a5b4d2187636f320377b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a1e77c16a84a6a5b4d2187636f320377b">asapUpdate</a> ()</td></tr>
<tr class="separator:a1e77c16a84a6a5b4d2187636f320377b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb012ce54b0d105e14ac44b6df42b7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a6fb012ce54b0d105e14ac44b6df42b7d">asapUpdate</a> (const <a class="el" href="classDD_1_1Image_1_1Box.html">Box</a> &amp;box, int direction=0)</td></tr>
<tr class="separator:a6fb012ce54b0d105e14ac44b6df42b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54fe7079e0236ae45b247dd9f5e300b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a54fe7079e0236ae45b247dd9f5e300b4">validate</a> (bool for_real=true)</td></tr>
<tr class="separator:a54fe7079e0236ae45b247dd9f5e300b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae745e59a2aacee53458f598174fc4b9c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#ae745e59a2aacee53458f598174fc4b9c">force_validate</a> (bool for_real=true)</td></tr>
<tr class="separator:ae745e59a2aacee53458f598174fc4b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09098696d3daf186a96c0a615379c315"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09098696d3daf186a96c0a615379c315"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>update_handles</b> () const </td></tr>
<tr class="separator:a09098696d3daf186a96c0a615379c315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a353707a4e92ff1f1b5073550ef379a05"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a353707a4e92ff1f1b5073550ef379a05">valid</a> () const </td></tr>
<tr class="memdesc:a353707a4e92ff1f1b5073550ef379a05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if it has been validated - including if there was an error.  <a href="#a353707a4e92ff1f1b5073550ef379a05">More...</a><br /></td></tr>
<tr class="separator:a353707a4e92ff1f1b5073550ef379a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7621a25cd7093ca3b4ed32cbabe525"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#aaa7621a25cd7093ca3b4ed32cbabe525">real_valid</a> () const </td></tr>
<tr class="memdesc:aaa7621a25cd7093ca3b4ed32cbabe525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if it has been real-validated - including if there was an error.  <a href="#aaa7621a25cd7093ca3b4ed32cbabe525">More...</a><br /></td></tr>
<tr class="separator:aaa7621a25cd7093ca3b4ed32cbabe525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177707fd9f1dd4f89e21ad84cd0c8b18"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a177707fd9f1dd4f89e21ad84cd0c8b18"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>inErrorState</b> () const </td></tr>
<tr class="separator:a177707fd9f1dd4f89e21ad84cd0c8b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae19a11372cd278630729933bfabfa911"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae19a11372cd278630729933bfabfa911"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>inInvalidState</b> () const </td></tr>
<tr class="separator:ae19a11372cd278630729933bfabfa911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d52d583d589b5acb5fd18bb38349a20"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a8d52d583d589b5acb5fd18bb38349a20">opened</a> () const </td></tr>
<tr class="separator:a8d52d583d589b5acb5fd18bb38349a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bb868632c6116e335c689d78b18ba7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a2bb868632c6116e335c689d78b18ba7a">open</a> ()</td></tr>
<tr class="separator:a2bb868632c6116e335c689d78b18ba7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a0c71e772e5c9073baa995a6bb46344"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a0c71e772e5c9073baa995a6bb46344"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>unopen</b> ()</td></tr>
<tr class="separator:a7a0c71e772e5c9073baa995a6bb46344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1c254a46d65cbf9a15b3ffb76d20626"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#ad1c254a46d65cbf9a15b3ffb76d20626">running</a> () const </td></tr>
<tr class="separator:ad1c254a46d65cbf9a15b3ffb76d20626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc30fd36bf5527f2c49a259e57340fed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#adc30fd36bf5527f2c49a259e57340fed">running</a> (bool v)</td></tr>
<tr class="separator:adc30fd36bf5527f2c49a259e57340fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2140a1fbd44b54e7b127516890f1de05"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a2140a1fbd44b54e7b127516890f1de05">not_closed</a> () const </td></tr>
<tr class="separator:a2140a1fbd44b54e7b127516890f1de05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a009bdb3fc6cf7b4f33134c71585f2f4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a009bdb3fc6cf7b4f33134c71585f2f4a">close</a> ()</td></tr>
<tr class="separator:a009bdb3fc6cf7b4f33134c71585f2f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f6445522b9e247d90a14a093491e17e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a2f6445522b9e247d90a14a093491e17e">callCloseAfter</a> (double seconds)</td></tr>
<tr class="separator:a2f6445522b9e247d90a14a093491e17e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09523a2232d68d4a5f0d27059194a279"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a09523a2232d68d4a5f0d27059194a279">copyState</a> (<a class="el" href="classDD_1_1Image_1_1Op.html">Op</a> *<a class="el" href="classDD_1_1Image_1_1Op.html#a3f8fb27d42f6da712722fa73eda6b5b0">input</a>)</td></tr>
<tr class="separator:a09523a2232d68d4a5f0d27059194a279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7348c3d34ca6acbd7a7dc0d6c8dff46d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7348c3d34ca6acbd7a7dc0d6c8dff46d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>cached</b> () const </td></tr>
<tr class="separator:a7348c3d34ca6acbd7a7dc0d6c8dff46d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af1b269af5f2a30e9d72d6001509775"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a9af1b269af5f2a30e9d72d6001509775">cached</a> (bool b)</td></tr>
<tr class="separator:a9af1b269af5f2a30e9d72d6001509775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8cb3de6c3434199d78bdd78ed144f2b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8cb3de6c3434199d78bdd78ed144f2b"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>inUse</b> () const </td></tr>
<tr class="separator:ae8cb3de6c3434199d78bdd78ed144f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd5eaba4391ab6908a8f06b4a466a103"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classDD_1_1Image_1_1Executable.html">Executable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#afd5eaba4391ab6908a8f06b4a466a103">executable</a> ()</td></tr>
<tr class="separator:afd5eaba4391ab6908a8f06b4a466a103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab886234f0358b0898f17ad52c8a27b3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#ab886234f0358b0898f17ad52c8a27b3a">setKnobsToContext</a> (const <a class="el" href="classDD_1_1Image_1_1OutputContext.html">OutputContext</a> &amp;)</td></tr>
<tr class="separator:ab886234f0358b0898f17ad52c8a27b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a268210647796fd4cc9251ae3317e469f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a268210647796fd4cc9251ae3317e469f">gotoContext</a> (const <a class="el" href="classDD_1_1Image_1_1OutputContext.html">OutputContext</a> &amp;, bool <a class="el" href="classDD_1_1Image_1_1Op.html#a55bc746ee3e202be40a7ee047f7ee34c">update</a>)</td></tr>
<tr class="separator:a268210647796fd4cc9251ae3317e469f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a178abeee0e49785e55d1a08033e9f313"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a178abeee0e49785e55d1a08033e9f313">progressFraction</a> (double fraction, <a class="el" href="classDD_1_1Image_1_1Op.html#ad05eb8420166eff8fabdb30b8fe9c13c">StatusFlags</a> flags=StatusNone)</td></tr>
<tr class="separator:a178abeee0e49785e55d1a08033e9f313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae967dcf63a16e9bde6989a323692f377"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae967dcf63a16e9bde6989a323692f377"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>progressFraction</b> (int a, int b, <a class="el" href="classDD_1_1Image_1_1Op.html#ad05eb8420166eff8fabdb30b8fe9c13c">StatusFlags</a> flags=StatusNone)</td></tr>
<tr class="separator:ae967dcf63a16e9bde6989a323692f377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c62b98ae62d3715b7c5b5a0c3817e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a04c62b98ae62d3715b7c5b5a0c3817e5">progressMessage</a> (const char *fmt,...)</td></tr>
<tr class="separator:a04c62b98ae62d3715b7c5b5a0c3817e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bb5deb08857a1028f3c7b45d1f70ae0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9bb5deb08857a1028f3c7b45d1f70ae0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>progressModalMessage</b> (const char *fmt,...)</td></tr>
<tr class="separator:a9bb5deb08857a1028f3c7b45d1f70ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d39f91bb365a356a69daccefae71fa0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a7d39f91bb365a356a69daccefae71fa0">progressDismiss</a> ()</td></tr>
<tr class="separator:a7d39f91bb365a356a69daccefae71fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7118c510e04b1e87737f9e2eec6785e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#aa7118c510e04b1e87737f9e2eec6785e">slowness</a> () const </td></tr>
<tr class="separator:aa7118c510e04b1e87737f9e2eec6785e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5200e6df02ebacdc0e9dae4757cbcd66"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5200e6df02ebacdc0e9dae4757cbcd66"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>slowness</b> (int newval)</td></tr>
<tr class="separator:a5200e6df02ebacdc0e9dae4757cbcd66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1356e393d10799db80da19e27310ac82"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a1356e393d10799db80da19e27310ac82">firstEngineRendersWholeRequest</a> () const </td></tr>
<tr class="separator:a1356e393d10799db80da19e27310ac82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a97a23daa29fcc1466a99d88595b73"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#ac7a97a23daa29fcc1466a99d88595b73">updateUI</a> (const <a class="el" href="classDD_1_1Image_1_1OutputContext.html">OutputContext</a> &amp;context)</td></tr>
<tr class="separator:ac7a97a23daa29fcc1466a99d88595b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad131c925b04abdeb048c5a0ae0012f97"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDD_1_1Image_1_1Format.html">Format</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#ad131c925b04abdeb048c5a0ae0012f97">input_format</a> () const </td></tr>
<tr class="separator:ad131c925b04abdeb048c5a0ae0012f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4cf62da84ac80bf8c53ee99aeebb66"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDD_1_1Image_1_1OutputContext.html">OutputContext</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#aec4cf62da84ac80bf8c53ee99aeebb66">uiContext</a> () const </td></tr>
<tr class="separator:aec4cf62da84ac80bf8c53ee99aeebb66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc3f4acb738937d3319707849fe1b26f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#afc3f4acb738937d3319707849fe1b26f">error</a> (const char *fmt,...)</td></tr>
<tr class="separator:afc3f4acb738937d3319707849fe1b26f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad20367c3afd62cd40a9c4f13848e3ae3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#ad20367c3afd62cd40a9c4f13848e3ae3">warning</a> (const char *fmt,...)</td></tr>
<tr class="separator:ad20367c3afd62cd40a9c4f13848e3ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2058a0ade50b432f556bf5495a7cb3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#ae2058a0ade50b432f556bf5495a7cb3a">critical</a> (const char *fmt,...)</td></tr>
<tr class="separator:ae2058a0ade50b432f556bf5495a7cb3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae90a6cff9b671dac3e5fcfd9809770f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#ae90a6cff9b671dac3e5fcfd9809770f2">debug</a> (const char *fmt,...)</td></tr>
<tr class="separator:ae90a6cff9b671dac3e5fcfd9809770f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2bc52a1cf2100f5e21446af388e1afb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2bc52a1cf2100f5e21446af388e1afb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#ad2bc52a1cf2100f5e21446af388e1afb">abort</a> () const </td></tr>
<tr class="memdesc:ad2bc52a1cf2100f5e21446af388e1afb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abort all trees the op is in. <br /></td></tr>
<tr class="separator:ad2bc52a1cf2100f5e21446af388e1afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af31a7c1b2fd23639d56c4e6a11c362d9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af31a7c1b2fd23639d56c4e6a11c362d9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#af31a7c1b2fd23639d56c4e6a11c362d9">aborted</a> () const </td></tr>
<tr class="memdesc:af31a7c1b2fd23639d56c4e6a11c362d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if one of the trees the op is in was aborted; ops should check this while processing and return quickly when true. <br /></td></tr>
<tr class="separator:af31a7c1b2fd23639d56c4e6a11c362d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf426eab2cede6dbe30e9d6746923ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abcf426eab2cede6dbe30e9d6746923ca"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#abcf426eab2cede6dbe30e9d6746923ca">cancel</a> () const </td></tr>
<tr class="memdesc:abcf426eab2cede6dbe30e9d6746923ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel all trees the op is in. Make sure you also call <em><a class="el" href="classDD_1_1Image_1_1Op.html#ad2bc52a1cf2100f5e21446af388e1afb" title="Abort all trees the op is in. ">abort()</a></em> to stop processing. <br /></td></tr>
<tr class="separator:abcf426eab2cede6dbe30e9d6746923ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a179e264be537d6ae0e3d0d0e15009fa4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a179e264be537d6ae0e3d0d0e15009fa4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a179e264be537d6ae0e3d0d0e15009fa4">cancelled</a> () const </td></tr>
<tr class="memdesc:a179e264be537d6ae0e3d0d0e15009fa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if one of the trees the op is in was cancelled (by user interaction) <br /></td></tr>
<tr class="separator:a179e264be537d6ae0e3d0d0e15009fa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc50640a4193fbadca8ea35ceadbb2c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc50640a4193fbadca8ea35ceadbb2c0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#adc50640a4193fbadca8ea35ceadbb2c0">addToTree</a> (<a class="el" href="classDD_1_1Image_1_1OpTree.html">OpTree</a> *lpTree)</td></tr>
<tr class="memdesc:adc50640a4193fbadca8ea35ceadbb2c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the op was added to the tree, or false if its reference count increased. <br /></td></tr>
<tr class="separator:adc50640a4193fbadca8ea35ceadbb2c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9dd1c442548369ac0de310842175fd1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac9dd1c442548369ac0de310842175fd1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#ac9dd1c442548369ac0de310842175fd1">removeFromTree</a> (<a class="el" href="classDD_1_1Image_1_1OpTree.html">OpTree</a> *lpTree)</td></tr>
<tr class="memdesc:ac9dd1c442548369ac0de310842175fd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns false if the op was removed from the tree, or true if its reference count decreased. <br /></td></tr>
<tr class="separator:ac9dd1c442548369ac0de310842175fd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f114b29137bb863a7e0286195fc7286"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f114b29137bb863a7e0286195fc7286"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a2f114b29137bb863a7e0286195fc7286">isInTree</a> (<a class="el" href="classDD_1_1Image_1_1OpTree.html">OpTree</a> *lpTree) const </td></tr>
<tr class="memdesc:a2f114b29137bb863a7e0286195fc7286"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an op is in a particular tree, for debugging purposes. <br /></td></tr>
<tr class="separator:a2f114b29137bb863a7e0286195fc7286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8a5d6eec289d1f2d2a9377227746e06"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac8a5d6eec289d1f2d2a9377227746e06"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#ac8a5d6eec289d1f2d2a9377227746e06">isInAnyTree</a> () const </td></tr>
<tr class="memdesc:ac8a5d6eec289d1f2d2a9377227746e06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an op is in any tree at all. <br /></td></tr>
<tr class="separator:ac8a5d6eec289d1f2d2a9377227746e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c9d6a4eb1986bf7211f518662f6556"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a14c9d6a4eb1986bf7211f518662f6556"></a>
<a class="el" href="classDD_1_1Image_1_1OpTreeHandler.html">OpTreeHandler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a14c9d6a4eb1986bf7211f518662f6556">getTreeHandler</a> () const </td></tr>
<tr class="memdesc:a14c9d6a4eb1986bf7211f518662f6556"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the treeHandler for a given <a class="el" href="classDD_1_1Image_1_1Op.html" title="Base class of all the things that can be created by Nuke nodes. ">Op</a>. <br /></td></tr>
<tr class="separator:a14c9d6a4eb1986bf7211f518662f6556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443106e419573550ccc22812c0bb3f18"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a443106e419573550ccc22812c0bb3f18">hasError</a> () const </td></tr>
<tr class="separator:a443106e419573550ccc22812c0bb3f18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a66b0df5e35b445a2e820018b842b6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#ab8a66b0df5e35b445a2e820018b842b6">opOrChildHasError</a> () const </td></tr>
<tr class="separator:ab8a66b0df5e35b445a2e820018b842b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad14f3cda4abcb6cda3f0f07101558889"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad14f3cda4abcb6cda3f0f07101558889"></a>
const <a class="el" href="classDD_1_1Image_1_1Op.html">Op</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getErroredOp</b> () const </td></tr>
<tr class="separator:ad14f3cda4abcb6cda3f0f07101558889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa806cde6e56b2bca6ca11da8280efef8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa806cde6e56b2bca6ca11da8280efef8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setPopUpScheme</b> (<a class="el" href="classDD_1_1Image_1_1Op.html#afbc2750a2e33057090759ec5844cd4bd">PopUpScheme</a> lScheme)</td></tr>
<tr class="separator:aa806cde6e56b2bca6ca11da8280efef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25033412cb001e66686e76773d976efa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25033412cb001e66686e76773d976efa"></a>
<a class="el" href="classDD_1_1Image_1_1Op.html#afbc2750a2e33057090759ec5844cd4bd">PopUpScheme</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getPopUpScheme</b> () const </td></tr>
<tr class="separator:a25033412cb001e66686e76773d976efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97448cba4119292908e3ee1438f31bdc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97448cba4119292908e3ee1438f31bdc"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a97448cba4119292908e3ee1438f31bdc">arePopUpsEnabled</a> ()</td></tr>
<tr class="memdesc:a97448cba4119292908e3ee1438f31bdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a pop-up should be enabled for the next message, modifying internal data when necessary. <br /></td></tr>
<tr class="separator:a97448cba4119292908e3ee1438f31bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d2c3b21cad6ad05f2dd69aa2e696c43"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d2c3b21cad6ad05f2dd69aa2e696c43"></a>
<a class="el" href="classDD_1_1Image_1_1OpMessageHandler.html">OpMessageHandler</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getMsgHandler</b> ()</td></tr>
<tr class="separator:a8d2c3b21cad6ad05f2dd69aa2e696c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dad677183711caa2b11e26aee15c874"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4dad677183711caa2b11e26aee15c874"></a>
const <a class="el" href="classDD_1_1Image_1_1OpMessageHandler.html">OpMessageHandler</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getMsgHandler</b> () const </td></tr>
<tr class="separator:a4dad677183711caa2b11e26aee15c874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a399f3b30fc69d633536fd9d08e34cf6e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a399f3b30fc69d633536fd9d08e34cf6e"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a399f3b30fc69d633536fd9d08e34cf6e">getDebugInfo</a> () const </td></tr>
<tr class="memdesc:a399f3b30fc69d633536fd9d08e34cf6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string of debug information about the op. For internal use. <br /></td></tr>
<tr class="separator:a399f3b30fc69d633536fd9d08e34cf6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c9f4e458aeb126a2e480525fe984af4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c9f4e458aeb126a2e480525fe984af4"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getDetailedDebugInfo</b> () const </td></tr>
<tr class="separator:a0c9f4e458aeb126a2e480525fe984af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab007448be5c7c917810e59515c209718"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#ab007448be5c7c917810e59515c209718">tryValidate</a> (bool for_real=true)</td></tr>
<tr class="separator:ab007448be5c7c917810e59515c209718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24e0d3db1f380929ed86e4a0a5913c1d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a24e0d3db1f380929ed86e4a0a5913c1d"></a>
virtual <a class="el" href="classDD_1_1Image_1_1Iop.html">Iop</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a24e0d3db1f380929ed86e4a0a5913c1d">iop</a> ()</td></tr>
<tr class="memdesc:a24e0d3db1f380929ed86e4a0a5913c1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast to an <a class="el" href="classDD_1_1Image_1_1Iop.html" title="Iop is the base class for all the image operators. ">Iop</a>. This is much cheaper and safer than using dynamic_cast. <br /></td></tr>
<tr class="separator:a24e0d3db1f380929ed86e4a0a5913c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a1c344be0f5eff664d3865a17d5e599"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a1c344be0f5eff664d3865a17d5e599"></a>
virtual const <a class="el" href="classDD_1_1Image_1_1Iop.html">Iop</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>iop</b> () const </td></tr>
<tr class="separator:a7a1c344be0f5eff664d3865a17d5e599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d002d52611ae0f41c94caacc67d9488"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d002d52611ae0f41c94caacc67d9488"></a>
virtual <a class="el" href="classDD_1_1Image_1_1GeoOp.html">GeoOp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a5d002d52611ae0f41c94caacc67d9488">geoOp</a> ()</td></tr>
<tr class="memdesc:a5d002d52611ae0f41c94caacc67d9488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast to a <a class="el" href="classDD_1_1Image_1_1GeoOp.html">GeoOp</a>. This is much cheaper and safer than using dynamic_cast. <br /></td></tr>
<tr class="separator:a5d002d52611ae0f41c94caacc67d9488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94bf4287ba05946187b5a2cce1e3a505"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94bf4287ba05946187b5a2cce1e3a505"></a>
virtual const <a class="el" href="classDD_1_1Image_1_1GeoOp.html">GeoOp</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>geoOp</b> () const </td></tr>
<tr class="separator:a94bf4287ba05946187b5a2cce1e3a505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf499fe6ef8a48bf84f345776e8bd4e4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf499fe6ef8a48bf84f345776e8bd4e4"></a>
virtual <a class="el" href="classDD_1_1Image_1_1ParticleOp.html">ParticleOp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#adf499fe6ef8a48bf84f345776e8bd4e4">particleOp</a> ()</td></tr>
<tr class="memdesc:adf499fe6ef8a48bf84f345776e8bd4e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast to a <a class="el" href="classDD_1_1Image_1_1ParticleOp.html">ParticleOp</a>. This is much cheaper and safer than using dynamic_cast. <br /></td></tr>
<tr class="separator:adf499fe6ef8a48bf84f345776e8bd4e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac55db723d5aaeeaa96577a1d3faa3dd3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac55db723d5aaeeaa96577a1d3faa3dd3"></a>
virtual const <a class="el" href="classDD_1_1Image_1_1ParticleOp.html">ParticleOp</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>particleOp</b> () const </td></tr>
<tr class="separator:ac55db723d5aaeeaa96577a1d3faa3dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d319f07a4b065aac013355859adc87"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4d319f07a4b065aac013355859adc87"></a>
virtual <a class="el" href="classDD_1_1Image_1_1DeepOnlyOp.html">DeepOnlyOp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#af4d319f07a4b065aac013355859adc87">deepOnlyOp</a> ()</td></tr>
<tr class="memdesc:af4d319f07a4b065aac013355859adc87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast to a <a class="el" href="classDD_1_1Image_1_1DeepOnlyOp.html">DeepOnlyOp</a>. This is much cheaper and safer than using dynamic_cast. <br /></td></tr>
<tr class="separator:af4d319f07a4b065aac013355859adc87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa59f8dc18f145634cfc253c7a469f5d4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa59f8dc18f145634cfc253c7a469f5d4"></a>
virtual const <a class="el" href="classDD_1_1Image_1_1DeepOnlyOp.html">DeepOnlyOp</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>deepOnlyOp</b> () const </td></tr>
<tr class="separator:aa59f8dc18f145634cfc253c7a469f5d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcd7e0b3d7926230d932d16f7ff7f995"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abcd7e0b3d7926230d932d16f7ff7f995"></a>
virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#abcd7e0b3d7926230d932d16f7ff7f995">getLibraryName</a> () const </td></tr>
<tr class="memdesc:abcd7e0b3d7926230d932d16f7ff7f995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a label and version string to display library version info for the Node. <br /></td></tr>
<tr class="separator:abcd7e0b3d7926230d932d16f7ff7f995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a471450d6e925c6b49c8e49d28ee2e128"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a471450d6e925c6b49c8e49d28ee2e128"></a>
virtual <a class="el" href="classDD_1_1Image_1_1Op.html#a98542a0dc83294f62271afbc44e3d86b">VersionInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getLibraryVersion</b> () const </td></tr>
<tr class="separator:a471450d6e925c6b49c8e49d28ee2e128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90329b91e3771603e6b7e6088673fe3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af90329b91e3771603e6b7e6088673fe3"></a>
virtual <a class="el" href="namespaceDD_1_1Image.html#ad201a5778276f385a04f007f6705fca5">OpHints</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#af90329b91e3771603e6b7e6088673fe3">opHints</a> () const </td></tr>
<tr class="memdesc:af90329b91e3771603e6b7e6088673fe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return hints to control when and how this op will be evaluated by the top-down system. <br /></td></tr>
<tr class="separator:af90329b91e3771603e6b7e6088673fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc5fd8a59a843cfd322b132b5ae426d"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a4fc5fd8a59a843cfd322b132b5ae426d">Class</a> () const  =0</td></tr>
<tr class="separator:a4fc5fd8a59a843cfd322b132b5ae426d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13168087d6ac700724e51387ab747c5f"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a13168087d6ac700724e51387ab747c5f">libraryDisplayName</a> () const </td></tr>
<tr class="separator:a13168087d6ac700724e51387ab747c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a833d6b240f57340f721e6d58b0b7ed3b"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a833d6b240f57340f721e6d58b0b7ed3b">displayName</a> () const </td></tr>
<tr class="separator:a833d6b240f57340f721e6d58b0b7ed3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa284f1588298fbf3a65f7e6eb3dfcfe9"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#aa284f1588298fbf3a65f7e6eb3dfcfe9">docsPath</a> () const </td></tr>
<tr class="separator:aa284f1588298fbf3a65f7e6eb3dfcfe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77dbe02db9c352f699eb20a527b5a95b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a77dbe02db9c352f699eb20a527b5a95b">onAction</a> (const <a class="el" href="classDD_1_1Image_1_1ViewerContext.html">ViewerContext</a> *c, const DD::Image::Flags f, void *d)</td></tr>
<tr class="separator:a77dbe02db9c352f699eb20a527b5a95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8dbbc4a153095c890f0bc50754fd53d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDD_1_1Image_1_1Op.html">Op</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#ac8dbbc4a153095c890f0bc50754fd53d">get</a> (const <a class="el" href="classDD_1_1Image_1_1Op_1_1Description.html">Description</a> *description)</td></tr>
<tr class="separator:ac8dbbc4a153095c890f0bc50754fd53d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:afce84780f6ddda80a21bd8f395ec5213"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afce84780f6ddda80a21bd8f395ec5213"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#afce84780f6ddda80a21bd8f395ec5213">treeVersion</a> ()</td></tr>
<tr class="memdesc:afce84780f6ddda80a21bd8f395ec5213"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the current tree version <br /></td></tr>
<tr class="separator:afce84780f6ddda80a21bd8f395ec5213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc3eaa72317ac7b4353188ba80e970b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0bc3eaa72317ac7b4353188ba80e970b"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a0bc3eaa72317ac7b4353188ba80e970b">nukeBusy</a> ()</td></tr>
<tr class="memdesc:a0bc3eaa72317ac7b4353188ba80e970b"><td class="mdescLeft">&#160;</td><td class="mdescRight">is nuke processing something on a parallel thread? <br /></td></tr>
<tr class="separator:a0bc3eaa72317ac7b4353188ba80e970b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7e22a28052346e485eb43ad1a4487e3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab7e22a28052346e485eb43ad1a4487e3"></a>
static <a class="el" href="classDD_1_1Image_1_1Op.html">Op</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>create</b> (Node *<a class="el" href="classDD_1_1Image_1_1Op.html#a1e65ba0209479090ca51fc3d0b60e8ea">node</a>, const char *name, <a class="el" href="classDD_1_1Image_1_1Op.html">Op</a> *p_op)</td></tr>
<tr class="separator:ab7e22a28052346e485eb43ad1a4487e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ef702ca3ae5f96fdb3311172b1949a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ef702ca3ae5f96fdb3311172b1949a3"></a>
static <a class="el" href="classDD_1_1Image_1_1Op.html">Op</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>create</b> (const char *name, <a class="el" href="classDD_1_1Image_1_1Op.html">Op</a> *p_op)</td></tr>
<tr class="separator:a2ef702ca3ae5f96fdb3311172b1949a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcf52066f5c15f92b40bc3e342f0213c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adcf52066f5c15f92b40bc3e342f0213c"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#adcf52066f5c15f92b40bc3e342f0213c">resetTimers</a> ()</td></tr>
<tr class="memdesc:adcf52066f5c15f92b40bc3e342f0213c"><td class="mdescLeft">&#160;</td><td class="mdescRight">reset all the performance timers <br /></td></tr>
<tr class="separator:adcf52066f5c15f92b40bc3e342f0213c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58e9a200d0a0b6084282ccc54a8bb7b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58e9a200d0a0b6084282ccc54a8bb7b4"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a58e9a200d0a0b6084282ccc54a8bb7b4">setTimingEnabled</a> (bool enabled)</td></tr>
<tr class="memdesc:a58e9a200d0a0b6084282ccc54a8bb7b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">turn performance timing on or off <br /></td></tr>
<tr class="separator:a58e9a200d0a0b6084282ccc54a8bb7b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33cd540c69e5a953419522071ef0c208"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33cd540c69e5a953419522071ef0c208"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a33cd540c69e5a953419522071ef0c208">isTimingEnabled</a> ()</td></tr>
<tr class="memdesc:a33cd540c69e5a953419522071ef0c208"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether performance timing is on or not <br /></td></tr>
<tr class="separator:a33cd540c69e5a953419522071ef0c208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf4e21f64f6c0baadf262531f269294f"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#adf4e21f64f6c0baadf262531f269294f">script_result</a> (bool py=false)</td></tr>
<tr class="separator:adf4e21f64f6c0baadf262531f269294f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a247330fc3bf38dd571628fce4b7c1e58"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a247330fc3bf38dd571628fce4b7c1e58">script_unlock</a> ()</td></tr>
<tr class="separator:a247330fc3bf38dd571628fce4b7c1e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59bb602b8d5e6baed304616a5c2122b0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a59bb602b8d5e6baed304616a5c2122b0">all_forget_request</a> ()</td></tr>
<tr class="separator:a59bb602b8d5e6baed304616a5c2122b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a129ccef599f8b61209481f6833e472f6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a129ccef599f8b61209481f6833e472f6"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>new_request_pass</b> ()</td></tr>
<tr class="separator:a129ccef599f8b61209481f6833e472f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a3799eeee2ba718507d2be641fd59f"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#ac5a3799eeee2ba718507d2be641fd59f">callPendingClose</a> (double seconds)</td></tr>
<tr class="separator:ac5a3799eeee2ba718507d2be641fd59f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f532639c9ff313225611a4935affe64"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a5f532639c9ff313225611a4935affe64">clearPendingClose</a> ()</td></tr>
<tr class="separator:a5f532639c9ff313225611a4935affe64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fd4d927f78192165d0a4da61a8a2803"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classDD_1_1Image_1_1Op.html">Op</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a3fd4d927f78192165d0a4da61a8a2803">error_op</a> ()</td></tr>
<tr class="separator:a3fd4d927f78192165d0a4da61a8a2803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a2ac728424be8a75b609801fde5804b"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a3a2ac728424be8a75b609801fde5804b">error_message</a> ()</td></tr>
<tr class="separator:a3a2ac728424be8a75b609801fde5804b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e399ba5a3b5870985bda34d49bbc77"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac2e399ba5a3b5870985bda34d49bbc77"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#ac2e399ba5a3b5870985bda34d49bbc77">clearAbortAndError</a> ()</td></tr>
<tr class="memdesc:ac2e399ba5a3b5870985bda34d49bbc77"><td class="mdescLeft">&#160;</td><td class="mdescRight">To be removed. <br /></td></tr>
<tr class="separator:ac2e399ba5a3b5870985bda34d49bbc77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77ba3dddb95c9eb7f72a784bcf08fb4f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77ba3dddb95c9eb7f72a784bcf08fb4f"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a77ba3dddb95c9eb7f72a784bcf08fb4f">SetDefaultPopUpEnable</a> (bool lEnable)</td></tr>
<tr class="memdesc:a77ba3dddb95c9eb7f72a784bcf08fb4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used by Nuke to indicate when ops using the default pop-up scheme should show pop-ups. Not recommended for customisation. <br /></td></tr>
<tr class="separator:a77ba3dddb95c9eb7f72a784bcf08fb4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad70244d478609ac267f25c5da19dd7c7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad70244d478609ac267f25c5da19dd7c7"></a>
static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#ad70244d478609ac267f25c5da19dd7c7">getVersionInfoStr</a> (const <a class="el" href="classDD_1_1Image_1_1Op.html#a98542a0dc83294f62271afbc44e3d86b">VersionInfo</a> &amp;versionInfo)</td></tr>
<tr class="memdesc:ad70244d478609ac267f25c5da19dd7c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to convert a VersionInfo tuple into a string. <br /></td></tr>
<tr class="separator:ad70244d478609ac267f25c5da19dd7c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acebc17c770453f35c1cf012abc3a34d6"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classDD_1_1Image_1_1Op_1_1Description.html">Description</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#acebc17c770453f35c1cf012abc3a34d6">find_description</a> (const char *name, const <a class="el" href="classDD_1_1Image_1_1Op.html">Op</a> *op_)</td></tr>
<tr class="separator:acebc17c770453f35c1cf012abc3a34d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a285efb59707933179ee733d71331ffcc"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a285efb59707933179ee733d71331ffcc">message_f</a> (char t, const char *,...)</td></tr>
<tr class="separator:a285efb59707933179ee733d71331ffcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90bfc1752627fa7caa67fddcd1fc1c9c"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a90bfc1752627fa7caa67fddcd1fc1c9c">message_vf</a> (char t, const char *, va_list)</td></tr>
<tr class="separator:a90bfc1752627fa7caa67fddcd1fc1c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb3d3b16d4e4f70dc5ec0b0545a99da"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a2cb3d3b16d4e4f70dc5ec0b0545a99da">add_timeout</a> (float t, TimeoutHandler, void *v=nullptr)</td></tr>
<tr class="separator:a2cb3d3b16d4e4f70dc5ec0b0545a99da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1043cf2af70846b8f7481c45e1ebead"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#ac1043cf2af70846b8f7481c45e1ebead">repeat_timeout</a> (float t, TimeoutHandler, void *=nullptr)</td></tr>
<tr class="separator:ac1043cf2af70846b8f7481c45e1ebead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865f2230aa48e64e4ac7afbebe1ff1a3"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a865f2230aa48e64e4ac7afbebe1ff1a3">has_timeout</a> (TimeoutHandler, void *=nullptr)</td></tr>
<tr class="separator:a865f2230aa48e64e4ac7afbebe1ff1a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01f1546aca4511bae387fa46fd84fe3e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a01f1546aca4511bae387fa46fd84fe3e">remove_timeout</a> (TimeoutHandler, void *=nullptr)</td></tr>
<tr class="separator:a01f1546aca4511bae387fa46fd84fe3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a5c33aa9be83595fd26a46e7e9de0264a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c33aa9be83595fd26a46e7e9de0264a"></a>
const <a class="el" href="classDD_1_1Image_1_1MetaData_1_1Bundle.html">MetaData::Bundle</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>metaCache</b></td></tr>
<tr class="separator:a5c33aa9be83595fd26a46e7e9de0264a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb94e65bda14fe1738321744015e9daf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb94e65bda14fe1738321744015e9daf"></a>
<a class="el" href="classDD_1_1Image_1_1Hash.html">Hash</a>&#160;</td><td class="memItemRight" valign="bottom"><b>metaCacheHash</b></td></tr>
<tr class="separator:acb94e65bda14fe1738321744015e9daf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a995f0f03d534d3eb2c9d75efea6b5193"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a995f0f03d534d3eb2c9d75efea6b5193"></a>
static unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>current_request_pass</b></td></tr>
<tr class="separator:a995f0f03d534d3eb2c9d75efea6b5193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6f647e85b45e6b7079bb17471273d90"><td class="memItemLeft" align="right" valign="top">static void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#ae6f647e85b45e6b7079bb17471273d90">node_redraw_cb</a> )(const <a class="el" href="classDD_1_1Image_1_1Op.html">Op</a> *)</td></tr>
<tr class="separator:ae6f647e85b45e6b7079bb17471273d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad54373ae41fee669bef9bc61827944fe"><td class="memItemLeft" align="right" valign="top">static void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#ad54373ae41fee669bef9bc61827944fe">print_name_cb</a> )(std::ostream &amp;, const <a class="el" href="classDD_1_1Image_1_1Op.html">Op</a> *)</td></tr>
<tr class="separator:ad54373ae41fee669bef9bc61827944fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84d331e6b34badaa5f9678dd6df6917b"><td class="memItemLeft" align="right" valign="top">static void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a84d331e6b34badaa5f9678dd6df6917b">status_callback</a> )(const <a class="el" href="classDD_1_1Image_1_1Op.html">Op</a> *, float, float, const char *, <a class="el" href="classDD_1_1Image_1_1Op.html#ad05eb8420166eff8fabdb30b8fe9c13c">StatusFlags</a>)</td></tr>
<tr class="separator:a84d331e6b34badaa5f9678dd6df6917b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5412dbf804691548f39ff9c2f20245a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa5412dbf804691548f39ff9c2f20245a"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>kInvalidVersion</b></td></tr>
<tr class="separator:aa5412dbf804691548f39ff9c2f20245a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9937b4d1b518e5c447a64649d7e2312e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9937b4d1b518e5c447a64649d7e2312e"></a>
static constexpr <a class="el" href="classDD_1_1Image_1_1Op.html#a98542a0dc83294f62271afbc44e3d86b">VersionInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><b>kUnsetVersion</b></td></tr>
<tr class="separator:a9937b4d1b518e5c447a64649d7e2312e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aa556ff07c78ede58fb5f3ed18f7b625d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa556ff07c78ede58fb5f3ed18f7b625d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#aa556ff07c78ede58fb5f3ed18f7b625d">Op</a> (Node *<a class="el" href="classDD_1_1Image_1_1Op.html#a1e65ba0209479090ca51fc3d0b60e8ea">node</a>)</td></tr>
<tr class="memdesc:aa556ff07c78ede58fb5f3ed18f7b625d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The constructor is protected so only subclasses can create the base class. <br /></td></tr>
<tr class="separator:aa556ff07c78ede58fb5f3ed18f7b625d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad18224f6cf7702991dd646addee0fbe5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#ad18224f6cf7702991dd646addee0fbe5">_invalidate</a> ()</td></tr>
<tr class="separator:ad18224f6cf7702991dd646addee0fbe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1dc586d97dd3e752bd3573bb7665b84"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#ae1dc586d97dd3e752bd3573bb7665b84">_validate</a> (bool for_real)</td></tr>
<tr class="separator:ae1dc586d97dd3e752bd3573bb7665b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a019d714de0d947176450c68df0f6f9e6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a019d714de0d947176450c68df0f6f9e6">_open</a> ()</td></tr>
<tr class="separator:a019d714de0d947176450c68df0f6f9e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99957cf4eabecb46ddfb5497766ccca6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a99957cf4eabecb46ddfb5497766ccca6">_close</a> ()</td></tr>
<tr class="separator:a99957cf4eabecb46ddfb5497766ccca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9ffa08d0a7e8b1d071a6f7bdcb5e106"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDD_1_1Image_1_1Op.html">Op</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#ab9ffa08d0a7e8b1d071a6f7bdcb5e106">create</a> (Node *<a class="el" href="classDD_1_1Image_1_1Op.html#a1e65ba0209479090ca51fc3d0b60e8ea">node</a>, const char *name)</td></tr>
<tr class="separator:ab9ffa08d0a7e8b1d071a6f7bdcb5e106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dbd9791d20163b06fc7b41dc7ecc9ba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7dbd9791d20163b06fc7b41dc7ecc9ba"></a>
<a class="el" href="classDD_1_1Image_1_1Op.html">Op</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>create</b> (const char *name)</td></tr>
<tr class="separator:a7dbd9791d20163b06fc7b41dc7ecc9ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba30401a92a6ad3c629b5246e85cdbad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDD_1_1Image_1_1Op.html#aaec7731a5d44a5b3db2fdd6aa6549f00">HandlesMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#aba30401a92a6ad3c629b5246e85cdbad">anyInputHandles</a> (<a class="el" href="classDD_1_1Image_1_1ViewerContext.html">ViewerContext</a> *)</td></tr>
<tr class="memdesc:aba30401a92a6ad3c629b5246e85cdbad"><td class="mdescLeft">&#160;</td><td class="mdescRight">return if any of the inputs (recursively) wish to draw handles  <a href="#aba30401a92a6ad3c629b5246e85cdbad">More...</a><br /></td></tr>
<tr class="separator:aba30401a92a6ad3c629b5246e85cdbad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be228bb3a6b9d696e924b6990b68c15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDD_1_1Image_1_1Op.html#aaec7731a5d44a5b3db2fdd6aa6549f00">HandlesMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a0be228bb3a6b9d696e924b6990b68c15">anyKnobHandles</a> (<a class="el" href="classDD_1_1Image_1_1ViewerContext.html">ViewerContext</a> *)</td></tr>
<tr class="memdesc:a0be228bb3a6b9d696e924b6990b68c15"><td class="mdescLeft">&#160;</td><td class="mdescRight">return if any of the knobs on this node wish to draw handles  <a href="#a0be228bb3a6b9d696e924b6990b68c15">More...</a><br /></td></tr>
<tr class="separator:a0be228bb3a6b9d696e924b6990b68c15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad953c3235503acb40a508a38458970ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#ad953c3235503acb40a508a38458970ae">build_input_handles</a> (<a class="el" href="classDD_1_1Image_1_1ViewerContext.html">ViewerContext</a> *)</td></tr>
<tr class="separator:ad953c3235503acb40a508a38458970ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abee83f5231cc1015a0b30e7b4527f47a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#abee83f5231cc1015a0b30e7b4527f47a">build_knob_handles</a> (<a class="el" href="classDD_1_1Image_1_1ViewerContext.html">ViewerContext</a> *)</td></tr>
<tr class="separator:abee83f5231cc1015a0b30e7b4527f47a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e1043e07bfb9c83ee8d02d1580fa92f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e1043e07bfb9c83ee8d02d1580fa92f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a1e1043e07bfb9c83ee8d02d1580fa92f">disallowNoTrees</a> ()</td></tr>
<tr class="memdesc:a1e1043e07bfb9c83ee8d02d1580fa92f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this to tell the op that it should always have op trees for normal behaviour (for internal use) <br /></td></tr>
<tr class="separator:a1e1043e07bfb9c83ee8d02d1580fa92f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebff835aec4677ee342690d0a55ee6ff"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classDD_1_1Image_1_1Op.html#aaec7731a5d44a5b3db2fdd6aa6549f00">HandlesMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#aebff835aec4677ee342690d0a55ee6ff">doAnyHandles</a> (<a class="el" href="classDD_1_1Image_1_1ViewerContext.html">ViewerContext</a> *ctx)</td></tr>
<tr class="separator:aebff835aec4677ee342690d0a55ee6ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a578ecede84d9c432c3cd8b4496d4b16e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classDD_1_1Image_1_1Op.html#a896b162a5d1b1d07f9397b667362ce49">PrevalidateResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#a578ecede84d9c432c3cd8b4496d4b16e">doPreValidate</a> (<a class="el" href="classDD_1_1Image_1_1ViewerContext.html">ViewerContext</a> *ctx=nullptr, <a class="el" href="classDD_1_1Image_1_1PreValidateContext.html">PreValidateContext</a> *=nullptr)</td></tr>
<tr class="separator:a578ecede84d9c432c3cd8b4496d4b16e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ad630933fdc66c9429480c7dae10cb09e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad630933fdc66c9429480c7dae10cb09e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Op.html#ad630933fdc66c9429480c7dae10cb09e">_haveHash</a></td></tr>
<tr class="memdesc:ad630933fdc66c9429480c7dae10cb09e"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether the _hash actually has been set by a call to invalidate(Hash) ever. <br /></td></tr>
<tr class="separator:ad630933fdc66c9429480c7dae10cb09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:accacedc6f06871ee6fdc08c2fcce841c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="accacedc6f06871ee6fdc08c2fcce841c"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>EngineContext</b></td></tr>
<tr class="separator:accacedc6f06871ee6fdc08c2fcce841c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Base class of all the things that can be created by Nuke nodes. </p>
<p>Nuke will create these things, hook their inputs to other ones, manage animation and store animated values into these by calling the <a class="el" href="classDD_1_1Image_1_1Op.html#a74011be78d484b8241939c392ab9b653">knobs()</a> function, and delete these when the node is destroyed.</p>
<p>Nuke will also invisibly manage multiple copies hidden inside a single node, where each copy is at a different time. This allows a later operator to ask for several time samples and merge them together in order to get motion blur. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a52e30323046f59045417065b91e55fea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;<a class="el" href="classDD_1_1Image_1_1Hash.html">Hash</a>, std::vector&lt;unsigned int&gt; &gt; <a class="el" href="classDD_1_1Image_1_1Op.html#a52e30323046f59045417065b91e55fea">DD::Image::Op::ItemSelectionList</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The following are utility structures for use in the handle callbacks ItemSelectionList is returned to the callback for eMouseDrag events. For each <a class="el" href="classDD_1_1Image_1_1GeoInfo.html" title="Contains a list of points and geometric primitives. ">GeoInfo</a> object which is part of the current selection, this maps the GeoSelection::geoID of the <a class="el" href="classDD_1_1Image_1_1GeoInfo.html" title="Contains a list of points and geometric primitives. ">GeoInfo</a> to a vector of indices of selected vertices for that object. </p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="aaec7731a5d44a5b3db2fdd6aa6549f00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classDD_1_1Image_1_1Op.html#aaec7731a5d44a5b3db2fdd6aa6549f00">DD::Image::Op::HandlesMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration for the use of <a class="el" href="classDD_1_1Image_1_1Op.html#aebff835aec4677ee342690d0a55ee6ff">doAnyHandles()</a>. the values are defined non-consectively so that that eHandles | eHandlesCooked == eHandlesCooked </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="aaec7731a5d44a5b3db2fdd6aa6549f00ae9d9022e0abaa22879a38049d6d6aaf3"></a>eHandlesUncooked&#160;</td><td class="fielddoc">
<p>no handles are needed </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aaec7731a5d44a5b3db2fdd6aa6549f00a4b0ee513512bceedee8e2515f2df94bb"></a>eHandlesCooked&#160;</td><td class="fielddoc">
<p>handles are needed, but generate_tree does not necessarily need calling </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aaec7731a5d44a5b3db2fdd6aa6549f00aa600e9311456487905305a75f39da2b7"></a>eHandlesMax&#160;</td><td class="fielddoc">
<p>handles are needed, and generate_tree needs to be called, to cook out the </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a5aea4d307e94fe59bfa2f66b56559030"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classDD_1_1Image_1_1Op.html#a5aea4d307e94fe59bfa2f66b56559030">DD::Image::Op::ViewableModes</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a5aea4d307e94fe59bfa2f66b56559030a4880af4193d306883e9051c3bf2dc043"></a>eViewableMode2D&#160;</td><td class="fielddoc">
<p>This op can be viewed in 2D. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a5aea4d307e94fe59bfa2f66b56559030a26b127ee376127e56cf3e8c724746264"></a>eViewableMode3D&#160;</td><td class="fielddoc">
<p>This op can be viewed in 3D. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a5aea4d307e94fe59bfa2f66b56559030a07643cfd78e09723b2a9640e51416a73"></a>eViewableMode3D_2DReference&#160;</td><td class="fielddoc">
<p>This op should be viewed in 3D with a 2D wipe overlay. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a7143e1bbe81a3903c73fbae0161bcfe6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classDD_1_1Image_1_1Op.html#a7143e1bbe81a3903c73fbae0161bcfe6">DD::Image::Op::GenerateType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a7143e1bbe81a3903c73fbae0161bcfe6af5c264e7de144944fffb68f98029f0e0"></a>OUTPUT_OP&#160;</td><td class="fielddoc">
<p>Return op with no knobs stored or inputs built. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7143e1bbe81a3903c73fbae0161bcfe6a829454cb678ec06c8c3317568546fdf4"></a>ANY_CONTEXT&#160;</td><td class="fielddoc">
<p>Return tree but maybe at a different <a class="el" href="classDD_1_1Image_1_1OutputContext.html">OutputContext</a>. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7143e1bbe81a3903c73fbae0161bcfe6a10d859f897448e28792026f0986b35c9"></a>INPUT_OP&#160;</td><td class="fielddoc">
<p>Same as ANY_CONTEXT but skip disabled ops. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7143e1bbe81a3903c73fbae0161bcfe6a545a54179f0f56984b4b903867d564bb"></a>INPUT_OP_PEEK&#160;</td><td class="fielddoc">
<p>Same as INPUT_OP, but avoid setting uiContext. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7143e1bbe81a3903c73fbae0161bcfe6ad4d97afa4899876ffde41bd9299f731c"></a>EXECUTABLE&#160;</td><td class="fielddoc">
<p>Returns op tree for right context. Skips disabled ops on inputs (but not main op) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7143e1bbe81a3903c73fbae0161bcfe6aa868cc46995008bb4f04e2f27103b183"></a>EXECUTABLE_SKIP&#160;</td><td class="fielddoc">
<p>Returns op tree for right context. Skips disabled ops. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7143e1bbe81a3903c73fbae0161bcfe6a75cd54701210e07bd9a3239d5cd02bed"></a>EXECUTABLE_INPUT&#160;</td><td class="fielddoc">
<p>Returns op tree for right context, with skipping, and replaces PostageStamp/TextureMap ops. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7143e1bbe81a3903c73fbae0161bcfe6a8f47e2a92552bd42641f9f43c1be88f9"></a>UICONTEXT_ONLY&#160;</td><td class="fielddoc">
<p>Don't try to make a tree, but try to set uiContext on the nodes as if we had. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ab7e6c22841d12d4b8f4e908b066bfe6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classDD_1_1Image_1_1Op.html#ab7e6c22841d12d4b8f4e908b066bfe6a">DD::Image::Op::NodeContext</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ab7e6c22841d12d4b8f4e908b066bfe6aa08ac177353adfedb8c28210fae3022d2"></a>eTimeline&#160;</td><td class="fielddoc">
<p>part of the node graph ( Nuke ) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab7e6c22841d12d4b8f4e908b066bfe6aad5156682159c44e082c8fcfd1f4be887"></a>eOpGraph&#160;</td><td class="fielddoc">
<p>part of a timeline effect ( Hiero ) </p>
<p>part of an op graph (NukeEngine) </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ad05eb8420166eff8fabdb30b8fe9c13c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classDD_1_1Image_1_1Op.html#ad05eb8420166eff8fabdb30b8fe9c13c">DD::Image::Op::StatusFlags</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flags to alter the behaviour of status_callback </p>

</div>
</div>
<a class="anchor" id="afbc2750a2e33057090759ec5844cd4bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classDD_1_1Image_1_1Op.html#afbc2750a2e33057090759ec5844cd4bd">DD::Image::Op::PopUpScheme</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pop-up schemes determine when pop-up messages are displayed for op errors. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="afbc2750a2e33057090759ec5844cd4bdabc6e7073930e89bdc83adbb702927c9a"></a>ePU_Never&#160;</td><td class="fielddoc">
<p>Don't ever display pop-ups for this op. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="afbc2750a2e33057090759ec5844cd4bda1e89aea03a9191ebf883d71611069c2f"></a>ePU_Done&#160;</td><td class="fielddoc">
<p>Previously only one pop-up was to display (ePU_Once), and it's now been shown. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="afbc2750a2e33057090759ec5844cd4bdab96b2ec349ff8d2809ffa3c9d8c12412"></a>ePU_Once&#160;</td><td class="fielddoc">
<p>Display only the next pop-up for this op. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="afbc2750a2e33057090759ec5844cd4bda6ac6d6e60881a4656348542da2bc3e74"></a>ePU_Default&#160;</td><td class="fielddoc">
<p>Display pop-ups according to the Nuke default: while loading scripts or changing knobs. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="afbc2750a2e33057090759ec5844cd4bdaae6bbcc472a54c6a676cf9835d7ae0ad"></a>ePU_Always&#160;</td><td class="fielddoc">
<p>Display every pop-up for this op. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ad18224f6cf7702991dd646addee0fbe5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Op::_invalidate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Operator-specific part of <a class="el" href="classDD_1_1Image_1_1Op.html#ad19589f141ad102c40fab9c26a87c5c8">invalidate()</a>. It will be called only if <a class="el" href="classDD_1_1Image_1_1Op.html#a353707a4e92ff1f1b5073550ef379a05" title="Returns true if it has been validated - including if there was an error. ">valid()</a> was on. Recommended that this not be used for anything, it is provided for back-compatibility only. Instead you should implement <a class="el" href="classDD_1_1Image_1_1Op.html#a009bdb3fc6cf7b4f33134c71585f2f4a">close()</a> and have that delete cached data if <a class="el" href="classDD_1_1Image_1_1Op.html#a353707a4e92ff1f1b5073550ef379a05" title="Returns true if it has been validated - including if there was an error. ">valid()</a> is false. The default version does nothing. </p>

<p>Reimplemented in <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#a0974cdcac7134c71025d929c776e03de">DD::Image::NukeWrapper</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Op.html#a7cd4f2bebb93a913641767f6435374ba">invalidateSameHash()</a>.</p>

</div>
</div>
<a class="anchor" id="ae1dc586d97dd3e752bd3573bb7665b84"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Op::_validate </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>for_real</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The subclass-dependent portion of <a class="el" href="classDD_1_1Image_1_1Op.html#a54fe7079e0236ae45b247dd9f5e300b4">validate()</a>. This is called by <a class="el" href="classDD_1_1Image_1_1Op.html#a54fe7079e0236ae45b247dd9f5e300b4">validate()</a> after checking to see if it is needed.</p>
<p>The default version calls validate(for_real) on all the inputs and does nothing else. </p>

<p>Reimplemented in <a class="el" href="classDD_1_1Image_1_1Iop.html#a5285c26469bf1fccfd61c554d5bf71fb">DD::Image::Iop</a>, <a class="el" href="classDD_1_1Image_1_1Read.html#a1f229ef410d606573a1f23544e6d7a8b">DD::Image::Read</a>, <a class="el" href="classDD_1_1Image_1_1GeoOp.html#ad800f5b6e901266dd70d669c0b26b85f">DD::Image::GeoOp</a>, <a class="el" href="classDD_1_1Image_1_1Render.html#a44a52a33fa89211f7b01b763d90e22c7">DD::Image::Render</a>, <a class="el" href="classDD_1_1Image_1_1Write.html#a24b3332f92388c30a53211b413c4a885">DD::Image::Write</a>, <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#a97d2f933e4ae12f47d4b32df6d33bbed">DD::Image::NukeWrapper</a>, <a class="el" href="classDD_1_1Image_1_1ReadGeo.html#aef6bfba04a696b14fcbae079755b6924">DD::Image::ReadGeo</a>, <a class="el" href="classDD_1_1Image_1_1Transform.html#ad9b86ff52be5808cff50304f4344c176">DD::Image::Transform</a>, <a class="el" href="classDD_1_1Image_1_1IllumShader.html#a35420055167b8c9fb02476c4fd2bd80e">DD::Image::IllumShader</a>, <a class="el" href="classDD_1_1Image_1_1TransformGeo.html#ac7d45ec8dbbf9ab270d26cc2e3b8b02f">DD::Image::TransformGeo</a>, <a class="el" href="classDD_1_1Image_1_1AxisOp.html#a3f2acda6bca5938a31cfb21faeff96a2">DD::Image::AxisOp</a>, <a class="el" href="classDD_1_1Image_1_1ComplexLightOp.html#ae8828555bdb50f32a744e98c7a607b17">DD::Image::ComplexLightOp</a>, <a class="el" href="classDD_1_1Image_1_1DrawIop.html#aa76f28a9be91134f3571439f6b7dd865">DD::Image::DrawIop</a>, <a class="el" href="classDD_1_1Image_1_1RenderScene.html#ab6f3b5274b541e907ba12b5ffc0844ae">DD::Image::RenderScene</a>, <a class="el" href="classDD_1_1Image_1_1DeepFilterOp.html#a842a9a161af95b319e7af371466a4b43">DD::Image::DeepFilterOp</a>, <a class="el" href="classDD_1_1Image_1_1NoIop.html#aa4ef25607b221ead4e36a0550a1ac80a">DD::Image::NoIop</a>, and <a class="el" href="classDD_1_1Image_1_1UpRez.html#abbe9a88ababa5bf013010adeaeb4a3d2">DD::Image::UpRez</a>.</p>

<p>References <a class="el" href="classDD_1_1Image_1_1Op.html#a3f8fb27d42f6da712722fa73eda6b5b0">input()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#a1f2eaf5b7de5354cc5838e608cf25543">inputs()</a>, and <a class="el" href="classDD_1_1Image_1_1Op.html#a54fe7079e0236ae45b247dd9f5e300b4">validate()</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1TransformGeo.html#ac7d45ec8dbbf9ab270d26cc2e3b8b02f">DD::Image::TransformGeo::_validate()</a>, <a class="el" href="classDD_1_1Image_1_1GeoOp.html#ad800f5b6e901266dd70d669c0b26b85f">DD::Image::GeoOp::_validate()</a>, and <a class="el" href="classDD_1_1Image_1_1Op.html#ae745e59a2aacee53458f598174fc4b9c">force_validate()</a>.</p>

</div>
</div>
<a class="anchor" id="a019d714de0d947176450c68df0f6f9e6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Op::_open </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The Op-dependent portion of <a class="el" href="classDD_1_1Image_1_1Op.html#a2bb868632c6116e335c689d78b18ba7a">open()</a>. This is called if it has not been called since the last <a class="el" href="classDD_1_1Image_1_1Op.html#ad19589f141ad102c40fab9c26a87c5c8">invalidate()</a>. For iops this is called just before the first call to engine(). It's purpose is to delay expensive setup until the very last moment. Usually it will open data files or calculate lookup tables. It can call <a class="el" href="classDD_1_1Image_1_1Op.html#afc3f4acb738937d3319707849fe1b26f">error()</a> to abort all the processing, if for instance your data files are missing.</p>
<p>All <a class="el" href="classDD_1_1Image_1_1Op.html#a019d714de0d947176450c68df0f6f9e6">_open()</a> calls are done inside a single locked mutex, so there are no multithreading issues even if several instances of a plugin, or several different plugins, try to update a shared data structure.</p>
<p>The default does nothing. </p>

<p>Reimplemented in <a class="el" href="classDD_1_1Image_1_1Iop.html#a3e059a1899bbe32ad584f1c719aee2c0">DD::Image::Iop</a>, <a class="el" href="classDD_1_1Image_1_1Read.html#a89ddd16acfdea09afe36bf1cc951137c">DD::Image::Read</a>, <a class="el" href="classDD_1_1Image_1_1PlanarIop.html#a6b45aacd8a12ca6d055ce87793925752">DD::Image::PlanarIop</a>, and <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#a4a9ebc9787a0b7c593c550a379fb5eee">DD::Image::NukeWrapper</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Op.html#a2bb868632c6116e335c689d78b18ba7a">open()</a>.</p>

</div>
</div>
<a class="anchor" id="a99957cf4eabecb46ddfb5497766ccca6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Op::_close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The subclass-dependent portion of <a class="el" href="classDD_1_1Image_1_1Op.html#a009bdb3fc6cf7b4f33134c71585f2f4a">close()</a>. This will be called by <a class="el" href="classDD_1_1Image_1_1Op.html#a009bdb3fc6cf7b4f33134c71585f2f4a">close()</a>. It will be called irregardless of valid state or whether you flagged an error during <a class="el" href="classDD_1_1Image_1_1Op.html#a019d714de0d947176450c68df0f6f9e6">_open()</a> or <a class="el" href="classDD_1_1Image_1_1Op.html#ae1dc586d97dd3e752bd3573bb7665b84">_validate()</a>.</p>
<p>For back-compatibility, Nuke calls this after 5.0 seconds of idle time. Future versions may not call this at all unless <a class="el" href="classDD_1_1Image_1_1Op.html#a2f6445522b9e247d90a14a093491e17e">callCloseAfter()</a> is done, so you should add callCloseAfter(5.0) to your plugins to retain compatibility.</p>
<p>Typically <a class="el" href="classDD_1_1Image_1_1Op.html#a99957cf4eabecb46ddfb5497766ccca6">_close()</a> will close files, destroy cached data, and call <a class="el" href="classDD_1_1Image_1_1Op.html#a009bdb3fc6cf7b4f33134c71585f2f4a">close()</a> on internal operators. It should not destroy any data that it might have returned pointers to (i.e. metadata, cached images, etc) unless <a class="el" href="classDD_1_1Image_1_1Op.html#a353707a4e92ff1f1b5073550ef379a05" title="Returns true if it has been validated - including if there was an error. ">valid()</a> is false. To make sure internal caches are destroyed, it should call both <a class="el" href="classDD_1_1Image_1_1Op.html#ad19589f141ad102c40fab9c26a87c5c8">invalidate()</a> and <a class="el" href="classDD_1_1Image_1_1Op.html#a009bdb3fc6cf7b4f33134c71585f2f4a">close()</a> on any internal <a class="el" href="classDD_1_1Image_1_1Op.html" title="Base class of all the things that can be created by Nuke nodes. ">Op</a> instances.</p>
<p>Despite the name, this is not the opposite of <a class="el" href="classDD_1_1Image_1_1Op.html#a2bb868632c6116e335c689d78b18ba7a">open()</a>. <a class="el" href="classDD_1_1Image_1_1Op.html#a2bb868632c6116e335c689d78b18ba7a">open()</a> is undone by <a class="el" href="classDD_1_1Image_1_1Op.html#ad19589f141ad102c40fab9c26a87c5c8">invalidate()</a>. This may be called multiple times after <a class="el" href="classDD_1_1Image_1_1Op.html#a2bb868632c6116e335c689d78b18ba7a">open()</a> and may be called before <a class="el" href="classDD_1_1Image_1_1Op.html#a2bb868632c6116e335c689d78b18ba7a">open()</a> is ever called.</p>
<p>The default implementation does nothing. </p>

<p>Reimplemented in <a class="el" href="classDD_1_1Image_1_1Iop.html#a5de9bcbbaebb959b498bf9baf66075d1">DD::Image::Iop</a>, <a class="el" href="classDD_1_1Image_1_1Read.html#a52f1f21e202ca9d2fdb06a5f8bd0100c">DD::Image::Read</a>, <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#a5de626196f56b88693fcb56a440c11ea">DD::Image::NukeWrapper</a>, <a class="el" href="classDD_1_1Image_1_1ReadGeo.html#adaeed1135c8603cb80857c347d0822fd">DD::Image::ReadGeo</a>, and <a class="el" href="classDD_1_1Image_1_1WriteGeo.html#a55ca0fd721ecd303e7844b3c0952720a">DD::Image::WriteGeo</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Op.html#a009bdb3fc6cf7b4f33134c71585f2f4a">close()</a>.</p>

</div>
</div>
<a class="anchor" id="ab9ffa08d0a7e8b1d071a6f7bdcb5e106"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDD_1_1Image_1_1Op.html">Op</a> * Op::create </td>
          <td>(</td>
          <td class="paramtype">Node *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a new instance of some <a class="el" href="classDD_1_1Image_1_1Op.html" title="Base class of all the things that can be created by Nuke nodes. ">Op</a> by name. This is assumed to be an internal part of this <a class="el" href="classDD_1_1Image_1_1Op.html" title="Base class of all the things that can be created by Nuke nodes. ">Op</a> and the new <a class="el" href="classDD_1_1Image_1_1Op.html" title="Base class of all the things that can be created by Nuke nodes. ">Op</a>'s <a class="el" href="classDD_1_1Image_1_1Op.html#a0d4340b2a813327a249698c0dee107bb">parent()</a> is set to this. This works by calling <a class="el" href="classDD_1_1Image_1_1Op.html#acebc17c770453f35c1cf012abc3a34d6">find_description()</a> and if that succeeds it calles the constructor() function in the description.</p>
<p>An <a class="el" href="classDD_1_1Image_1_1Op.html" title="Base class of all the things that can be created by Nuke nodes. ">Op</a> can use this to create any other operator, even one in a plugin, as part of itself. You should do this inside <a class="el" href="classDD_1_1Image_1_1Op.html#ae1dc586d97dd3e752bd3573bb7665b84">_validate()</a> and not inside the constructor so that any errors can be reported correctly. If there is a problem finding a plugin or loading it this will call <a class="el" href="classDD_1_1Image_1_1Op.html#afc3f4acb738937d3319707849fe1b26f">error()</a> with an appropriate error message and return zero. You should quit in this case, perhaps setting some flags so that further calls to your object will not crash.</p>
<p>You will need to cast the result if you want to use it. For instance if it is an <a class="el" href="classDD_1_1Image_1_1Iop.html" title="Iop is the base class for all the image operators. ">Iop</a> you should use dynamic_cast&lt;Iop*&gt; on it. If this does not work (returning a zero) you should call <a class="el" href="classDD_1_1Image_1_1Op.html#afc3f4acb738937d3319707849fe1b26f">error()</a> with an appropriate message and give up.</p>
<p>The name passed in is not the necessarily the name that that the node has in the UI: instead it is the name returned by the <a class="el" href="classDD_1_1Image_1_1Op.html#a4fc5fd8a59a843cfd322b132b5ae426d">Class()</a> function in C++ and Python for the node. (For example, the regular Merge node's internal name is "Merge2", and "Merge" refers to the original Merge node, left in for compatibility.</p>
<p>If you have a header file or other description of the object you can store settings into it using methods from the header file. If you do not have the header file you can still use the <a class="el" href="classDD_1_1Image_1_1Op.html#a1e36f90d0838e7ac1b0e0dac9fa15ca3">field()</a> method to put values into it. </p>

<p>References <a class="el" href="classDD_1_1Image_1_1Op_1_1Description.html#a54a689f7020d3af89e2486b2c564c574">DD::Image::Op::Description::constructor()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#afc3f4acb738937d3319707849fe1b26f">error()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#acebc17c770453f35c1cf012abc3a34d6">find_description()</a>, and <a class="el" href="classDD_1_1Image_1_1Op.html#a0d4340b2a813327a249698c0dee107bb">parent()</a>.</p>

</div>
</div>
<a class="anchor" id="aba30401a92a6ad3c629b5246e85cdbad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDD_1_1Image_1_1Op.html#aaec7731a5d44a5b3db2fdd6aa6549f00">Op::HandlesMode</a> Op::anyInputHandles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDD_1_1Image_1_1ViewerContext.html">ViewerContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return if any of the inputs (recursively) wish to draw handles </p>
<p>Convenience function for <a class="el" href="classDD_1_1Image_1_1Op.html#aebff835aec4677ee342690d0a55ee6ff">doAnyHandles()</a> to call. </p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Op.html#aebff835aec4677ee342690d0a55ee6ff">doAnyHandles()</a>.</p>

</div>
</div>
<a class="anchor" id="a0be228bb3a6b9d696e924b6990b68c15"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDD_1_1Image_1_1Op.html#aaec7731a5d44a5b3db2fdd6aa6549f00">Op::HandlesMode</a> Op::anyKnobHandles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDD_1_1Image_1_1ViewerContext.html">ViewerContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return if any of the knobs on this node wish to draw handles </p>
<p>Convenience function for <a class="el" href="classDD_1_1Image_1_1Op.html#aebff835aec4677ee342690d0a55ee6ff">doAnyHandles()</a> to call. This will check if the user interface window is open. If so it will go through all the knobs, and if <a class="el" href="classDD_1_1Image_1_1Knob.html#aa8a1d21ea1b3316944eeb14112b8b990">Knob::build_handle()</a> returns true it returns true </p>

<p>References <a class="el" href="classDD_1_1Image_1_1Knob.html#aa8a1d21ea1b3316944eeb14112b8b990">DD::Image::Knob::build_handle()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#aaec7731a5d44a5b3db2fdd6aa6549f00ae9d9022e0abaa22879a38049d6d6aaf3">eHandlesUncooked</a>, and <a class="el" href="classDD_1_1Image_1_1Op.html#a3bbfe0c075c8844df6b49d5ea400c52a">knob()</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Op.html#aebff835aec4677ee342690d0a55ee6ff">doAnyHandles()</a>.</p>

</div>
</div>
<a class="anchor" id="ad953c3235503acb40a508a38458970ae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Op::build_input_handles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDD_1_1Image_1_1ViewerContext.html">ViewerContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convenience function for <a class="el" href="classDD_1_1Image_1_1Op.html#a7a50f7c26535dd6c84390c67c08c5581">build_handles()</a> to call. This will call <a class="el" href="classDD_1_1Image_1_1Op.html#a31c6dce4be81844688cda2cd19f4de5f">add_input_handle()</a> on each input to the operator. </p>

<p>References <a class="el" href="classDD_1_1Image_1_1Op.html#a31c6dce4be81844688cda2cd19f4de5f">add_input_handle()</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Transform.html#a89239e1d50e3f24f7d7a3fba00a3dbbe">DD::Image::Transform::build_handles()</a>, <a class="el" href="classDD_1_1Image_1_1AxisOp.html#a368a8c3f618a2cb06ec4c8d0fccaa73a">DD::Image::AxisOp::build_handles()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#a7a50f7c26535dd6c84390c67c08c5581">build_handles()</a>, and <a class="el" href="classDD_1_1Image_1_1GeoOp.html#ac4d98ee7c3b175b08fab14ee83b50549">DD::Image::GeoOp::build_matrix_handles()</a>.</p>

</div>
</div>
<a class="anchor" id="abee83f5231cc1015a0b30e7b4527f47a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Op::build_knob_handles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDD_1_1Image_1_1ViewerContext.html">ViewerContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convenience function for <a class="el" href="classDD_1_1Image_1_1Op.html#a7a50f7c26535dd6c84390c67c08c5581">build_handles()</a> to call. This will check if the user interface window is open. If so it will go through all the knobs, and if <a class="el" href="classDD_1_1Image_1_1Knob.html#aa8a1d21ea1b3316944eeb14112b8b990">Knob::build_handle()</a> returns true it calls <a class="el" href="classDD_1_1Image_1_1Knob.html#a8630ea6b7ea56c39e797952bafbedb34">Knob::add_draw_handle()</a>. </p>

<p>References <a class="el" href="classDD_1_1Image_1_1Knob.html#a8630ea6b7ea56c39e797952bafbedb34">DD::Image::Knob::add_draw_handle()</a>, <a class="el" href="classDD_1_1Image_1_1Knob.html#aa8a1d21ea1b3316944eeb14112b8b990">DD::Image::Knob::build_handle()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#a3bbfe0c075c8844df6b49d5ea400c52a">knob()</a>, and <a class="el" href="classDD_1_1Image_1_1ViewerContext.html#aa7c594641aed310fa01f2351efce8766">DD::Image::ViewerContext::pImpl()</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1TransformGeo.html#afa6576a607819ccbf51882a884a4e1f6">DD::Image::TransformGeo::build_handles()</a>, <a class="el" href="classDD_1_1Image_1_1Transform.html#a89239e1d50e3f24f7d7a3fba00a3dbbe">DD::Image::Transform::build_handles()</a>, <a class="el" href="classDD_1_1Image_1_1AxisOp.html#a368a8c3f618a2cb06ec4c8d0fccaa73a">DD::Image::AxisOp::build_handles()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#a7a50f7c26535dd6c84390c67c08c5581">build_handles()</a>, and <a class="el" href="classDD_1_1Image_1_1GeoOp.html#ac4d98ee7c3b175b08fab14ee83b50549">DD::Image::GeoOp::build_matrix_handles()</a>.</p>

</div>
</div>
<a class="anchor" id="aebff835aec4677ee342690d0a55ee6ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDD_1_1Image_1_1Op.html#aaec7731a5d44a5b3db2fdd6aa6549f00">Op::HandlesMode</a> Op::doAnyHandles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDD_1_1Image_1_1ViewerContext.html">ViewerContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function to be implemented by subclasses who implement build_handles. Should return eHandlesCooked or eHandlesUncooked if a call to build_handles might add handles to be drawn, or eNoHandles, if no handles need drawing. The default implementation of this returns the maximum of the values that <a class="el" href="classDD_1_1Image_1_1Op.html#aba30401a92a6ad3c629b5246e85cdbad" title="return if any of the inputs (recursively) wish to draw handles ">anyInputHandles()</a> or <a class="el" href="classDD_1_1Image_1_1Op.html#a0be228bb3a6b9d696e924b6990b68c15" title="return if any of the knobs on this node wish to draw handles ">anyKnobHandles()</a> return</p>
<p>Subclasses that call build_input_handles from <a class="el" href="classDD_1_1Image_1_1Op.html#a7a50f7c26535dd6c84390c67c08c5581">build_handles()</a> should make anyInputHandles contribute towards the result with operator| - similarly, subclasses which call <a class="el" href="classDD_1_1Image_1_1Op.html#abee83f5231cc1015a0b30e7b4527f47a">build_knob_handles()</a> should return a value from this if <a class="el" href="classDD_1_1Image_1_1Op.html#a0be228bb3a6b9d696e924b6990b68c15" title="return if any of the knobs on this node wish to draw handles ">anyKnobHandles()</a> returns a value.</p>
<p>Note that at the time that doAnyHandles has been called, the <a class="el" href="classDD_1_1Image_1_1Op.html" title="Base class of all the things that can be created by Nuke nodes. ">Op</a> tree and inputs has not been generated, and knob values on this <a class="el" href="classDD_1_1Image_1_1Op.html" title="Base class of all the things that can be created by Nuke nodes. ">Op</a> have not been stored. If the result of this needs to depend upon knob values, fetch the values out with knob("knobName")-&gt;get_value().</p>
<p>If this function returns cooked then it will (possibly expensively) generate an op tree, including storing the knob values, and then call build_handles upon that. If it returns uncooked then it can skip the op generation step, and will just call build_handles on an op, assuming that the op can use any arbitrary outputContext and does not need to have had its knobs cooked. (The <a class="el" href="classDD_1_1Image_1_1Op.html#aec4cf62da84ac80bf8c53ee99aeebb66">uiContext()</a> should be correct)</p>
<p>If in previous versions you returned 'true' from this function, you should return eHandlesCooked. </p>

<p>Reimplemented in <a class="el" href="classDD_1_1Image_1_1RenderScene.html#ab9f7014314503ff2a95a6291c72afb19">DD::Image::RenderScene</a>.</p>

<p>References <a class="el" href="classDD_1_1Image_1_1Op.html#aba30401a92a6ad3c629b5246e85cdbad">anyInputHandles()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#a0be228bb3a6b9d696e924b6990b68c15">anyKnobHandles()</a>, and <a class="el" href="classDD_1_1Image_1_1Op.html#aaec7731a5d44a5b3db2fdd6aa6549f00aa600e9311456487905305a75f39da2b7">eHandlesMax</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1RenderScene.html#ab9f7014314503ff2a95a6291c72afb19">DD::Image::RenderScene::doAnyHandles()</a>.</p>

</div>
</div>
<a class="anchor" id="a44f1e97f589ca7c7d16b5eb15ea94824"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDD_1_1Image_1_1Op.html#a896b162a5d1b1d07f9397b667362ce49">Op::PrevalidateResult</a> Op::preValidate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDD_1_1Image_1_1ViewerContext.html">ViewerContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDD_1_1Image_1_1PreValidateContext.html">PreValidateContext</a> *&#160;</td>
          <td class="paramname"><em>pvc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>preValidate step to perform any potentially expensive steps before <a class="el" href="classDD_1_1Image_1_1Op.html#a54fe7079e0236ae45b247dd9f5e300b4">validate()</a>. This is cancellable, and will return eCancalled/eAbandoned if the user cancelled or abandoned it. (In the event of a cancellation a subsequent validate will still work, but will do the additional work). </p>

<p>References <a class="el" href="classDD_1_1Image_1_1ViewerContext.html#a5f77148ff88c27b0c8af3519fade1675">DD::Image::ViewerContext::connected()</a>, and <a class="el" href="classDD_1_1Image_1_1Op.html#a578ecede84d9c432c3cd8b4496d4b16e">doPreValidate()</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Op.html#a578ecede84d9c432c3cd8b4496d4b16e">doPreValidate()</a>.</p>

</div>
</div>
<a class="anchor" id="ab0f0dc1f231976d506e5444fb6ccc577"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDD_1_1Image_1_1Op.html">Op</a> * Op::rootOp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>return the root for this <a class="el" href="classDD_1_1Image_1_1Op.html" title="Base class of all the things that can be created by Nuke nodes. ">Op</a>. IMPORTANT: this may return NULL depending of the state of this <a class="el" href="classDD_1_1Image_1_1Op.html" title="Base class of all the things that can be created by Nuke nodes. ">Op</a> i.e. inside a <a class="el" href="classDD_1_1Image_1_1Op.html#a43260b9f61dc1ff269a93acab40b8b6c">set_field()</a> call </p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1InternalOCIOOp.html#a20741f77f0b82e03a65f80c1a27f14a9">DD::Image::InternalOCIOOp::updateColorManagementSetting()</a>, and <a class="el" href="classDD_1_1Image_1_1InternalOCIOOp.html#a8d2038cb78817d8b490605ecf6871735">DD::Image::InternalOCIOOp::updateOCIOKnobValues()</a>.</p>

</div>
</div>
<a class="anchor" id="a0c3627c3eb0de1e6e03be2bf51f14bcc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Op::preValidateAborted </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>treeStartingVersion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDD_1_1Image_1_1Op.html#a896b162a5d1b1d07f9397b667362ce49">PrevalidateResult</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>returns true if user has aborted or cancelled. leaves result in parameter, otherwise returns false. </p>

<p>References <a class="el" href="classDD_1_1Image_1_1Op.html#a179e264be537d6ae0e3d0d0e15009fa4">cancelled()</a>, and <a class="el" href="classDD_1_1Image_1_1Op.html#afce84780f6ddda80a21bd8f395ec5213">treeVersion()</a>.</p>

</div>
</div>
<a class="anchor" id="aac28ac7af905cc60ac6ed9ecce16d0d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDD_1_1Image_1_1MetaData_1_1Bundle.html">MetaData::Bundle</a> &amp; Op::_fetchMetaData </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>keyname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Implement this to supply metadata. by default it will pass through to fetchMetaData on input(0). The reference should be to an internal object that should remain valid until the <a class="el" href="classDD_1_1Image_1_1Op.html" title="Base class of all the things that can be created by Nuke nodes. ">Op</a> is invalidated: returning a reference to the return value of another <a class="el" href="classDD_1_1Image_1_1Op.html" title="Base class of all the things that can be created by Nuke nodes. ">Op</a>'s fetchMetaData is acceptable.</p>
<p>the key parameter will in future be used to allow only one piece of metadata to be calculated: presently nuke ignores it, and it is safe for plugins to ignore. </p>

<p>Reimplemented in <a class="el" href="classDD_1_1Image_1_1Read.html#a52f58ea22550e5819dc7e3613e66139a">DD::Image::Read</a>.</p>

<p>References <a class="el" href="classDD_1_1Image_1_1Op.html#a15e7072f2282bb9fced37048aaf8ae11">fetchMetaData()</a>, and <a class="el" href="classDD_1_1Image_1_1Op.html#a3f8fb27d42f6da712722fa73eda6b5b0">input()</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Op.html#a15e7072f2282bb9fced37048aaf8ae11">fetchMetaData()</a>.</p>

</div>
</div>
<a class="anchor" id="a15e7072f2282bb9fced37048aaf8ae11"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDD_1_1Image_1_1MetaData_1_1Bundle.html">MetaData::Bundle</a> &amp; Op::fetchMetaData </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>keyname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call this to fetch a metadata bundle containing the particular keyname, or NULL to fetch all available metadata. You may get back all available data even if you had specified a particular item. </p>

<p>References <a class="el" href="classDD_1_1Image_1_1Op.html#aac28ac7af905cc60ac6ed9ecce16d0d4">_fetchMetaData()</a>, and <a class="el" href="classDD_1_1Image_1_1Op.html#a69dfe1facc10819d7dc561ae1b380d66">hash()</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Op.html#aac28ac7af905cc60ac6ed9ecce16d0d4">_fetchMetaData()</a>.</p>

</div>
</div>
<a class="anchor" id="a1e65ba0209479090ca51fc3d0b60e8ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Node * Op::node </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the Nuke user interface node this operator belongs to. If you use DDImage in another program you could use this to store an arbitrary piece of user data. </p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Write.html#a24b3332f92388c30a53211b413c4a885">DD::Image::Write::_validate()</a>, <a class="el" href="classDD_1_1Image_1_1GeoOp.html#a784a8ee80f408ea1df56d3f46b90ea7a">DD::Image::GeoOp::add_draw_geometry()</a>, <a class="el" href="classDD_1_1Image_1_1GeometryList.html#a884f92737a7e1cd1254d1e8bc6061d87">DD::Image::GeometryList::add_object()</a>, <a class="el" href="classDD_1_1Image_1_1Render.html#a90a47fa24195353de915be2cf2a4e9cf">DD::Image::Render::buildGeoInfoHandle()</a>, <a class="el" href="classDD_1_1Image_1_1Render.html#addce74cc03baad7bf43ab970725335e2">DD::Image::Render::draw_primitives()</a>, <a class="el" href="classDD_1_1Image_1_1Write.html#ae76f84680bb2d23603e7bc3b32ef0de5">DD::Image::Write::execute()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#ad131c925b04abdeb048c5a0ae0012f97">input_format()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#aeae75f67ceb4736a1c5a61ce8634641c">nodeContext()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#aa556ff07c78ede58fb5f3ed18f7b625d">Op()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#aa01955aa08bcdfb41a9721c8cb427f3f">script_command()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#a697e2a3194de8f4444d09971db44ed0f">script_expand()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#aec4cf62da84ac80bf8c53ee99aeebb66">uiContext()</a>, <a class="el" href="classDD_1_1Image_1_1GeoOp.html#a1dc735a575e03d2c0ba1e449d5337618">DD::Image::GeoOp::update_geometry_hashes()</a>, and <a class="el" href="classDD_1_1Image_1_1Write.html#a5650e145be0132468ac805d2a6dc27d1">DD::Image::Write::updateDefaultLUT()</a>.</p>

</div>
</div>
<a class="anchor" id="a54449efe332353c5be370b8f43aab967"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DD::Image::Op::node </td>
          <td>(</td>
          <td class="paramtype">Node *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the Nuke user interface node this operator belongs to. Nuke uses this to report errors. Warning: do not attempt to set both <a class="el" href="classDD_1_1Image_1_1Op.html#a0d4340b2a813327a249698c0dee107bb">parent()</a> and <a class="el" href="classDD_1_1Image_1_1Op.html#a1e65ba0209479090ca51fc3d0b60e8ea">node()</a>, they use the same memory location! </p>

</div>
</div>
<a class="anchor" id="a0d4340b2a813327a249698c0dee107bb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDD_1_1Image_1_1Op.html">Op</a> * DD::Image::Op::parent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the operator this is inside of, if the constructor set it. </p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1TransformGeo.html#ac7d45ec8dbbf9ab270d26cc2e3b8b02f">DD::Image::TransformGeo::_validate()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#a5a6acb4a433796a5b0c7940542b4db31">addTime()</a>, <a class="el" href="classDD_1_1Image_1_1TransformGeo.html#afa6576a607819ccbf51882a884a4e1f6">DD::Image::TransformGeo::build_handles()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#ab9ffa08d0a7e8b1d071a6f7bdcb5e106">create()</a>, <a class="el" href="classDD_1_1Image_1_1Scene.html#ad825a571c92d0611e08af922eb19e3f4">DD::Image::Scene::evaluate_lights()</a>, and <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#aeda64ddd68ad1ba134854300bed02e4a">DD::Image::NukeWrapper::NukeWrapper()</a>.</p>

</div>
</div>
<a class="anchor" id="a74011be78d484b8241939c392ab9b653"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Op::knobs </td>
          <td>(</td>
          <td class="paramtype">Knob_Callback&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Define the "knobs" that will be presented in the control panel for the operator.</p>
<p>Normally you call <em>callback</em> once for each <a class="el" href="classDD_1_1Image_1_1Knob.html">Knob</a> you want on the panel. The file <a class="el" href="Knobs_8h.html" title="Knob creation functions. ">Knobs.h</a> describes a number of type-safe wrapper functions that you should use instead of calling <em>callback</em> directly. This file also documents all the existing built-in types.</p>
<p>When knobs are being created <em>callback</em> takes an enumeration value that defines the type of knob being created, and the name, label, and arbitrary extra data to pass to the constructor, and a pointer to data that may (depending on the knob type) be used to get a default value.</p>
<p>When data is being stored <em>callback</em> ignores all the arguments except the pointer, this is then passed to the store() method of the knob that was created last time.</p>
<p>Use of only the enumerated types avoids the need to link with Nuke, thus allowing your image operator to be used with other programs that only use the DDImage libarary.</p>
<p>If desired a custom <a class="el" href="classDD_1_1Image_1_1Knob.html">Knob</a> may be created. In this case your operator will only work as a plugin to Nuke. This function must call the makeKnobs() function on the callback object and if true it should call the constructor for the custom knob. If false it should call <em>callback</em>, you can pass 0 for all the arguments except the pointer, which will be passed to the store() method of your <a class="el" href="classDD_1_1Image_1_1Knob.html">Knob</a>. </p>

<p>Reimplemented in <a class="el" href="classDD_1_1Image_1_1Transform.html#adce2202f6011867ccb2a8b63d4effca5">DD::Image::Transform</a>, <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#a5952ee7ac93232be46555d08acfad1c0">DD::Image::NukeWrapper</a>, <a class="el" href="classDD_1_1Image_1_1DeepAccumPixelOp.html#ac1dd6256dc7c6b95f7c07072c50d43da">DD::Image::DeepAccumPixelOp</a>, <a class="el" href="classDD_1_1Image_1_1IllumShader.html#a7e6592243a24b5f8581dc2489e9c90fe">DD::Image::IllumShader</a>, <a class="el" href="classDD_1_1Image_1_1NoIop.html#a413e338b0e943cee1d0d2e98b79a87d4">DD::Image::NoIop</a>, and <a class="el" href="classDD_1_1Image_1_1SourceGeo.html#a2fe0653d05c0ff0f12e408d286ee3d0a">DD::Image::SourceGeo</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Op.html#a4ed442e5319c28645301c7760072e412">field()</a>, and <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#a5952ee7ac93232be46555d08acfad1c0">DD::Image::NukeWrapper::knobs()</a>.</p>

</div>
</div>
<a class="anchor" id="a187563982c7ede588ba740fbcf9c38ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Op::replace_knobs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDD_1_1Image_1_1Knob.html">Knob</a> *&#160;</td>
          <td class="paramname"><em>afterthis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *, Knob_Callback)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileExt</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the set of knobs this node has, by deleting <em>n</em> knobs after the <em>afterthis</em> knob, then inserting new knobs produced by calling the function <em>f</em>. The return value is the number of knobs created by <em>f</em>, which you probably want to save and pass to the next call.</p>
<p>If <em>n</em> is zero or negative then this only creates knobs. If <em>f</em> is null then this only destroys knobs.</p>
<p>Currently the old knobs are completly destroyed. Future versions may try to match up the new knobs with the old ones and preserve the values and widgets.</p>
<p>Your <a class="el" href="classDD_1_1Image_1_1Op.html#a74011be78d484b8241939c392ab9b653">knobs()</a> function should also call <em>f</em> by using <a class="el" href="classDD_1_1Image_1_1Op.html#a04ac66fdaecffae7f30a5db5c2bfaf97">add_knobs()</a>. You also need to pick a knob that controls the rest of the knobs and set the <a class="el" href="classDD_1_1Image_1_1Knob.html#a465bc9ae9af20944c5be97a15eee6c8a" title="Always calls knob_changed, regardless of whether it has previously returned false. ">Knob::KNOB_CHANGED_ALWAYS</a> flag on it so that you can change the set of knobs on any changes. </p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1FileOp.html#a0f84e1109e627d256c3b7031172d2dec">DD::Image::FileOp::add_extra_knobs()</a>, and <a class="el" href="classDD_1_1Image_1_1FileOp.html#a200c741353d39ac4c0c5e9098a03b0f9">DD::Image::FileOp::replace_knobs()</a>.</p>

</div>
</div>
<a class="anchor" id="a04ac66fdaecffae7f30a5db5c2bfaf97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Op::add_knobs </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *, Knob_Callback)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Knob_Callback&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call f() and return how many knobs it created. This should be called inside a <a class="el" href="classDD_1_1Image_1_1Op.html#a74011be78d484b8241939c392ab9b653">knobs()</a> function to create the original set of knobs that will be changed by <a class="el" href="classDD_1_1Image_1_1Op.html#a187563982c7ede588ba740fbcf9c38ae">replace_knobs()</a>, and to store the values into the current set of knobs. This will return zero if the callback is not creating knobs. </p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1FileOp.html#a8d8bf0239e0b5016093a43d0719bf187">DD::Image::FileOp::extra_knobs()</a>, and <a class="el" href="classDD_1_1Image_1_1FileOp.html#a9624e7ab36fdf7c74b43c168dc71e898">DD::Image::FileOp::replaceable_knobs()</a>.</p>

</div>
</div>
<a class="anchor" id="acb229f28d82696e0cee5bc5f7f11dda8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op::set_unlicensed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disable all knobs on the node that this op belongs to, other than the ones on the Node tab. This can be called at the end of your <a class="el" href="classDD_1_1Image_1_1Op.html#a74011be78d484b8241939c392ab9b653">knobs()</a> method to ensure that <em>all</em> knobs are disabled (for example, if a license check is failed). </p>

</div>
</div>
<a class="anchor" id="a3bbfe0c075c8844df6b49d5ea400c52a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDD_1_1Image_1_1Knob.html">Knob</a> * Op::knob </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find and return a <a class="el" href="classDD_1_1Image_1_1Knob.html">Knob</a> on the control panel for the node that controls this <a class="el" href="classDD_1_1Image_1_1Op.html" title="Base class of all the things that can be created by Nuke nodes. ">Op</a>. Returns null if there is no knob with the given name.</p>
<p>If <a class="el" href="classDD_1_1Image_1_1Op.html#a74011be78d484b8241939c392ab9b653">knobs()</a> has not been called, you may not get knobs you think should exist. This will happen if this <a class="el" href="classDD_1_1Image_1_1Op.html" title="Base class of all the things that can be created by Nuke nodes. ">Op</a> was created directly by another <a class="el" href="classDD_1_1Image_1_1Op.html" title="Base class of all the things that can be created by Nuke nodes. ">Op</a>. If such a controlling op wants to change the stored data, it should use the <a class="el" href="classDD_1_1Image_1_1Op.html#a1e36f90d0838e7ac1b0e0dac9fa15ca3">field()</a> method to get the pointer to where to store it, rather than trying to change the value of a knob.</p>
<p>If DDImage is not being used by Nuke this will return null. However <a class="el" href="classDD_1_1Image_1_1Op.html#a1e36f90d0838e7ac1b0e0dac9fa15ca3">field()</a> will still work. </p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1ReadGeo.html#aef6bfba04a696b14fcbae079755b6924">DD::Image::ReadGeo::_validate()</a>, <a class="el" href="classDD_1_1Image_1_1Write.html#a24b3332f92388c30a53211b413c4a885">DD::Image::Write::_validate()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#a0be228bb3a6b9d696e924b6990b68c15">anyKnobHandles()</a>, <a class="el" href="classDD_1_1Image_1_1Read.html#a7e26eb86dbf6438c8f036adfa8e1f2eb">DD::Image::Read::append()</a>, <a class="el" href="classDD_1_1Image_1_1ParticleOp.html#adee80501072cc12fa02ee350e575e1d0">DD::Image::ParticleOp::appendSimulationCurve()</a>, <a class="el" href="classDD_1_1Image_1_1RenderScene.html#acf63b203c79c4f3570481944ec91c1de">DD::Image::RenderScene::build_handles()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#abee83f5231cc1015a0b30e7b4527f47a">build_knob_handles()</a>, <a class="el" href="classDD_1_1Image_1_1AxisOp.html#a1921572a23134e768f996748493d00d9">DD::Image::AxisOp::enableAxisKnobs()</a>, <a class="el" href="classDD_1_1Image_1_1AxisOp.html#ad53682980643cea93267cf3ec58ed83c">DD::Image::AxisOp::enableKnobs()</a>, <a class="el" href="classDD_1_1Image_1_1Executable.html#aa2ba7efc423799f9d7f4b6cfb2127935">DD::Image::Executable::frameRangeKnobsChanged()</a>, <a class="el" href="classDD_1_1Image_1_1AxisOp.html#a6c96bf373706df14b917b8972c26b1ae">DD::Image::AxisOp::isGuiInteractive()</a>, <a class="el" href="classDD_1_1Image_1_1Write.html#a056aa0257240a0f0f6ede7cfb38cdd7a">DD::Image::Write::isWrite()</a>, <a class="el" href="classDD_1_1Image_1_1DrawIop.html#a791e0672e4e5568059cc09cdefa41537">DD::Image::DrawIop::knob_changed()</a>, <a class="el" href="classDD_1_1Image_1_1GeoOp.html#ae6bdd2fb36e3c25bba2f003f69a0c6d8">DD::Image::GeoOp::knob_changed()</a>, <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#a7ebcbce1b005acb2039180935dba9d5c">DD::Image::NukeWrapper::knob_changed()</a>, <a class="el" href="classDD_1_1Image_1_1LookAt.html#a251917dfa9cfcdc39a0e83bbe2fd9b97">DD::Image::LookAt::knobChanged()</a>, <a class="el" href="classDD_1_1Image_1_1InternalOCIOOp.html#a964605cec2a608423328bd61d53aa6a8">DD::Image::InternalOCIOOp::nodePanelShown()</a>, <a class="el" href="namespaceDD_1_1Image.html#a866e8bc35cae6e1d57285fae38cb2b94">DD::Image::RecursiveUseFilesystem()</a>, <a class="el" href="classDD_1_1Image_1_1Write.html#a1050fa6be610d1ee9e47fb4420e14923">DD::Image::Write::set_file_type()</a>, <a class="el" href="classDD_1_1Image_1_1Executable.html#a858b1a54188706ebe3a94716559433b6">DD::Image::Executable::skipForContext()</a>, <a class="el" href="classDD_1_1Image_1_1InternalOCIOOp.html#a20741f77f0b82e03a65f80c1a27f14a9">DD::Image::InternalOCIOOp::updateColorManagementSetting()</a>, and <a class="el" href="classDD_1_1Image_1_1InternalOCIOOp.html#a8d2038cb78817d8b490605ecf6871735">DD::Image::InternalOCIOOp::updateOCIOKnobValues()</a>.</p>

</div>
</div>
<a class="anchor" id="a070557fb167e36323190ccc0177306e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDD_1_1Image_1_1Knob.html">Knob</a> * Op::knob </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a knob by index number. If the index number is larger than the number of knobs then null is returned. By starting at zero and incrementing until this returns null you will get every <a class="el" href="classDD_1_1Image_1_1Knob.html">Knob</a> known about. </p>

</div>
</div>
<a class="anchor" id="ad5ed2bd29bf82944c20ce87f2b724dbc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Op::pushed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if any knob is <a class="el" href="classDD_1_1Image_1_1Knob.html#ade4f4c9ef3b705f42aff603fd4dad3b6">Knob::pushed()</a>, meaning the user is holding it down with the mouse. Currently only implemented for the handles in the viewer, but the intention is to make it work for widgets in the control panels, too. This is used by <a class="el" href="classDD_1_1Image_1_1Transform.html">Transform</a> to enable the texture map preview. </p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Transform.html#a89239e1d50e3f24f7d7a3fba00a3dbbe">DD::Image::Transform::build_handles()</a>, and <a class="el" href="classDD_1_1Image_1_1Render.html#aa402d3d515ee9ccd074ec44dfdb39c6b">DD::Image::Render::build_handles()</a>.</p>

</div>
</div>
<a class="anchor" id="ae8c65314eda731d9e09dadd293ae273b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Op::panel_visible </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the control panel for the node is open. This can be used to turn the visiblility of handles on/off. </p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Transform.html#a89239e1d50e3f24f7d7a3fba00a3dbbe">DD::Image::Transform::build_handles()</a>, <a class="el" href="classDD_1_1Image_1_1Render.html#aa402d3d515ee9ccd074ec44dfdb39c6b">DD::Image::Render::build_handles()</a>, and <a class="el" href="classDD_1_1Image_1_1Write.html#a5650e145be0132468ac805d2a6dc27d1">DD::Image::Write::updateDefaultLUT()</a>.</p>

</div>
</div>
<a class="anchor" id="ae60d53348e4bccb9f32b09f911c86a4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Op::node_disabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the Nuke Node that created this <a class="el" href="classDD_1_1Image_1_1Op.html" title="Base class of all the things that can be created by Nuke nodes. ">Op</a> is disabled. </p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1RenderScene.html#a45b1c86c34437eac2e75ffd0e6cee448">DD::Image::RenderScene::_request()</a>, <a class="el" href="classDD_1_1Image_1_1ViewerContext.html#a021f9545fd49f3b940506fc57ebad4a3">DD::Image::ViewerContext::addCamera()</a>, <a class="el" href="classDD_1_1Image_1_1ViewerContext.html#a801c446b0489925d2efeb2826c7d99d8">DD::Image::ViewerContext::addLight()</a>, <a class="el" href="classDD_1_1Image_1_1TransformGeo.html#afa6576a607819ccbf51882a884a4e1f6">DD::Image::TransformGeo::build_handles()</a>, <a class="el" href="classDD_1_1Image_1_1Transform.html#a89239e1d50e3f24f7d7a3fba00a3dbbe">DD::Image::Transform::build_handles()</a>, <a class="el" href="classDD_1_1Image_1_1GeoOp.html#ac4d98ee7c3b175b08fab14ee83b50549">DD::Image::GeoOp::build_matrix_handles()</a>, <a class="el" href="classDD_1_1Image_1_1ComplexLightOp.html#a8a2e010dcb839688632ad8893b10a1c6">DD::Image::ComplexLightOp::draw_handle()</a>, <a class="el" href="classDD_1_1Image_1_1LightOp.html#a540b22a17b692092402465dc9538cbc5">DD::Image::LightOp::draw_handle()</a>, <a class="el" href="classDD_1_1Image_1_1Scene.html#ad825a571c92d0611e08af922eb19e3f4">DD::Image::Scene::evaluate_lights()</a>, <a class="el" href="classDD_1_1Image_1_1Scene.html#ae0226b859d5d27e5a5bb7ecc59f9f536">DD::Image::Scene::request()</a>, <a class="el" href="classDD_1_1Image_1_1ComplexLightOp.html#ace0e6013f17ac715c494dacc44ebf5dc">DD::Image::ComplexLightOp::shade_GL()</a>, and <a class="el" href="classDD_1_1Image_1_1LightOp.html#afccbb825cb76b21bd509f3d7c05bd813">DD::Image::LightOp::shade_GL()</a>.</p>

</div>
</div>
<a class="anchor" id="ab402de75ab56921663b55f853587627b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Op::node_selected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the node is selected by the user. This can be used to turn a wireframe preview on/off. </p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1GeoOp.html#a784a8ee80f408ea1df56d3f46b90ea7a">DD::Image::GeoOp::add_draw_geometry()</a>, <a class="el" href="classDD_1_1Image_1_1AxisOp.html#a368a8c3f618a2cb06ec4c8d0fccaa73a">DD::Image::AxisOp::build_handles()</a>, <a class="el" href="classDD_1_1Image_1_1ComplexLightOp.html#a8a2e010dcb839688632ad8893b10a1c6">DD::Image::ComplexLightOp::draw_handle()</a>, <a class="el" href="classDD_1_1Image_1_1CameraOp.html#a8c4002730a75e3c05618459917268307">DD::Image::CameraOp::draw_handle()</a>, <a class="el" href="classDD_1_1Image_1_1AxisOp.html#ac45085bd760fed42cde18b60eedb8c09">DD::Image::AxisOp::draw_handle()</a>, <a class="el" href="classDD_1_1Image_1_1LightOp.html#a540b22a17b692092402465dc9538cbc5">DD::Image::LightOp::draw_handle()</a>, and <a class="el" href="classDD_1_1Image_1_1GeoOp.html#ace1a847e9b32e30bc385cd1063505a17">DD::Image::GeoOp::select_geometry()</a>.</p>

</div>
</div>
<a class="anchor" id="a5c243a7fa9b978742fc461cb4df23592"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Op::node_gl_color </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the color selected by the user to draw things in the viewer. The return value is of the form 0xrrggbb00. </p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1GeoOp.html#a382c89d2fd4ece23ed5728f4a5c2579d">DD::Image::GeoOp::get_geometry()</a>, and <a class="el" href="classDD_1_1Image_1_1GeoOp.html#a1dc735a575e03d2c0ba1e449d5337618">DD::Image::GeoOp::update_geometry_hashes()</a>.</p>

</div>
</div>
<a class="anchor" id="a1e36f90d0838e7ac1b0e0dac9fa15ca3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * Op::field </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Locate the memory that will be stored into by the knob with the given name and return a pointer to it. Returns null if not found.</p>
<p>This works by calling <a class="el" href="classDD_1_1Image_1_1Op.html#a74011be78d484b8241939c392ab9b653">knobs()</a> with a special callback function that examines each callback for the correct name. This is not particularily fast so you may want to store the retuned pointer somewhere.</p>
<p>This will work even if <a class="el" href="classDD_1_1Image_1_1Op.html#a3bbfe0c075c8844df6b49d5ea400c52a">knob()</a> does not work. It will work for internal <a class="el" href="classDD_1_1Image_1_1Op.html" title="Base class of all the things that can be created by Nuke nodes. ">Op</a> instances made with <a class="el" href="classDD_1_1Image_1_1Op.html#ab9ffa08d0a7e8b1d071a6f7bdcb5e106">create()</a> or by direct construction that are not visible to the user and have no knobs. </p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Op.html#a36806d21434105c3fce012d162b3ed94">get_field()</a>, and <a class="el" href="classDD_1_1Image_1_1Op.html#a43260b9f61dc1ff269a93acab40b8b6c">set_field()</a>.</p>

</div>
</div>
<a class="anchor" id="a4ed442e5319c28645301c7760072e412"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * Op::field </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as the other <a class="el" href="classDD_1_1Image_1_1Op.html#a1e36f90d0838e7ac1b0e0dac9fa15ca3">field()</a>, but if the field is found then <em>type</em> is set to an enumeration (defined in <a class="el" href="Knobs_8h.html" title="Knob creation functions. ">Knobs.h</a>) for the type of knob. This can be used to do type-safety tests of the storage location. </p>

<p>References <a class="el" href="classDD_1_1Image_1_1Op.html#a74011be78d484b8241939c392ab9b653">knobs()</a>.</p>

</div>
</div>
<a class="anchor" id="a43260b9f61dc1ff269a93acab40b8b6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * Op::set_field </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy data to a field in an extremely type unsafe manner. Basically this does memcpy(field(name),data,size). Make sure you know what you are doing. Returns the field or null if the field was not found. </p>

<p>References <a class="el" href="classDD_1_1Image_1_1Op.html#a1e36f90d0838e7ac1b0e0dac9fa15ca3">field()</a>.</p>

</div>
</div>
<a class="anchor" id="a36806d21434105c3fce012d162b3ed94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * Op::get_field </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy data from a field in an extremely type unsafe manner. Basically this does memcpy(data,field(name),size). Make sure you know what you are doing. Returns the field or null if the field was not found. </p>

<p>References <a class="el" href="classDD_1_1Image_1_1Op.html#a1e36f90d0838e7ac1b0e0dac9fa15ca3">field()</a>.</p>

</div>
</div>
<a class="anchor" id="ad0f128321842f15450b575aefedca602"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op::beginHandle </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDD_1_1Image_1_1ViewerContext.html">ViewerContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EventCallback *&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>z</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDD_1_1Image_1_1ViewerContext.html#ac9c915d433bdce7b6b47c0956c850f43">ViewerContext::Cursor</a>&#160;</td>
          <td class="paramname"><em>cursor</em> = <code>ViewerContext::kNoCursor</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback handling. Used to register callbacks to receive Viewer events listed in the HandleType callback. The op must implement an add_draw_handle call from it's build_handles to ensure that draw_handle gets called. The op can then register callbacks from within it's draw_handle to receive these events. </p>

</div>
</div>
<a class="anchor" id="aac5d7e37ec7090d95e064575e648ae40"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Op::knob_changed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDD_1_1Image_1_1Knob.html">Knob</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whenever the user moves a <a class="el" href="classDD_1_1Image_1_1Knob.html">Knob</a> this is called with a pointer to the <a class="el" href="classDD_1_1Image_1_1Knob.html">Knob</a>, on one of the Ops controlled by that <a class="el" href="classDD_1_1Image_1_1Knob.html">Knob</a>. The purpose is to automatically enable/disable or set the values of other knobs.</p>
<p>Do not assume this is called on all instances of your Op! It will not be in cases of clones or multiple frame numbers in Nuke. So storing results in this call is wrong! To get values out of knobs you must either rely on them being stored and <a class="el" href="classDD_1_1Image_1_1Op.html#a54fe7079e0236ae45b247dd9f5e300b4">validate()</a> being called, or you must ask for them using knob(name)-&gt;value().</p>
<p>You must return non-zero if you do anything. Returning zero indicates that there is no need to call this on the same knob again. Base class returns zero always. </p>

<p>Reimplemented in <a class="el" href="classDD_1_1Image_1_1ReadGeo.html#a0a764cc70d844284cf0498f18d6b2747">DD::Image::ReadGeo</a>, <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#a7ebcbce1b005acb2039180935dba9d5c">DD::Image::NukeWrapper</a>, <a class="el" href="classDD_1_1Image_1_1GeoOp.html#ae6bdd2fb36e3c25bba2f003f69a0c6d8">DD::Image::GeoOp</a>, and <a class="el" href="classDD_1_1Image_1_1DrawIop.html#a791e0672e4e5568059cc09cdefa41537">DD::Image::DrawIop</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#a7ebcbce1b005acb2039180935dba9d5c">DD::Image::NukeWrapper::knob_changed()</a>.</p>

</div>
</div>
<a class="anchor" id="a5a6acb4a433796a5b0c7940542b4db31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op::addTime </td>
          <td>(</td>
          <td class="paramtype">OpTimer::Category&#160;</td>
          <td class="paramname"><em>category</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>microsecondsCPU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>microsecondsWall</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isTopLevel</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>add the amount of time /microseconds/ to the debug info. Avoid doing this manually, try to use the <a class="el" href="classDD_1_1Image_1_1OpTimer.html">OpTimer</a> class instead. </p>

<p>References <a class="el" href="classDD_1_1Image_1_1Op.html#a5a6acb4a433796a5b0c7940542b4db31">addTime()</a>, and <a class="el" href="classDD_1_1Image_1_1Op.html#a0d4340b2a813327a249698c0dee107bb">parent()</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Op.html#a5a6acb4a433796a5b0c7940542b4db31">addTime()</a>.</p>

</div>
</div>
<a class="anchor" id="af1088a7c1e940c479bd74dae025fabb2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Op::inputArrows </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nodeInputs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>overriden by Ops to specify the number of input arrows to display on the DAG the op has not been stored/generated. nodeInputs is how many inputs are connected to the node right now (or rather, the index of the first unconnected input). Returning -1 (which the default implementation always does) indicates that the DAG should use its default behaviour. </p>

</div>
</div>
<a class="anchor" id="aa01955aa08bcdfb41a9721c8cb427f3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Op::script_command </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>py</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>eval</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classDD_1_1Image_1_1Execute.html">Execute</a> the string in Nuke's scripting language. Returns true on success, false if there is an error. The resulting output (either text or an error message) is in <a class="el" href="classDD_1_1Image_1_1Op.html#adf4e21f64f6c0baadf262531f269294f">script_result()</a>. You <em>must</em> call <a class="el" href="classDD_1_1Image_1_1Op.html#a247330fc3bf38dd571628fce4b7c1e58">script_unlock()</a> after you are done looking at the result, if you want to keep it around you should copy it to your own memory. </p>

<p>References <a class="el" href="classDD_1_1Image_1_1Op.html#a1e65ba0209479090ca51fc3d0b60e8ea">node()</a>.</p>

</div>
</div>
<a class="anchor" id="a697e2a3194de8f4444d09971db44ed0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Op::script_expand </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>"expand" the string in Nuke's scripting language. Returns true on success, false if there is an error. The resulting output (either the expanded text or an error message) is in <a class="el" href="classDD_1_1Image_1_1Op.html#adf4e21f64f6c0baadf262531f269294f">script_result()</a>. You must call <a class="el" href="classDD_1_1Image_1_1Op.html#a247330fc3bf38dd571628fce4b7c1e58">script_unlock()</a> after you are done looking at the result, if you want to keep it around you should copy it to your own memory.</p>
<p>The current version replaces backslash sequences, executes "[command]" and inserts the result, and replaces $variable with global tcl variables. It also will produce strange results if the DDString.has mismatched quotes or curly braces in it.</p>
<p>If the string does not contain any special characters then <em>result</em> is set directly to it. Be aware of this if you attempt to delete <em>string</em>.</p>
<p>This is very similar to script_command("return string") except it avoids some quoting problems and is much faster in the common case where there are no commands. </p>

<p>References <a class="el" href="classDD_1_1Image_1_1Op.html#a1e65ba0209479090ca51fc3d0b60e8ea">node()</a>.</p>

</div>
</div>
<a class="anchor" id="adf4e21f64f6c0baadf262531f269294f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * Op::script_result </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>py</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The result of the most recent <a class="el" href="classDD_1_1Image_1_1Op.html#aa01955aa08bcdfb41a9721c8cb427f3f">script_command()</a> or <a class="el" href="classDD_1_1Image_1_1Op.html#a697e2a3194de8f4444d09971db44ed0f">script_expand()</a>. For multithreading this buffer is protected by a recursive lock that is set by calling <a class="el" href="classDD_1_1Image_1_1Op.html#aa01955aa08bcdfb41a9721c8cb427f3f">script_command()</a> or <a class="el" href="classDD_1_1Image_1_1Op.html#a697e2a3194de8f4444d09971db44ed0f">script_expand()</a>. You <em>must</em> call <a class="el" href="classDD_1_1Image_1_1Op.html#a247330fc3bf38dd571628fce4b7c1e58">script_unlock()</a> to release the lock. </p>

</div>
</div>
<a class="anchor" id="a247330fc3bf38dd571628fce4b7c1e58"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Op::script_unlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allow the memory for <a class="el" href="classDD_1_1Image_1_1Op.html#adf4e21f64f6c0baadf262531f269294f">script_result()</a> to the most recent <a class="el" href="classDD_1_1Image_1_1Op.html#aa01955aa08bcdfb41a9721c8cb427f3f">script_command()</a> or <a class="el" href="classDD_1_1Image_1_1Op.html#a697e2a3194de8f4444d09971db44ed0f">script_expand()</a> to be reused. You <em>must</em> call this exactly once for every call to <a class="el" href="classDD_1_1Image_1_1Op.html#aa01955aa08bcdfb41a9721c8cb427f3f">script_command()</a> or <a class="el" href="classDD_1_1Image_1_1Op.html#a697e2a3194de8f4444d09971db44ed0f">script_expand()</a>! </p>

</div>
</div>
<a class="anchor" id="a7a50f7c26535dd6c84390c67c08c5581"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Op::build_handles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDD_1_1Image_1_1ViewerContext.html">ViewerContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Construct a list of callbacks to draw handles for this <a class="el" href="classDD_1_1Image_1_1Op.html" title="Base class of all the things that can be created by Nuke nodes. ">Op</a>. Because handles are drawn much more often than they are changed a great deal of time is saved by searching and building a list of the functions to call.</p>
<p>The default implementation recursively calls all the input ops (with <a class="el" href="classDD_1_1Image_1_1Op.html#ad953c3235503acb40a508a38458970ae">build_input_handles()</a>) and then calls all the knobs (with <a class="el" href="classDD_1_1Image_1_1Op.html#abee83f5231cc1015a0b30e7b4527f47a">build_knob_handles()</a>).</p>
<p>If the op wants to draw a custom GL interface such as outlines or even texture maps, it must call <a class="el" href="classDD_1_1Image_1_1ViewerContext.html#a5657dba31924a195782d1e719f4455d4">ViewerContext::add_draw_handle()</a> with pointers to routines to be executed to draw the OpenGL. The convenience function <a class="el" href="classDD_1_1Image_1_1Op.html#aba9abeaf38daf13cf9ff013192ddc3ef">Op::add_draw_handle()</a> will cause the virtual function <a class="el" href="classDD_1_1Image_1_1Op.html#abdf77566e651b87bb29483269b56e2b0">draw_handle()</a> to be called for this.</p>
<p>The op can also mess with the transformation in the context, switch the viewer between 2D and 3D, and do other modifications to the OpenGl state. Look at <a class="el" href="classDD_1_1Image_1_1Transform.html">Transform</a>, <a class="el" href="classDD_1_1Image_1_1AxisOp.html" title="AxisOp is the base class for all the 3D objects. It simply contains a transform matrix. ">AxisOp</a> and <a class="el" href="classDD_1_1Image_1_1DrawIop.html">DrawIop</a> for different ways of implementing this. </p>

<p>Reimplemented in <a class="el" href="classDD_1_1Image_1_1Render.html#aa402d3d515ee9ccd074ec44dfdb39c6b">DD::Image::Render</a>, <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#af1a4e212a8d266672fd52be58ef0254f">DD::Image::NukeWrapper</a>, <a class="el" href="classDD_1_1Image_1_1GeoOp.html#abce22573e9b7228f0191cc9991a1c9b8">DD::Image::GeoOp</a>, <a class="el" href="classDD_1_1Image_1_1AxisOp.html#a368a8c3f618a2cb06ec4c8d0fccaa73a">DD::Image::AxisOp</a>, <a class="el" href="classDD_1_1Image_1_1Transform.html#a89239e1d50e3f24f7d7a3fba00a3dbbe">DD::Image::Transform</a>, <a class="el" href="classDD_1_1Image_1_1RenderScene.html#acf63b203c79c4f3570481944ec91c1de">DD::Image::RenderScene</a>, and <a class="el" href="classDD_1_1Image_1_1TransformGeo.html#afa6576a607819ccbf51882a884a4e1f6">DD::Image::TransformGeo</a>.</p>

<p>References <a class="el" href="classDD_1_1Image_1_1Op.html#ad953c3235503acb40a508a38458970ae">build_input_handles()</a>, and <a class="el" href="classDD_1_1Image_1_1Op.html#abee83f5231cc1015a0b30e7b4527f47a">build_knob_handles()</a>.</p>

</div>
</div>
<a class="anchor" id="aba9abeaf38daf13cf9ff013192ddc3ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op::add_draw_handle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDD_1_1Image_1_1ViewerContext.html">ViewerContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience function to call <a class="el" href="classDD_1_1Image_1_1ViewerContext.html#a5657dba31924a195782d1e719f4455d4">ViewerContext::add_draw_handle()</a> with a function that will call this-&gt;<a class="el" href="classDD_1_1Image_1_1Op.html#abdf77566e651b87bb29483269b56e2b0">draw_handle()</a>. </p>

<p>References <a class="el" href="classDD_1_1Image_1_1ViewerContext.html#a5657dba31924a195782d1e719f4455d4">DD::Image::ViewerContext::add_draw_handle()</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Transform.html#a89239e1d50e3f24f7d7a3fba00a3dbbe">DD::Image::Transform::build_handles()</a>, and <a class="el" href="classDD_1_1Image_1_1AxisOp.html#a368a8c3f618a2cb06ec4c8d0fccaa73a">DD::Image::AxisOp::build_handles()</a>.</p>

</div>
</div>
<a class="anchor" id="abdf77566e651b87bb29483269b56e2b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Op::draw_handle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDD_1_1Image_1_1ViewerContext.html">ViewerContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default single method for drawing handles. Simple operators can override this and override <a class="el" href="classDD_1_1Image_1_1Op.html#a7a50f7c26535dd6c84390c67c08c5581">build_handles()</a> to call add_op_handle() and then the base class version of <a class="el" href="classDD_1_1Image_1_1Op.html#a7a50f7c26535dd6c84390c67c08c5581">build_handles()</a>. </p>

<p>Reimplemented in <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#aa4d2f3dbcec8fc661d70ac84d02e81e8">DD::Image::NukeWrapper</a>, <a class="el" href="classDD_1_1Image_1_1LightOp.html#a540b22a17b692092402465dc9538cbc5">DD::Image::LightOp</a>, <a class="el" href="classDD_1_1Image_1_1AxisOp.html#ac45085bd760fed42cde18b60eedb8c09">DD::Image::AxisOp</a>, <a class="el" href="classDD_1_1Image_1_1Transform.html#acddd313dcc0c820c1a8c0b194d8c96f4">DD::Image::Transform</a>, <a class="el" href="classDD_1_1Image_1_1DrawIop.html#a12edb08a355454225bba5e69be139790">DD::Image::DrawIop</a>, <a class="el" href="classDD_1_1Image_1_1CameraOp.html#a8c4002730a75e3c05618459917268307">DD::Image::CameraOp</a>, and <a class="el" href="classDD_1_1Image_1_1ComplexLightOp.html#a8a2e010dcb839688632ad8893b10a1c6">DD::Image::ComplexLightOp</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#aa4d2f3dbcec8fc661d70ac84d02e81e8">DD::Image::NukeWrapper::draw_handle()</a>.</p>

</div>
</div>
<a class="anchor" id="a31c6dce4be81844688cda2cd19f4de5f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Op::add_input_handle </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDD_1_1Image_1_1ViewerContext.html">ViewerContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Call <a class="el" href="classDD_1_1Image_1_1Op.html#a7a50f7c26535dd6c84390c67c08c5581">build_handles()</a> on an input to this op. The input numbers are the user-visible numbers (not the result of split_inputs().</p>
<p>This is better than calling <a class="el" href="classDD_1_1Image_1_1Op.html#a7a50f7c26535dd6c84390c67c08c5581">build_handles()</a> on the input directly, as it checks to see if the operator was visited already (not doing this can make it exponentially slow when there are many splits and joins in a script), and it saves and restores parts of the ctx like the transform so they can be changed by the operator, and it skips added operators like PostageStamp that should not be visible to the user.</p>
<p>Special values for input: -1 means do <em>this</em> op, -2 means do each inputs where <a class="el" href="classDD_1_1Image_1_1Op.html#a814d71f7e6af7bbd10b771eb4439ee61">uses_input()</a> is non-zero. </p>

<p>Reimplemented in <a class="el" href="classDD_1_1Image_1_1ParticleOp.html#af6f59ac14e26da3bedd55e4f2bd9665d">DD::Image::ParticleOp</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1ParticleOp.html#af6f59ac14e26da3bedd55e4f2bd9665d">DD::Image::ParticleOp::add_input_handle()</a>, <a class="el" href="classDD_1_1Image_1_1TransformGeo.html#afa6576a607819ccbf51882a884a4e1f6">DD::Image::TransformGeo::build_handles()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#ad953c3235503acb40a508a38458970ae">build_input_handles()</a>, and <a class="el" href="classDD_1_1Image_1_1GeoOp.html#ac4d98ee7c3b175b08fab14ee83b50549">DD::Image::GeoOp::build_matrix_handles()</a>.</p>

</div>
</div>
<a class="anchor" id="a448fc3791b6e2bb8339e023f2bb01ada"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op::add_knob_handle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDD_1_1Image_1_1Knob.html">Knob</a> *&#160;</td>
          <td class="paramname"><em>knob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDD_1_1Image_1_1ViewerContext.html">ViewerContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as knob-&gt;add_draw_handle(ctx). This is for back-compatibility only. </p>

<p>References <a class="el" href="classDD_1_1Image_1_1Knob.html#a8630ea6b7ea56c39e797952bafbedb34">DD::Image::Knob::add_draw_handle()</a>.</p>

</div>
</div>
<a class="anchor" id="a8c47564f84fd480311d0f080839b0c95"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Op::getViewableModes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a bitmask of the suggested viewable modes supported for this op.</p>
<p>The return value should a bitmask of or'ed together values from the ViewableModes enum.</p>
<p>The Nuke viewer will automatically switch to 3D or 2D modes when connected to an op that is only vieweable in a single mode.</p>
<p>The default implementation does the following:</p>
<p>returns eViewableMode3D for ops that are not Iops or convertable to Iops. returns eViewableMode2D for Iops or ops that can be convertible to Iops, and if all their inputs are the same type as the op. returns ( eViewableMode2D | eViewableMode3D ) for Iops or ops that can be convertible to Iops if they have mixed inputs </p>

<p>References <a class="el" href="classDD_1_1Image_1_1Iop.html#a6f2f504a83ec6ed4bdb8f6b8cca1490b">DD::Image::Iop::default_input()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#a5aea4d307e94fe59bfa2f66b56559030a4880af4193d306883e9051c3bf2dc043">eViewableMode2D</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#a5aea4d307e94fe59bfa2f66b56559030a26b127ee376127e56cf3e8c724746264">eViewableMode3D</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#a1f2eaf5b7de5354cc5838e608cf25543">inputs()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#adb272858c40a05b35e6596f103377bb4">outputContext()</a>, and <a class="el" href="classDD_1_1Image_1_1Op.html#a3f1298d78336302f857270898296703d">test_input()</a>.</p>

</div>
</div>
<a class="anchor" id="a7991d2e6e89553a657049e1273c86c21"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Op::optional_input </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Index of the first "optional" input. The inputs between this number and <a class="el" href="classDD_1_1Image_1_1Op.html#acd7d2c60fe1d600584aacb9ffe8d900c">minimum_inputs()</a> are displayed differently in Nuke to indicate that it is ok for them to not be connected. Used by the mask inputs. The default version returns <a class="el" href="classDD_1_1Image_1_1Op.html#acd7d2c60fe1d600584aacb9ffe8d900c">minimum_inputs()</a>, which means there are no optional inputs. </p>

<p>Reimplemented in <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#ae96db1b2f1199d1dd9b9fab6cbb72e8b">DD::Image::NukeWrapper</a>.</p>

<p>References <a class="el" href="classDD_1_1Image_1_1Op.html#acd7d2c60fe1d600584aacb9ffe8d900c">minimum_inputs()</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#ae96db1b2f1199d1dd9b9fab6cbb72e8b">DD::Image::NukeWrapper::optional_input()</a>.</p>

</div>
</div>
<a class="anchor" id="acd7d2c60fe1d600584aacb9ffe8d900c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Op::minimum_inputs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The minimum number of input connections the operator can have. Default is <a class="el" href="classDD_1_1Image_1_1Op.html#a1f2eaf5b7de5354cc5838e608cf25543">inputs()</a>. </p>

<p>Reimplemented in <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#a5e76c2c100677aae2d209032c62ea690">DD::Image::NukeWrapper</a>.</p>

<p>References <a class="el" href="classDD_1_1Image_1_1Op.html#a1f2eaf5b7de5354cc5838e608cf25543">inputs()</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#aeda64ddd68ad1ba134854300bed02e4a">DD::Image::NukeWrapper::NukeWrapper()</a>, and <a class="el" href="classDD_1_1Image_1_1Op.html#a7991d2e6e89553a657049e1273c86c21">optional_input()</a>.</p>

</div>
</div>
<a class="anchor" id="a7a9392b9827e2f79f2bac7d3317b4065"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Op::maximum_inputs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The maximum number of input connections the operator can have. There may be more <a class="el" href="classDD_1_1Image_1_1Op.html#a1f2eaf5b7de5354cc5838e608cf25543">inputs()</a> if <a class="el" href="classDD_1_1Image_1_1Op.html#abef17d0f45fe7540c4893983d1b0e45e">split_input()</a> is used. The default return value is <a class="el" href="classDD_1_1Image_1_1Op.html#a1f2eaf5b7de5354cc5838e608cf25543">inputs()</a>. </p>

<p>Reimplemented in <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#afb418bbcd62ece283c5aa7ff0a64093a">DD::Image::NukeWrapper</a>.</p>

<p>References <a class="el" href="classDD_1_1Image_1_1Op.html#a1f2eaf5b7de5354cc5838e608cf25543">inputs()</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Op.html#a2a213156968fa2fc9bbe92f40e059ea3">input_label()</a>, and <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#afb418bbcd62ece283c5aa7ff0a64093a">DD::Image::NukeWrapper::maximum_inputs()</a>.</p>

</div>
</div>
<a class="anchor" id="a3f1298d78336302f857270898296703d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Op::test_input </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDD_1_1Image_1_1Op.html">Op</a> *&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This virtual function lets an operator decide what kinds of things to connect to the input. It can use any test wanted, but usually uses RTTI dynamic_cast&lt;class*&gt; to see if the <a class="el" href="classDD_1_1Image_1_1Op.html" title="Base class of all the things that can be created by Nuke nodes. ">Op</a> is the correct subclass. If this returns false, then Nuke will use <a class="el" href="classDD_1_1Image_1_1Op.html#a18a1ce753b5e575eadf779b78e962bfd">default_input()</a> to generate the op that will be connected to this input.</p>
<p>If you implement <a class="el" href="classDD_1_1Image_1_1Op.html#abef17d0f45fe7540c4893983d1b0e45e">split_input()</a> <em>n</em> is the user-visible input number, but <a class="el" href="classDD_1_1Image_1_1Op.html#a3b26296e171162ecf103fd75827bef6e">set_input()</a> will be called with the split input number.</p>
<p>The default version returns false, so you can't hook anything up. </p>

<p>Reimplemented in <a class="el" href="classDD_1_1Image_1_1Iop.html#a731050e753f6b55f9383852297e6beae">DD::Image::Iop</a>, <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#aa4fe766138a2cdd19a5d25bb22c11b46">DD::Image::NukeWrapper</a>, <a class="el" href="classDD_1_1Image_1_1GeoOp.html#aab389c0a4af7dd3ccd6c3d4e07ffc373">DD::Image::GeoOp</a>, <a class="el" href="classDD_1_1Image_1_1AxisOp.html#abcf95a4280ff9273320ccdfa4a9cf504">DD::Image::AxisOp</a>, <a class="el" href="classDD_1_1Image_1_1TransformGeo.html#a82082329cd7761b6664c66f235cb4858">DD::Image::TransformGeo</a>, and <a class="el" href="classDD_1_1Image_1_1DeepFilterOp.html#a9a80a262013fc8e56799164475af33fa">DD::Image::DeepFilterOp</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Op.html#a8c47564f84fd480311d0f080839b0c95">getViewableModes()</a>.</p>

</div>
</div>
<a class="anchor" id="a1f2eaf5b7de5354cc5838e608cf25543"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int DD::Image::Op::inputs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Current number of inputs. Nuke will set this to inputNumber(node_inputs()). </p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Write.html#a9ac973ff93bff010d602ea2c82b29aa1">DD::Image::Write::_request()</a>, <a class="el" href="classDD_1_1Image_1_1Iop.html#aa8864e1084f0c08996ef897d1e2a3312">DD::Image::Iop::_request()</a>, <a class="el" href="classDD_1_1Image_1_1Write.html#a24b3332f92388c30a53211b413c4a885">DD::Image::Write::_validate()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#ae1dc586d97dd3e752bd3573bb7665b84">_validate()</a>, <a class="el" href="classDD_1_1Image_1_1Iop.html#a5285c26469bf1fccfd61c554d5bf71fb">DD::Image::Iop::_validate()</a>, <a class="el" href="classDD_1_1Image_1_1Black.html#a1d7811a18f57a108b451be9a8b02ba0a">DD::Image::Black::Black()</a>, <a class="el" href="classDD_1_1Image_1_1GeoOp.html#ac4d98ee7c3b175b08fab14ee83b50549">DD::Image::GeoOp::build_matrix_handles()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#a578ecede84d9c432c3cd8b4496d4b16e">doPreValidate()</a>, <a class="el" href="classDD_1_1Image_1_1Write.html#ae76f84680bb2d23603e7bc3b32ef0de5">DD::Image::Write::execute()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#aa9691f132bb2bc8cf3ed5c27e6a1ef4f">forget_request()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#a8c47564f84fd480311d0f080839b0c95">getViewableModes()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#a7a9392b9827e2f79f2bac7d3317b4065">maximum_inputs()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#acd7d2c60fe1d600584aacb9ffe8d900c">minimum_inputs()</a>, <a class="el" href="classDD_1_1Image_1_1NullGeo.html#a3630a733efc60bc4f5b033f838ded27c">DD::Image::NullGeo::NullGeo()</a>, <a class="el" href="namespaceDD_1_1Image.html#a866e8bc35cae6e1d57285fae38cb2b94">DD::Image::RecursiveUseFilesystem()</a>, <a class="el" href="classDD_1_1Image_1_1RenderScene.html#a2b0c59f4f37482a24984916ef5084d47">DD::Image::RenderScene::render_camera()</a>, and <a class="el" href="classDD_1_1Image_1_1SourceGeo.html#a47f3569644ef139285842eff6b904be2">DD::Image::SourceGeo::SourceGeo()</a>.</p>

</div>
</div>
<a class="anchor" id="a478c5f12fe443a94630a6b1ecb9020d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Op::node_inputs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Current number of inputs that the user sees in the Nuke DAG. This may be different than <a class="el" href="classDD_1_1Image_1_1Op.html#a1f2eaf5b7de5354cc5838e608cf25543">inputs()</a> if you implement <a class="el" href="classDD_1_1Image_1_1Op.html#abef17d0f45fe7540c4893983d1b0e45e">split_input()</a>. </p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1ParticleOp.html#adee80501072cc12fa02ee350e575e1d0">DD::Image::ParticleOp::appendSimulationCurve()</a>.</p>

</div>
</div>
<a class="anchor" id="ad60adcf8b3c3db91ee559210046e6d6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDD_1_1Image_1_1Op.html">Op</a> * Op::node_input </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDD_1_1Image_1_1Op.html#a7143e1bbe81a3903c73fbae0161bcfe6">Op::GenerateType</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="classDD_1_1Image_1_1Op.html#a7143e1bbe81a3903c73fbae0161bcfe6af5c264e7de144944fffb68f98029f0e0">OUTPUT_OP</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an op tree that <em>could</em> be connected to input <em>n</em>. This allows you to peek at your input ops before <a class="el" href="classDD_1_1Image_1_1Op.html#a54fe7079e0236ae45b247dd9f5e300b4">validate()</a> is called, such as in <a class="el" href="classDD_1_1Image_1_1Op.html#a74011be78d484b8241939c392ab9b653">knobs()</a> or in the constructor. Or you can use this to peek at an input after <a class="el" href="classDD_1_1Image_1_1Op.html#a814d71f7e6af7bbd10b771eb4439ee61">uses_input()</a> returns zero or <a class="el" href="classDD_1_1Image_1_1Op.html#abef17d0f45fe7540c4893983d1b0e45e">split_input()</a> returns zero or negative.</p>
<p><em>n</em> is the user-visible input number. If you implement <a class="el" href="classDD_1_1Image_1_1Op.html#abef17d0f45fe7540c4893983d1b0e45e">split_input()</a> this may be different than input(n), but it is the same as input(n,0).</p>
<p><em>type</em> determines what exactly is in the returned op.</p><ul>
<li><a class="el" href="classDD_1_1Image_1_1Op.html#a7143e1bbe81a3903c73fbae0161bcfe6af5c264e7de144944fffb68f98029f0e0" title="Return op with no knobs stored or inputs built. ">Op::OUTPUT_OP</a> returns an <a class="el" href="classDD_1_1Image_1_1Op.html" title="Base class of all the things that can be created by Nuke nodes. ">Op</a> that you can call <a class="el" href="classDD_1_1Image_1_1Op.html#a4fc5fd8a59a843cfd322b132b5ae426d">Class()</a> on but not much else. <a class="el" href="classDD_1_1Image_1_1Knob.html">Knob</a> values have not been stored in it and no inputs are hooked up.</li>
<li><a class="el" href="classDD_1_1Image_1_1Op.html#a7143e1bbe81a3903c73fbae0161bcfe6a829454cb678ec06c8c3317568546fdf4" title="Return tree but maybe at a different OutputContext. ">Op::ANY_CONTEXT</a> will return an op created for this version of the tree but it may return it set to a different <a class="el" href="classDD_1_1Image_1_1OutputContext.html">OutputContext</a>. This lets you call almost anything but you cannot depend on any animated values being correct.</li>
<li><a class="el" href="classDD_1_1Image_1_1Op.html#a7143e1bbe81a3903c73fbae0161bcfe6a10d859f897448e28792026f0986b35c9" title="Same as ANY_CONTEXT but skip disabled ops. ">Op::INPUT_OP</a> is like ANY_CONTEXT but skips disabled nodes so it returns the actual op that will be used to create data. Used by code that wants to peek at the output data, such as the format or frame range, but does not require the exact correct frame number or view.</li>
<li><a class="el" href="classDD_1_1Image_1_1Op.html#a7143e1bbe81a3903c73fbae0161bcfe6ad4d97afa4899876ffde41bd9299f731c" title="Returns op tree for right context. Skips disabled ops on inputs (but not main op) ...">Op::EXECUTABLE</a> forces the <a class="el" href="classDD_1_1Image_1_1OutputContext.html">OutputContext</a> to be a certain value. Don't use this as I have not decided what this certain value is yet (may be <a class="el" href="classDD_1_1Image_1_1Op.html#aec4cf62da84ac80bf8c53ee99aeebb66">uiContext()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#adb272858c40a05b35e6596f103377bb4">outputContext()</a>, or <a class="el" href="classDD_1_1Image_1_1Op.html#a843a2b11746037eecfa0686fd7215cc1">inputContext()</a>...)</li>
<li><a class="el" href="classDD_1_1Image_1_1Op.html#a7143e1bbe81a3903c73fbae0161bcfe6a75cd54701210e07bd9a3239d5cd02bed" title="Returns op tree for right context, with skipping, and replaces PostageStamp/TextureMap ops...">Op::EXECUTABLE_INPUT</a> both forces the <a class="el" href="classDD_1_1Image_1_1OutputContext.html">OutputContext</a> and skips disabled nodes, and also inserts hidden ops used to generate Postage stamps and texture maps. This is as close as possible to the actual <a class="el" href="classDD_1_1Image_1_1Op.html" title="Base class of all the things that can be created by Nuke nodes. ">Op</a> that will be connected to this input.</li>
</ul>
<p>If the input is not connected, OUTPUT_OP will return NULL, since this is commonly used to check if an input is connected. Note that if default_input(n) returns NULL, you cannot distinguish a disconnected input from an input connected to a Switch or other non-op node that is itself disconnected.</p>
<p>All other values for <em>type</em> return default_input(n) if the input is not connected.</p>
<p>Except for <em>type</em> of OUTPUT_OP, this is slow, and if the context it uses is wrong, it will cause extra instances of the entire <a class="el" href="classDD_1_1Image_1_1Op.html" title="Base class of all the things that can be created by Nuke nodes. ">Op</a> tree to be generated, which can be very wasteful depending on the <a class="el" href="classDD_1_1Image_1_1Op.html" title="Base class of all the things that can be created by Nuke nodes. ">Op</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classDD_1_1Image_1_1Op.html#a478c5f12fe443a94630a6b1ecb9020d7">node_inputs()</a>, <a class="el" href="classDD_1_1Image_1_1Execute.html">DD::Image::Execute</a> </dd></dl>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1RenderScene.html#acf63b203c79c4f3570481944ec91c1de">DD::Image::RenderScene::build_handles()</a>, <a class="el" href="classDD_1_1Image_1_1Write.html#ae76f84680bb2d23603e7bc3b32ef0de5">DD::Image::Write::execute()</a>, <a class="el" href="classDD_1_1Image_1_1Write.html#a056aa0257240a0f0f6ede7cfb38cdd7a">DD::Image::Write::isWrite()</a>, <a class="el" href="classDD_1_1Image_1_1DrawIop.html#a791e0672e4e5568059cc09cdefa41537">DD::Image::DrawIop::knob_changed()</a>, and <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#a7ebcbce1b005acb2039180935dba9d5c">DD::Image::NukeWrapper::knob_changed()</a>.</p>

</div>
</div>
<a class="anchor" id="a29555dfdeb6d61fbf78011642417e0fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDD_1_1Image_1_1Op.html">Op</a> * DD::Image::Op::input_op </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as node_input(n, INPUT_OP), this is provided for back-compatibility </p>

</div>
</div>
<a class="anchor" id="a86a4ce0ce33ec442202dd4e272e2a96b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Op::inputs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Change the number returned by <a class="el" href="classDD_1_1Image_1_1Op.html#a1f2eaf5b7de5354cc5838e608cf25543">inputs()</a>. Actually resizes array. New entries are NULL; old ones have removeOutput called on them if set. </p>

<p>References <a class="el" href="classDD_1_1Image_1_1Op.html#a3f8fb27d42f6da712722fa73eda6b5b0">input()</a>, and <a class="el" href="classDD_1_1Image_1_1Op.html#a3b26296e171162ecf103fd75827bef6e">set_input()</a>.</p>

</div>
</div>
<a class="anchor" id="a3f8fb27d42f6da712722fa73eda6b5b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDD_1_1Image_1_1Op.html">Op</a> * Op::input </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return input <em>n</em>. This is the same as input(n, 0) if you do not implement <a class="el" href="classDD_1_1Image_1_1Op.html#abef17d0f45fe7540c4893983d1b0e45e">split_input()</a>, but is much faster.</p>
<p>This is null if <a class="el" href="classDD_1_1Image_1_1Op.html#a3b26296e171162ecf103fd75827bef6e">set_input()</a> has not been called.</p>
<p>Nuke only calls <a class="el" href="classDD_1_1Image_1_1Op.html#a3b26296e171162ecf103fd75827bef6e">set_input()</a> just before <a class="el" href="classDD_1_1Image_1_1Op.html#a54fe7079e0236ae45b247dd9f5e300b4">validate()</a> is called, and only if <a class="el" href="classDD_1_1Image_1_1Op.html#a814d71f7e6af7bbd10b771eb4439ee61">uses_input()</a> returns non-zero. If you want to look at the input op before this (such as in <a class="el" href="classDD_1_1Image_1_1Op.html#a843a2b11746037eecfa0686fd7215cc1">inputContext()</a> methods) you must use <a class="el" href="classDD_1_1Image_1_1Op.html#ad60adcf8b3c3db91ee559210046e6d6b">node_input()</a>. </p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Op.html#aac28ac7af905cc60ac6ed9ecce16d0d4">_fetchMetaData()</a>, <a class="el" href="classDD_1_1Image_1_1RenderScene.html#ab6f3b5274b541e907ba12b5ffc0844ae">DD::Image::RenderScene::_validate()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#ae1dc586d97dd3e752bd3573bb7665b84">_validate()</a>, <a class="el" href="classDD_1_1Image_1_1ParticleOp.html#af6f59ac14e26da3bedd55e4f2bd9665d">DD::Image::ParticleOp::add_input_handle()</a>, <a class="el" href="classDD_1_1Image_1_1ParticleOp.html#adee80501072cc12fa02ee350e575e1d0">DD::Image::ParticleOp::appendSimulationCurve()</a>, <a class="el" href="classDD_1_1Image_1_1ParticleOp.html#a20b3279efda1a9991e7831f622de7e9b">DD::Image::ParticleOp::appendSimulationInput()</a>, <a class="el" href="classDD_1_1Image_1_1GeoOp.html#ac4d98ee7c3b175b08fab14ee83b50549">DD::Image::GeoOp::build_matrix_handles()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#a578ecede84d9c432c3cd8b4496d4b16e">doPreValidate()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#aa9691f132bb2bc8cf3ed5c27e6a1ef4f">forget_request()</a>, <a class="el" href="classDD_1_1Image_1_1Iop.html#a3c8c86cdb0e213db45825962ea5c3268">DD::Image::Iop::input()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#ab3311c9a30d1f582ab69aeb4e7a018e7">input()</a>, <a class="el" href="classDD_1_1Image_1_1DeepFilterOp.html#a9708abc1bedb5a97e3ff7d58710c71df">DD::Image::DeepFilterOp::input0()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#a86a4ce0ce33ec442202dd4e272e2a96b">inputs()</a>, <a class="el" href="classDD_1_1Image_1_1TransformGeo.html#a57d856ebf0e9b7d8e0f8b6554fa8a1d7">DD::Image::TransformGeo::lookat_input()</a>, <a class="el" href="classDD_1_1Image_1_1AxisOp.html#a05bfec322a1a4dca9ea0eb5abba80566">DD::Image::AxisOp::lookat_input()</a>, <a class="el" href="classDD_1_1Image_1_1RenderScene.html#a2b0c59f4f37482a24984916ef5084d47">DD::Image::RenderScene::render_camera()</a>, <a class="el" href="classDD_1_1Image_1_1RenderScene.html#a5519379b46ea1ebae251683f419c9d97">DD::Image::RenderScene::render_geo()</a>, <a class="el" href="classDD_1_1Image_1_1GeoOp.html#ace1a847e9b32e30bc385cd1063505a17">DD::Image::GeoOp::select_geometry()</a>, and <a class="el" href="classDD_1_1Image_1_1Op.html#a3b26296e171162ecf103fd75827bef6e">set_input()</a>.</p>

</div>
</div>
<a class="anchor" id="a4b531b97920ff151b4cc07bdbf6cd283"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Op::inputNumber </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the "flat" input number from the user-visible input number and an index into the values returned by <a class="el" href="classDD_1_1Image_1_1Op.html#abef17d0f45fe7540c4893983d1b0e45e">split_input()</a>. This is the same as n+offset of you do not implement <a class="el" href="classDD_1_1Image_1_1Op.html#abef17d0f45fe7540c4893983d1b0e45e">split_input()</a>. <em>offset</em> is assumed to be less than abs(split_input(n)). </p>

<p>References <a class="el" href="classDD_1_1Image_1_1Op.html#abef17d0f45fe7540c4893983d1b0e45e">split_input()</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#a97d2f933e4ae12f47d4b32df6d33bbed">DD::Image::NukeWrapper::_validate()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#ab3311c9a30d1f582ab69aeb4e7a018e7">input()</a>, and <a class="el" href="classDD_1_1Image_1_1Op.html#a90e74b3d284d3fb34b448b8b52e18a54">set_input()</a>.</p>

</div>
</div>
<a class="anchor" id="ab3311c9a30d1f582ab69aeb4e7a018e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDD_1_1Image_1_1Op.html">Op</a> * Op::input </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as input(inputNumber(n, offset)); </p>

<p>References <a class="el" href="classDD_1_1Image_1_1Op.html#a3f8fb27d42f6da712722fa73eda6b5b0">input()</a>, and <a class="el" href="classDD_1_1Image_1_1Op.html#a4b531b97920ff151b4cc07bdbf6cd283">inputNumber()</a>.</p>

</div>
</div>
<a class="anchor" id="aba15a593cfe65a8b150cfe442ebe64cd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDD_1_1Image_1_1Op.html">Op</a> * DD::Image::Op::input0 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the primary input </p>
<p>Fast <em>inline</em> method of getting input(0). </p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1AxisOp.html#a3f2acda6bca5938a31cfb21faeff96a2">DD::Image::AxisOp::_validate()</a>, <a class="el" href="classDD_1_1Image_1_1AxisOp.html#a368a8c3f618a2cb06ec4c8d0fccaa73a">DD::Image::AxisOp::build_handles()</a>, <a class="el" href="classDD_1_1Image_1_1Iop.html#a0d95f2d8257ac82a6bcae96b7aa308db">DD::Image::Iop::force_validate()</a>, <a class="el" href="classDD_1_1Image_1_1Iop.html#a51848c95715ac873d6cd0265e504b970">DD::Image::Iop::input0()</a>, and <a class="el" href="classDD_1_1Image_1_1SourceGeo.html#afe6057e659825636c36a04e6d955e5d8">DD::Image::SourceGeo::input_iop()</a>.</p>

</div>
</div>
<a class="anchor" id="a879629bef50c0149cd4301219e7d3425"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Op::input1 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the second input, if it exists </p>
<p>Fast <em>inline</em> method of getting input(1) if it is not null. Warning: this may crash if input(1) is null.</p>
<p>Fast <em>inline</em> method of setting input(1). </p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Iop.html#a43aec063e2536e91b4e48b9a038f9836">DD::Image::Iop::input1()</a>.</p>

</div>
</div>
<a class="anchor" id="aadf5ef411da25098a653238ee467804c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classDD_1_1Image_1_1Op.html">Op</a>*&gt;&amp; DD::Image::Op::getInputs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reference to a vector of all inputs, including input0 and other_inputs. Note that this may contain null pointers if some in between inputs are disconnected. </p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Write.html#ae76f84680bb2d23603e7bc3b32ef0de5">DD::Image::Write::execute()</a>.</p>

</div>
</div>
<a class="anchor" id="ae632494cc8a61316fda1dc2213040079"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classDD_1_1Image_1_1Op.html">Op</a>*&gt;&amp; DD::Image::Op::getChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reference to a vector of all child ops. Avoid using this; it is only really public for op tree traversal. </p>

</div>
</div>
<a class="anchor" id="a3b26296e171162ecf103fd75827bef6e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Op::set_input </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDD_1_1Image_1_1Op.html">Op</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set input(n). This does not change <a class="el" href="classDD_1_1Image_1_1Op.html#a1f2eaf5b7de5354cc5838e608cf25543">inputs()</a>, even if <em>n</em> is greater.</p>
<p>This is a virtual function so that subclasses can set the input pointers for child operators. The arguments to <a class="el" href="classDD_1_1Image_1_1Op.html#a4b531b97920ff151b4cc07bdbf6cd283">inputNumber()</a> are also provided to assist with this. Make sure that any derived classes still call the parent class version though. </p>

<p>Reimplemented in <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#aab25fce5f10e45620883665c3c202f68">DD::Image::NukeWrapper</a>.</p>

<p>References <a class="el" href="classDD_1_1Image_1_1OpTreeHandler.html#aa972de3f49c1950034da1d4cd9b92127">DD::Image::OpTreeHandler::addOpToTrees()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#a3f8fb27d42f6da712722fa73eda6b5b0">input()</a>, and <a class="el" href="classDD_1_1Image_1_1OpTreeHandler.html#a9295914bc790d24272ec636d24a7eec2">DD::Image::OpTreeHandler::removeOpFromTrees()</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Write.html#ae76f84680bb2d23603e7bc3b32ef0de5">DD::Image::Write::execute()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#a86a4ce0ce33ec442202dd4e272e2a96b">inputs()</a>, <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#aab25fce5f10e45620883665c3c202f68">DD::Image::NukeWrapper::set_input()</a>, and <a class="el" href="classDD_1_1Image_1_1Op.html#a90e74b3d284d3fb34b448b8b52e18a54">set_input()</a>.</p>

</div>
</div>
<a class="anchor" id="a22d3e1884fa063fd80a28df2b5d4b574"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DD::Image::Op::set_input0 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDD_1_1Image_1_1Op.html">Op</a> *&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fast <em>inline</em> method of setting input(0). </p>

</div>
</div>
<a class="anchor" id="a90e74b3d284d3fb34b448b8b52e18a54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op::set_input </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDD_1_1Image_1_1Op.html">Op</a> *&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as set_input(inputNumber(n, offset), op, n, offset); </p>

<p>References <a class="el" href="classDD_1_1Image_1_1Op.html#a4b531b97920ff151b4cc07bdbf6cd283">inputNumber()</a>, and <a class="el" href="classDD_1_1Image_1_1Op.html#a3b26296e171162ecf103fd75827bef6e">set_input()</a>.</p>

</div>
</div>
<a class="anchor" id="adb272858c40a05b35e6596f103377bb4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDD_1_1Image_1_1OutputContext.html">OutputContext</a> &amp; DD::Image::Op::outputContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The current context that this <a class="el" href="classDD_1_1Image_1_1Op.html" title="Base class of all the things that can be created by Nuke nodes. ">Op</a> is supposed to produce a picture for. This includes the frame number, the view, etc. </p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Transform.html#ad9b86ff52be5808cff50304f4344c176">DD::Image::Transform::_validate()</a>, <a class="el" href="classDD_1_1Image_1_1ReadGeo.html#aef6bfba04a696b14fcbae079755b6924">DD::Image::ReadGeo::_validate()</a>, <a class="el" href="classDD_1_1Image_1_1Transform.html#aed0d7387a712ca5dbfe2924e55f1fb6b">DD::Image::Transform::append()</a>, <a class="el" href="classDD_1_1Image_1_1Iop.html#a6f2f504a83ec6ed4bdb8f6b8cca1490b">DD::Image::Iop::default_input()</a>, <a class="el" href="classDD_1_1Image_1_1ParticleRender.html#ababfeb287f4ad417820b2d85d1f8392c">DD::Image::ParticleRender::doPreValidate()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#a8c47564f84fd480311d0f080839b0c95">getViewableModes()</a>, <a class="el" href="classDD_1_1Image_1_1RenderScene.html#a0412acaa3eb0bc7b636e25e54375afec">DD::Image::RenderScene::inputContext()</a>, <a class="el" href="classDD_1_1Image_1_1Writer.html#a171ee65911988a0f8acb5c30b4906b18">DD::Image::Writer::inputContext()</a>, <a class="el" href="classDD_1_1Image_1_1Write.html#ab54d30ada0b431c753a246a9abe819ac">DD::Image::Write::inputContext()</a>, <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#a358957d1f70f3b18740c00b16280f0fa">DD::Image::NukeWrapper::inputContext()</a>, <a class="el" href="classDD_1_1Image_1_1Transform.html#a1131cfc5fd81215ebf0574c192193a3e">DD::Image::Transform::matrixAt()</a>, and <a class="el" href="classDD_1_1Image_1_1FileReader.html#a89b8a8836677e9dc5ec7fcc09501d4c9">DD::Image::FileReader::readAllLinesRequested()</a>.</p>

</div>
</div>
<a class="anchor" id="a17945fe59b77fdaeb7450d424fe4a7e2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Op::setOutputContext </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDD_1_1Image_1_1OutputContext.html">OutputContext</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Change what is in <a class="el" href="classDD_1_1Image_1_1Op.html#adb272858c40a05b35e6596f103377bb4">outputContext()</a>. Nuke calls this for you. Subclasses can override this, but they must call the base class with exactly the same context. This method is a convenient place to do calculations that are needed before any of the following methods work:</p><ul>
<li>int <a class="el" href="classDD_1_1Image_1_1Op.html#abef17d0f45fe7540c4893983d1b0e45e">split_input(int) const</a>;</li>
<li>float <a class="el" href="classDD_1_1Image_1_1Op.html#a814d71f7e6af7bbd10b771eb4439ee61">uses_input(int) const</a>;</li>
<li>const <a class="el" href="classDD_1_1Image_1_1OutputContext.html">OutputContext</a>&amp; <a class="el" href="classDD_1_1Image_1_1Op.html#a843a2b11746037eecfa0686fd7215cc1">inputContext(int n, int m, OutputContext&amp;) const</a>;</li>
<li>Op* defaultInput(int n, const OutputContext&amp;) const; The knob values have been stored at this point, but no inputs have been created. </li>
</ul>

<p>Reimplemented in <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#ac2b575e19d0db3d3193cd6ee4cc29515">DD::Image::NukeWrapper</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#ac2b575e19d0db3d3193cd6ee4cc29515">DD::Image::NukeWrapper::setOutputContext()</a>.</p>

</div>
</div>
<a class="anchor" id="ac3b2909bec5cfe8da41e9b7fb58764db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Op::append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDD_1_1Image_1_1Hash.html">Hash</a> &amp;&#160;</td>
          <td class="paramname"><em>hash</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculate a value for the <a class="el" href="classDD_1_1Image_1_1Op.html#a69dfe1facc10819d7dc561ae1b380d66">hash()</a>. The incoming variable is a suggested value for the hash, calculated by Nuke. This is a hash of all the <a class="el" href="classDD_1_1Image_1_1Op.html#a814d71f7e6af7bbd10b771eb4439ee61">uses_input()</a> <a class="el" href="classDD_1_1Image_1_1Op.html" title="Base class of all the things that can be created by Nuke nodes. ">Op</a> hash values and all the <a class="el" href="classDD_1_1Image_1_1Op.html#a74011be78d484b8241939c392ab9b653">knobs()</a> that don't have the NO_RERENDER flag set. A subclass can override this to modify the hash, such as to append the frame number in cases where the output image changes depending on the frame even if no controls are animated: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> MyOp::append(Hash&amp; <a class="code" href="classDD_1_1Image_1_1Op.html#a69dfe1facc10819d7dc561ae1b380d66">hash</a>) {</div>
<div class="line">this-&gt;actual_frame = <a class="code" href="DDMath_8h.html#aa6714f85bd37e61348fb2347f1233af9">clamp</a>(<span class="keywordtype">int</span>(<a class="code" href="classDD_1_1Image_1_1Op.html#adb272858c40a05b35e6596f103377bb4">outputContext</a>.frame()), first, last);</div>
<div class="line">hash.append(actual_frame);</div>
<div class="line">}</div>
</div><!-- fragment --><p> The default version does nothing. </p>

<p>Reimplemented in <a class="el" href="classDD_1_1Image_1_1Read.html#a7e26eb86dbf6438c8f036adfa8e1f2eb">DD::Image::Read</a>, and <a class="el" href="classDD_1_1Image_1_1Transform.html#aed0d7387a712ca5dbfe2924e55f1fb6b">DD::Image::Transform</a>.</p>

</div>
</div>
<a class="anchor" id="a814d71f7e6af7bbd10b771eb4439ee61"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float Op::uses_input </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return non-zero to indicate that this operator actually uses the data on the given input arrow. If this returns false then Nuke will not highlight the input arrow, and may not even construct the operator on this input (so the pointer may be null or garbage or an out-of-date version of the operator.</p>
<p>The value may be used to control how bright the arrow is, 1.0 indicates full use, 0.0 indicates none. This allows a cross-dissolve operator to fade the arrows on/off. In addition, values &lt;= .01 will appear off to the user but will still construct inputs, this is useful for operators that want to peek at the frame ranges or formats but appear to the user as though the input is unused.</p>
<p>The default version returns 1.0. </p>

<p>Reimplemented in <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#afe31faa135db3a2806ee04635a1551cf">DD::Image::NukeWrapper</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#afe31faa135db3a2806ee04635a1551cf">DD::Image::NukeWrapper::uses_input()</a>.</p>

</div>
</div>
<a class="anchor" id="abef17d0f45fe7540c4893983d1b0e45e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Op::split_input </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If this returns a number <em>m</em> greater or equal to zero, then the user-visible input <em>n</em> is split into <em>m</em> separate inputs (i.e. the number of inputs will be increased by m-1, and the next user-visible input will be at input n+m).</p>
<p>This is used to look at the input at several different frames.</p>
<p>If you override this you must also override <a class="el" href="classDD_1_1Image_1_1Op.html#a843a2b11746037eecfa0686fd7215cc1">inputContext()</a> to return different values for each of these or they will all end up hooked to the same <a class="el" href="classDD_1_1Image_1_1Op.html" title="Base class of all the things that can be created by Nuke nodes. ">Op</a>.</p>
<p>Returning -1 acts like 1 but leaves the input connected to an arbitrary frame (same as what node_input(n, ANY_CONTEXT) returns). You are expected to use an <a class="el" href="classDD_1_1Image_1_1Execute.html">Execute</a> object to switch this input to specific frames.</p>
<p>The default version returns 1. </p>

<p>Reimplemented in <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#ae5a7e9617586d986e1d237c04db415d9">DD::Image::NukeWrapper</a>, <a class="el" href="classDD_1_1Image_1_1Write.html#a6c6c6356a3a5c5c7981e4c4138f2c07f">DD::Image::Write</a>, <a class="el" href="classDD_1_1Image_1_1RenderScene.html#a85655166850bc0f321225935b1647bda">DD::Image::RenderScene</a>, and <a class="el" href="classDD_1_1Image_1_1WriteGeo.html#a60585543a375d065b9b0ee8fe4ceb670">DD::Image::WriteGeo</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Op.html#a4b531b97920ff151b4cc07bdbf6cd283">inputNumber()</a>, and <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#ae5a7e9617586d986e1d237c04db415d9">DD::Image::NukeWrapper::split_input()</a>.</p>

</div>
</div>
<a class="anchor" id="a843a2b11746037eecfa0686fd7215cc1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDD_1_1Image_1_1OutputContext.html">OutputContext</a> &amp; Op::inputContext </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDD_1_1Image_1_1OutputContext.html">OutputContext</a> &amp;&#160;</td>
          <td class="paramname"><em>scratch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the context to use for the input connected to input(n, offset). The most common thing to do is to change the frame number.</p>
<p>The default version returns <a class="el" href="classDD_1_1Image_1_1Op.html#adb272858c40a05b35e6596f103377bb4">outputContext()</a>.</p>
<p>You can use <em>scratch</em> as a space to construct the context and return it.</p>
<p>This cannot look at input <em>n</em> or above, as they have not been created yet. Often though it is useful to look at these inputs, for instance to get the frame range to make a time-reversing operator. If you want to do this you use <a class="el" href="classDD_1_1Image_1_1Op.html#ad60adcf8b3c3db91ee559210046e6d6b">node_input()</a> to generate a "likely" op. You can examine any data in it that you know will not depend on the frame number. </p>

<p>Reimplemented in <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#a358957d1f70f3b18740c00b16280f0fa">DD::Image::NukeWrapper</a>, <a class="el" href="classDD_1_1Image_1_1Write.html#ab54d30ada0b431c753a246a9abe819ac">DD::Image::Write</a>, and <a class="el" href="classDD_1_1Image_1_1RenderScene.html#a0412acaa3eb0bc7b636e25e54375afec">DD::Image::RenderScene</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Render.html#a44a52a33fa89211f7b01b763d90e22c7">DD::Image::Render::_validate()</a>, and <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#a358957d1f70f3b18740c00b16280f0fa">DD::Image::NukeWrapper::inputContext()</a>.</p>

</div>
</div>
<a class="anchor" id="a157e98d1b2073ebdfa639192add847e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDD_1_1Image_1_1OutputContext.html">OutputContext</a> * Op::inputUIContext </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDD_1_1Image_1_1OutputContext.html">OutputContext</a> &amp;&#160;</td>
          <td class="paramname"><em>scratch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the context to show the user for the input connected to user input <em>n</em>. This is used if the frame number, view, etc that you want the user to see is different than the first one you actually want. For instance a time-blending operation may want the times frame-.5 and frame+.5, but wants the user to see the frame number unchanged.</p>
<p>Typical implementation is to not mess with the frame number: </p><div class="fragment"><div class="line"><span class="keyword">const</span> OutputContext* MyOp::inputUIContext(<span class="keywordtype">int</span> n, OutputContext&amp;)<span class="keyword"> const </span>{</div>
<div class="line"><span class="keywordflow">return</span> &amp;<a class="code" href="classDD_1_1Image_1_1Op.html#adb272858c40a05b35e6596f103377bb4">outputContext</a>();</div>
<div class="line">}</div>
</div><!-- fragment --><p>The default version returns null, which is for back compatibility. If null is returned, inputContext(n,0) is used. </p>

</div>
</div>
<a class="anchor" id="a18a1ce753b5e575eadf779b78e962bfd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDD_1_1Image_1_1Op.html">Op</a> * Op::default_input </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the <a class="el" href="classDD_1_1Image_1_1Op.html" title="Base class of all the things that can be created by Nuke nodes. ">Op</a> to connect to this input if the arrow is disconnected in Nuke, or if the <a class="el" href="classDD_1_1Image_1_1Op.html" title="Base class of all the things that can be created by Nuke nodes. ">Op</a> Nuke tries fails the <a class="el" href="classDD_1_1Image_1_1Op.html#a3f1298d78336302f857270898296703d">test_input()</a> test. Making this method return a default instance of the desired <a class="el" href="classDD_1_1Image_1_1Op.html" title="Base class of all the things that can be created by Nuke nodes. ">Op</a> type will avoid having to put many checks for null inputs in your code. This can assume <a class="el" href="classDD_1_1Image_1_1Op.html#adb272858c40a05b35e6596f103377bb4">outputContext()</a> is already set.</p>
<p>The default version returns NULL, so disconnected arrows get NULL in their inputs.</p>
<p>If you implement <a class="el" href="classDD_1_1Image_1_1Op.html#abef17d0f45fe7540c4893983d1b0e45e">split_input()</a> <em>n</em> is the user-visible input number, but <a class="el" href="classDD_1_1Image_1_1Op.html#a3b26296e171162ecf103fd75827bef6e">set_input()</a> will be called with the split input number. </p>

<p>Reimplemented in <a class="el" href="classDD_1_1Image_1_1Iop.html#a6f2f504a83ec6ed4bdb8f6b8cca1490b">DD::Image::Iop</a>, <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#a0865ecf333521cf6700e8ec7d67e95be">DD::Image::NukeWrapper</a>, <a class="el" href="classDD_1_1Image_1_1GeoOp.html#a7ef4bea6a8f230fe5253d1766d881355">DD::Image::GeoOp</a>, <a class="el" href="classDD_1_1Image_1_1IllumShader.html#a32adf96e4eec3b21c9b039d589532670">DD::Image::IllumShader</a>, and <a class="el" href="classDD_1_1Image_1_1TransformGeo.html#ad29efda9c1741b6683e575a3193a6b48">DD::Image::TransformGeo</a>.</p>

</div>
</div>
<a class="anchor" id="a69dfe1facc10819d7dc561ae1b380d66"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDD_1_1Image_1_1Hash.html">Hash</a> &amp; DD::Image::Op::hash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A value which will change as the output of the operator changes. Nuke calculates this as a side-effect of constructing the tree. See <a class="el" href="classDD_1_1Image_1_1Op.html#ac3b2909bec5cfe8da41e9b7fb58764db">append(Hash&amp;)</a> for how this is calculated. </p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#a0974cdcac7134c71025d929c776e03de">DD::Image::NukeWrapper::_invalidate()</a>, <a class="el" href="classDD_1_1Image_1_1RenderScene.html#acf63b203c79c4f3570481944ec91c1de">DD::Image::RenderScene::build_handles()</a>, <a class="el" href="classDD_1_1Image_1_1ParticleBehaviour.html#a24c2bba153e58624057d3b1af5a4fa49">DD::Image::ParticleBehaviour::conditionsApply()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#a09523a2232d68d4a5f0d27059194a279">copyState()</a>, <a class="el" href="classDD_1_1Image_1_1DeepOp.html#a7e8315522d5a6d8f0d78c57b80b5f63a">DD::Image::DeepOp::deepRequest()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#a15e7072f2282bb9fced37048aaf8ae11">fetchMetaData()</a>, <a class="el" href="classDD_1_1Image_1_1SourceGeo.html#a9d447d7645ed63d51ccf106094be9cbf">DD::Image::SourceGeo::get_geometry_hash()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#a2caca27ce7fdd46a10aecf83f5eded5c">invalidate()</a>, and <a class="el" href="classDD_1_1Image_1_1Transform.html#a030b38a14c6ea86ef4b84d03a0bc9e4f">DD::Image::Transform::motionBlurSample()</a>.</p>

</div>
</div>
<a class="anchor" id="a7d50fc5cf4180e79dae181db82667a47"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool DD::Image::Op::frameTransformImplemented </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Override <a class="el" href="classDD_1_1Image_1_1Op.html#a7d50fc5cf4180e79dae181db82667a47">frameTransformImplemented()</a> to return true if the <a class="el" href="classDD_1_1Image_1_1Op.html" title="Base class of all the things that can be created by Nuke nodes. ">Op</a> implements frameTransformDownstream and frameTransformUpstream. These are used to transform the times on keyframes used for such panels as the Dope Sheet and the Curve Editor, as well as the keyframes on the Viewer timeline.</p>
<p>For example, if this node is a simple retime with a constant factor, then frameTransformDownstream should be overridden to set outFrame to the frame /produced/ given an input frame; and frameTransformUpstream should be overriden to set inFrame to the frame /required/ given an output frame.</p>
<p>For time operators that use multiple frames the 'centre' one should be preferred: this is the same one which will be return by inputUIContext (or if that isn't implemented by the <a class="el" href="classDD_1_1Image_1_1Op.html" title="Base class of all the things that can be created by Nuke nodes. ">Op</a>, then inputContext. The <a class="el" href="classDD_1_1Image_1_1OutputContext.html">OutputContext</a> is passed in so that the view and other things on it can be honoured if necessary; ignore that frame on it.</p>
<p>The downstream and upstream methods should match, so taking the result of frameTransformDownstream and feeding it into frameTransformUpstream should produce the same result. However, there are lots of exceptions to this, in particular when there is no downstream mapping the outFrame is allowed to be NAN.</p>
<p>Note that it may be more helpful to provide an extension of the mapping that is is use for the linear part than actually reflecting clipping behaviour at the end. These functions are used for display of keyframes in the user interface and not for actual processing.</p>
<p>Both transform methods also take an input index, which identifies which input is upstream along the path being taken through the DAG. This allows overrides to query upstream nodes for data required for the time transform, e.g. input clip start/length.</p>
<p>frameTransformDownstrean and frameTransformUpstream should return true if the mapping was successful, or false if no mapping was available. </p>

</div>
</div>
<a class="anchor" id="acabdc67602b50ce49f970d284b9e2305"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DopeItemFlags::Mask Op::getDopeItemFlags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Flags for influencing how the <a class="el" href="classDD_1_1Image_1_1Op.html" title="Base class of all the things that can be created by Nuke nodes. ">Op</a> should be represented in the dopesheet. Override as appropriate. </p>

</div>
</div>
<a class="anchor" id="a2f3c75489552f1d32351e270f7917675"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool DD::Image::Op::shouldHideInDopeSheet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDD_1_1Image_1_1Knob.html">Knob</a> *&#160;</td>
          <td class="paramname"><em>knob</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overrides should return true if the specified knob should be omitted in the Dope Sheet. This can be used to hide knobs such as the <a class="el" href="classDD_1_1Image_1_1Read.html">Read</a> node's 'file' knob. </p>

</div>
</div>
<a class="anchor" id="ae001b039dd47807c6a0efc4f202e99fe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classDD_1_1Image_1_1Knob.html">DD::Image::Knob</a>* DD::Image::Op::getDopeItemKnob </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Override for an <a class="el" href="classDD_1_1Image_1_1Op.html" title="Base class of all the things that can be created by Nuke nodes. ">Op</a> to specify a specific knob's keys to appear in its dope item in the DopeSheet. This is intended for use by time nodes, where the bar representing a time clip is driven by animation keys on a knob. </p>

</div>
</div>
<a class="anchor" id="af33cb4f5deaa72c22c13f5f9cdf0f8b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DD::Image::Op::requested </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if <a class="el" href="classDD_1_1Image_1_1Op.html#a3052f925ffc0c206fee2fef2092981f5">setRequested()</a> has been called since the last time forget_request() was called. This is used by <a class="el" href="classDD_1_1Image_1_1Iop.html#a5f7a57fc2339f0d84040d017e3f04b00">Iop::request()</a> style calls to see if this is the first time they were visited. </p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Iop.html#a78753f46131ea6a958f4ad5e511a6646">DD::Image::Iop::_copyState()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#aa9691f132bb2bc8cf3ed5c27e6a1ef4f">forget_request()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#a2937b3712f2ac3f405da1b4ef495116a">forgetRequestShallow()</a>, and <a class="el" href="classDD_1_1Image_1_1Iop.html#a5f7a57fc2339f0d84040d017e3f04b00">DD::Image::Iop::request()</a>.</p>

</div>
</div>
<a class="anchor" id="a3052f925ffc0c206fee2fef2092981f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DD::Image::Op::setRequested </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make <a class="el" href="classDD_1_1Image_1_1Op.html#af33cb4f5deaa72c22c13f5f9cdf0f8b9">requested()</a> return true. This is intended to be called by subclass methods such as <a class="el" href="classDD_1_1Image_1_1Iop.html#a5f7a57fc2339f0d84040d017e3f04b00">Iop::request()</a>. </p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Iop.html#a5f7a57fc2339f0d84040d017e3f04b00">DD::Image::Iop::request()</a>.</p>

</div>
</div>
<a class="anchor" id="a2937b3712f2ac3f405da1b4ef495116a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op::forgetRequestShallow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Turn off <a class="el" href="classDD_1_1Image_1_1Op.html#af33cb4f5deaa72c22c13f5f9cdf0f8b9">requested()</a> in this <a class="el" href="classDD_1_1Image_1_1Op.html" title="Base class of all the things that can be created by Nuke nodes. ">Op</a> only</p>
<p>Without this <a class="el" href="classDD_1_1Image_1_1Iop.html#a5f7a57fc2339f0d84040d017e3f04b00">Iop::request()</a> calls will accumulate their results and the <a class="el" href="classDD_1_1Image_1_1Iop.html#aa8864e1084f0c08996ef897d1e2a3312">Iop::_request()</a> virtual functions will not be called unless the request is for more channels or pixels. </p>

<p>References <a class="el" href="classDD_1_1Image_1_1Op.html#af33cb4f5deaa72c22c13f5f9cdf0f8b9">requested()</a>.</p>

</div>
</div>
<a class="anchor" id="aa9691f132bb2bc8cf3ed5c27e6a1ef4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op::forget_request </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; <a class="el" href="classDD_1_1Image_1_1Op.html">Op</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>forgotten</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recursively turn off <a class="el" href="classDD_1_1Image_1_1Op.html#af33cb4f5deaa72c22c13f5f9cdf0f8b9">requested()</a> in this <a class="el" href="classDD_1_1Image_1_1Op.html" title="Base class of all the things that can be created by Nuke nodes. ">Op</a> and all the inputs. Without this <a class="el" href="classDD_1_1Image_1_1Iop.html#a5f7a57fc2339f0d84040d017e3f04b00">Iop::request()</a> calls will accumulate their results and the <a class="el" href="classDD_1_1Image_1_1Iop.html#aa8864e1084f0c08996ef897d1e2a3312">Iop::_request()</a> virtual functions will not be called unless the request is for more channels or pixels.</p>
<p>Also see <a class="el" href="classDD_1_1Image_1_1Op.html#a59bb602b8d5e6baed304616a5c2122b0">all_forget_request()</a> which is much faster. </p>

<p>References <a class="el" href="classDD_1_1Image_1_1Op.html#a3f8fb27d42f6da712722fa73eda6b5b0">input()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#a1f2eaf5b7de5354cc5838e608cf25543">inputs()</a>, and <a class="el" href="classDD_1_1Image_1_1Op.html#af33cb4f5deaa72c22c13f5f9cdf0f8b9">requested()</a>.</p>

</div>
</div>
<a class="anchor" id="a59bb602b8d5e6baed304616a5c2122b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DD::Image::Op::all_forget_request </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Acts like forget_request() was called on every <a class="el" href="classDD_1_1Image_1_1Op.html" title="Base class of all the things that can be created by Nuke nodes. ">Op</a> in existence. This is done by incrementing a static variable and is thus a much faster method. </p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1ToBuffer.html#a4b6e8a0328d1f5f9a9242386ade6732a">DD::Image::ToBuffer::to_buffer()</a>.</p>

</div>
</div>
<a class="anchor" id="aa1533af7ee9d451c0661ce2754d00877"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * Op::node_shape </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return what shape Nuke should draw the box in the DAG window. This is a string where the characters approximately show what shapes the ends of the box are. The default return value is "[]" (or "\)" for DeepOps);</p>
<p>Other possible characters are &lt; &gt; ( ) r c p b { } / \ and ! </p>

<p>Reimplemented in <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#a76171834960a1fcf4b8679b304412a99">DD::Image::NukeWrapper</a>, <a class="el" href="classDD_1_1Image_1_1GeoOp.html#a5598ee3f327f0b4792c09d5805b88c09">DD::Image::GeoOp</a>, and <a class="el" href="classDD_1_1Image_1_1Material.html#a27533897dcd17e2ea123fd51d79dfb20">DD::Image::Material</a>.</p>

<p>References <a class="el" href="classDD_1_1Image_1_1DeepOp.html#a5254235d934a4f8fcfe45b5cbc86375d">DD::Image::DeepOp::DeepNodeShape()</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#a76171834960a1fcf4b8679b304412a99">DD::Image::NukeWrapper::node_shape()</a>.</p>

</div>
</div>
<a class="anchor" id="a1302934ae109973f546ace0c05ea1ed2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Op::node_color </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the default color for the Node in the Nuke DAG window. The value is 0xRRGGBBAA. The AA byte is ignored right now. Returning 0 indicates that you want the fall-back color set in the user's preferences to be used. If you really want to return black, return 0xff. </p>

<p>Reimplemented in <a class="el" href="classDD_1_1Image_1_1Transform.html#a383537bc7fbc7aa606a0dcc15efc9f2b">DD::Image::Transform</a>, <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#a0bce169583a65e767535968f84fae297">DD::Image::NukeWrapper</a>, and <a class="el" href="classDD_1_1Image_1_1Material.html#a734bc564d62718cf90bbe2a5a6d1b785">DD::Image::Material</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#a0bce169583a65e767535968f84fae297">DD::Image::NukeWrapper::node_color()</a>.</p>

</div>
</div>
<a class="anchor" id="a7d9f3157dced5cc944383f7bde273787"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * Op::node_help </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return help information for this node. This information is in the pop-up window that the user gets when they hit the [?] button in the lower-left corner of the control panel.</p>
<p>The first character should not be a punctuation mark, they are all reserved for future use. </p>

<p>Implemented in <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#a7ab873fda478ecb9d5871cd49e950a92">DD::Image::NukeWrapper</a>, and <a class="el" href="classDD_1_1Image_1_1LightOp.html#a28057d4dfb34bb53ac3decfa59a9cb42">DD::Image::LightOp</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#a7ab873fda478ecb9d5871cd49e950a92">DD::Image::NukeWrapper::node_help()</a>.</p>

</div>
</div>
<a class="anchor" id="a2a213156968fa2fc9bbe92f40e059ea3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * Op::input_label </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the text Nuke should draw on the arrow head for input <em>i</em> in the DAG window. This should be a very short string, one letter ideally. If you want you can print into the passed buffer and return a pointer to that, the buffer is very short (20 characters). Return null or an empty string to not label the arrow.</p>
<p>The default version checks <a class="el" href="classDD_1_1Image_1_1Op.html#a7a9392b9827e2f79f2bac7d3317b4065">maximum_inputs()</a>. It leaves 1-input nodes blank. 2-input nodes are labeled B and A. Higher numbers of inputs get their index number + 1 as a label. </p>

<p>Reimplemented in <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#ae7b67193e4b4a8db1366898faa7c362d">DD::Image::NukeWrapper</a>, and <a class="el" href="classDD_1_1Image_1_1IllumShader.html#a86ffbfaa48047921f2e17d1c6b8d501a">DD::Image::IllumShader</a>.</p>

<p>References <a class="el" href="classDD_1_1Image_1_1Op.html#a7a9392b9827e2f79f2bac7d3317b4065">maximum_inputs()</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#ae7b67193e4b4a8db1366898faa7c362d">DD::Image::NukeWrapper::input_label()</a>.</p>

</div>
</div>
<a class="anchor" id="a5c86d87e39b6e09733942f239ec98e61"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Op::input_longlabel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a longer string describing an input. This is used when there is more room to format the string into, such as a tooltip. If an empty string is returned then <a class="el" href="classDD_1_1Image_1_1Op.html#a2a213156968fa2fc9bbe92f40e059ea3">input_label()</a> is used. </p>

</div>
</div>
<a class="anchor" id="aa3a29ea27d511f7074d053df864c5195"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DD::Image::Op::node_redraw </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An operator should call this if it does anything to change it's color(), shape(), or label(), this tells Nuke to update the DAG display. If this operator has a <a class="el" href="classDD_1_1Image_1_1Op.html#a0d4340b2a813327a249698c0dee107bb">parent()</a> this does nothing. </p>

</div>
</div>
<a class="anchor" id="a6ae750a8ab437bef1c4d9996932c661b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DD::Image::Op::print_name </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prints the name of the <a class="el" href="classDD_1_1Image_1_1Op.html" title="Base class of all the things that can be created by Nuke nodes. ">Op</a>, for use in error or warning messages. </p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1ComplexLightOp.html#a8a2e010dcb839688632ad8893b10a1c6">DD::Image::ComplexLightOp::draw_handle()</a>, <a class="el" href="classDD_1_1Image_1_1CameraOp.html#a8c4002730a75e3c05618459917268307">DD::Image::CameraOp::draw_handle()</a>, <a class="el" href="classDD_1_1Image_1_1AxisOp.html#ac45085bd760fed42cde18b60eedb8c09">DD::Image::AxisOp::draw_handle()</a>, <a class="el" href="classDD_1_1Image_1_1LightOp.html#a540b22a17b692092402465dc9538cbc5">DD::Image::LightOp::draw_handle()</a>, <a class="el" href="classDD_1_1Image_1_1Iop.html#ab1903d94f8e04ca446968ba731b074bb">DD::Image::Iop::get()</a>, <a class="el" href="namespaceDD_1_1Image.html#a5b01bd15dbdeff52e8474a0154cf3238">DD::Image::GetOpText()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#a9d842d7fddc50c14c62d858834a19567">node_name()</a>, and <a class="el" href="classDD_1_1Image_1_1Iop.html#a5f7a57fc2339f0d84040d017e3f04b00">DD::Image::Iop::request()</a>.</p>

</div>
</div>
<a class="anchor" id="aeae75f67ceb4736a1c5a61ce8634641c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDD_1_1Image_1_1Op.html#ab7e6c22841d12d4b8f4e908b066bfe6a">Op::NodeContext</a> Op::nodeContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>return the node context for this op </p>

<p>References <a class="el" href="classDD_1_1Image_1_1Op.html#a1e65ba0209479090ca51fc3d0b60e8ea">node()</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#a97d2f933e4ae12f47d4b32df6d33bbed">DD::Image::NukeWrapper::_validate()</a>, <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#a5952ee7ac93232be46555d08acfad1c0">DD::Image::NukeWrapper::knobs()</a>, and <a class="el" href="classDD_1_1Image_1_1FileReader.html#a89b8a8836677e9dc5ec7fcc09501d4c9">DD::Image::FileReader::readAllLinesRequested()</a>.</p>

</div>
</div>
<a class="anchor" id="a9d842d7fddc50c14c62d858834a19567"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Op::node_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the same string as printed by print_name(ostream). </p>

<p>References <a class="el" href="classDD_1_1Image_1_1Op.html#a6ae750a8ab437bef1c4d9996932c661b">print_name()</a>.</p>

</div>
</div>
<a class="anchor" id="a7cd4f2bebb93a913641767f6435374ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op::invalidateSameHash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make sure the next call to <a class="el" href="classDD_1_1Image_1_1Op.html#a54fe7079e0236ae45b247dd9f5e300b4">validate()</a> calls <a class="el" href="classDD_1_1Image_1_1Op.html#ae1dc586d97dd3e752bd3573bb7665b84">_validate()</a>, by turning off the <a class="el" href="classDD_1_1Image_1_1Op.html#a353707a4e92ff1f1b5073550ef379a05" title="Returns true if it has been validated - including if there was an error. ">valid()</a> flag, and calling <a class="el" href="classDD_1_1Image_1_1Op.html#ad18224f6cf7702991dd646addee0fbe5">_invalidate()</a>.</p>
<p>This is a very fast function if <a class="el" href="classDD_1_1Image_1_1Op.html#a353707a4e92ff1f1b5073550ef379a05" title="Returns true if it has been validated - including if there was an error. ">valid()</a> is false so you can call it many times. </p>

<p>References <a class="el" href="classDD_1_1Image_1_1Op.html#ad18224f6cf7702991dd646addee0fbe5">_invalidate()</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#a0974cdcac7134c71025d929c776e03de">DD::Image::NukeWrapper::_invalidate()</a>, and <a class="el" href="classDD_1_1Image_1_1Op.html#ad19589f141ad102c40fab9c26a87c5c8">invalidate()</a>.</p>

</div>
</div>
<a class="anchor" id="ad19589f141ad102c40fab9c26a87c5c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Op::invalidate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If <a class="el" href="classDD_1_1Image_1_1Op.html#a353707a4e92ff1f1b5073550ef379a05" title="Returns true if it has been validated - including if there was an error. ">valid()</a>, change the <a class="el" href="classDD_1_1Image_1_1Op.html#a69dfe1facc10819d7dc561ae1b380d66">hash()</a> to a random number and call <a class="el" href="classDD_1_1Image_1_1Op.html#a7cd4f2bebb93a913641767f6435374ba">invalidateSameHash()</a>. Since the hash is different, output operators that check it to see if the image has changed will think it has changed. Returns true if it was <a class="el" href="classDD_1_1Image_1_1Op.html#a353707a4e92ff1f1b5073550ef379a05" title="Returns true if it has been validated - including if there was an error. ">valid()</a>.</p>
<p>Don't use this on <a class="el" href="classDD_1_1Image_1_1Op.html" title="Base class of all the things that can be created by Nuke nodes. ">Op</a> instances produced by Nuke as it will mess up the <a class="el" href="classDD_1_1Image_1_1Op.html#a69dfe1facc10819d7dc561ae1b380d66">hash()</a> value which Nuke relies on not changing. Plugins can use this on internal <a class="el" href="classDD_1_1Image_1_1Op.html" title="Base class of all the things that can be created by Nuke nodes. ">Op</a> instances, and other programs using DDImage can use this.</p>
<p>If you just want to force <a class="el" href="classDD_1_1Image_1_1Op.html#ae1dc586d97dd3e752bd3573bb7665b84">_validate()</a> to get called, use <a class="el" href="classDD_1_1Image_1_1Op.html#a7cd4f2bebb93a913641767f6435374ba">invalidateSameHash()</a>. </p>

<p>References <a class="el" href="classDD_1_1Image_1_1Op.html#a7cd4f2bebb93a913641767f6435374ba">invalidateSameHash()</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#a0974cdcac7134c71025d929c776e03de">DD::Image::NukeWrapper::_invalidate()</a>, <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#a97d2f933e4ae12f47d4b32df6d33bbed">DD::Image::NukeWrapper::_validate()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#a09523a2232d68d4a5f0d27059194a279">copyState()</a>, <a class="el" href="classDD_1_1Image_1_1Scene.html#ad825a571c92d0611e08af922eb19e3f4">DD::Image::Scene::evaluate_lights()</a>, <a class="el" href="classDD_1_1Image_1_1GeoOp.html#ae6bdd2fb36e3c25bba2f003f69a0c6d8">DD::Image::GeoOp::knob_changed()</a>, and <a class="el" href="classDD_1_1Image_1_1InternalOCIOOp.html#a21088fe01d89152aa6dff96c18b30709">DD::Image::InternalOCIOOp::validate()</a>.</p>

</div>
</div>
<a class="anchor" id="a2caca27ce7fdd46a10aecf83f5eded5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Op::invalidate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDD_1_1Image_1_1Hash.html">Hash</a> &amp;&#160;</td>
          <td class="paramname"><em>hash</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if the hash is different, in which case it changes <a class="el" href="classDD_1_1Image_1_1Op.html#a69dfe1facc10819d7dc561ae1b380d66">hash()</a> to this new value, and calls <a class="el" href="classDD_1_1Image_1_1Op.html#a7cd4f2bebb93a913641767f6435374ba">invalidateSameHash()</a>. Returns true if the hash is different. </p>

<p>References <a class="el" href="classDD_1_1Image_1_1Op.html#ad630933fdc66c9429480c7dae10cb09e">_haveHash</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#a69dfe1facc10819d7dc561ae1b380d66">hash()</a>, and <a class="el" href="classDD_1_1Image_1_1Op.html#a7cd4f2bebb93a913641767f6435374ba">invalidateSameHash()</a>.</p>

</div>
</div>
<a class="anchor" id="a55bc746ee3e202be40a7ee047f7ee34c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Op::update </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDD_1_1Image_1_1Box.html">Box</a> *&#160;</td>
          <td class="paramname"><em>box</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Obsolete function, calls asapUpdate(*box) or <a class="el" href="classDD_1_1Image_1_1Op.html#a1e77c16a84a6a5b4d2187636f320377b">asapUpdate()</a> if box is NULL, returns true. </p>

</div>
</div>
<a class="anchor" id="a1e77c16a84a6a5b4d2187636f320377b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op::asapUpdate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicate that the output of this <a class="el" href="classDD_1_1Image_1_1Op.html" title="Base class of all the things that can be created by Nuke nodes. ">Op</a> has changed. This may be called by a parallel thread, such as a socket listener, or other connection to an outside image source. The Nuke viewer will redraw with the new image.</p>
<p>Currently you <em>must</em> also implement <a class="el" href="classDD_1_1Image_1_1Op.html#ac3b2909bec5cfe8da41e9b7fb58764db">append(Hash&amp;)</a> and make it modify the hash. The easiest way is to increment a counter when you call this and add call hash.append(counter) in that function. The viewer will not update if the hash does not change.</p>
<p>This disables disk caching by the viewer, on the assumption that the resulting image will only be seen once.</p>
<p>Return value from Nuke is currently always true. </p>

</div>
</div>
<a class="anchor" id="a6fb012ce54b0d105e14ac44b6df42b7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op::asapUpdate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDD_1_1Image_1_1Box.html">Box</a> &amp;&#160;</td>
          <td class="paramname"><em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>direction</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="classDD_1_1Image_1_1Op.html#a1e77c16a84a6a5b4d2187636f320377b">asapUpdate()</a> but the box indicates an area that you want the viewer to draw first. This area must be in viewer coordinates (including the current proxy settings). This is used by paint strokes.</p>
<p>The optional <em>direction</em> indicates which direction to draw the box. Positive draws from bottom to top, negative from top to bottom. Zero indicates you don't care. </p>

</div>
</div>
<a class="anchor" id="a54fe7079e0236ae45b247dd9f5e300b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op::validate </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>for_real</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Turns on <a class="el" href="classDD_1_1Image_1_1Op.html#a353707a4e92ff1f1b5073550ef379a05" title="Returns true if it has been validated - including if there was an error. ">valid()</a>, and if <em>for_real</em> is true, turns on <a class="el" href="classDD_1_1Image_1_1Op.html#aaa7621a25cd7093ca3b4ed32cbabe525" title="Returns true if it has been real-validated - including if there was an error. ">real_valid()</a>. This returns immediately if these flags are already on.</p>
<p>When this returns, info() has been filled in with information about the output image. If <em>for_real</em> is false this is a quick "simulation" used by Nuke. If <em>for_real</em> is true this is a more accurate version that incorporates the actual information that is read from input files, and can take considerably longer.</p>
<p>If this has ever called <a class="el" href="classDD_1_1Image_1_1Op.html#afc3f4acb738937d3319707849fe1b26f">error()</a> since the last time <a class="el" href="classDD_1_1Image_1_1Op.html#ad19589f141ad102c40fab9c26a87c5c8">invalidate()</a> was called, this will immediately report the same error message, turn on <a class="el" href="classDD_1_1Image_1_1Op.html#ad2bc52a1cf2100f5e21446af388e1afb" title="Abort all trees the op is in. ">abort()</a>, and return. You must test for this after calling <a class="el" href="classDD_1_1Image_1_1Op.html#a2bb868632c6116e335c689d78b18ba7a">open()</a> (this need for a test will go away when we fix it to use exceptions). </p>

<p>References <a class="el" href="classDD_1_1Image_1_1Op.html#ae745e59a2aacee53458f598174fc4b9c">force_validate()</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1UpRez.html#abbe9a88ababa5bf013010adeaeb4a3d2">DD::Image::UpRez::_validate()</a>, <a class="el" href="classDD_1_1Image_1_1AxisOp.html#a3f2acda6bca5938a31cfb21faeff96a2">DD::Image::AxisOp::_validate()</a>, <a class="el" href="classDD_1_1Image_1_1TransformGeo.html#ac7d45ec8dbbf9ab270d26cc2e3b8b02f">DD::Image::TransformGeo::_validate()</a>, <a class="el" href="classDD_1_1Image_1_1IllumShader.html#a35420055167b8c9fb02476c4fd2bd80e">DD::Image::IllumShader::_validate()</a>, <a class="el" href="classDD_1_1Image_1_1DrawIop.html#af9ef29ef2bc4a6c56c9df5925a6acfe7">DD::Image::DrawIop::_validate()</a>, <a class="el" href="classDD_1_1Image_1_1Transform.html#ad9b86ff52be5808cff50304f4344c176">DD::Image::Transform::_validate()</a>, <a class="el" href="classDD_1_1Image_1_1ReadGeo.html#aef6bfba04a696b14fcbae079755b6924">DD::Image::ReadGeo::_validate()</a>, <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#a97d2f933e4ae12f47d4b32df6d33bbed">DD::Image::NukeWrapper::_validate()</a>, <a class="el" href="classDD_1_1Image_1_1Write.html#a24b3332f92388c30a53211b413c4a885">DD::Image::Write::_validate()</a>, <a class="el" href="classDD_1_1Image_1_1Render.html#a44a52a33fa89211f7b01b763d90e22c7">DD::Image::Render::_validate()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#ae1dc586d97dd3e752bd3573bb7665b84">_validate()</a>, <a class="el" href="classDD_1_1Image_1_1Transform.html#aed0d7387a712ca5dbfe2924e55f1fb6b">DD::Image::Transform::append()</a>, <a class="el" href="classDD_1_1Image_1_1TransformGeo.html#afa6576a607819ccbf51882a884a4e1f6">DD::Image::TransformGeo::build_handles()</a>, <a class="el" href="classDD_1_1Image_1_1Transform.html#a89239e1d50e3f24f7d7a3fba00a3dbbe">DD::Image::Transform::build_handles()</a>, <a class="el" href="classDD_1_1Image_1_1AxisOp.html#a368a8c3f618a2cb06ec4c8d0fccaa73a">DD::Image::AxisOp::build_handles()</a>, <a class="el" href="classDD_1_1Image_1_1Render.html#aa402d3d515ee9ccd074ec44dfdb39c6b">DD::Image::Render::build_handles()</a>, <a class="el" href="classDD_1_1Image_1_1GeoOp.html#ac4d98ee7c3b175b08fab14ee83b50549">DD::Image::GeoOp::build_matrix_handles()</a>, <a class="el" href="classDD_1_1Image_1_1Iop.html#a7f4acc5d9cda6f4fca94e71e6ed1ff78">DD::Image::Iop::copy_info()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#a09523a2232d68d4a5f0d27059194a279">copyState()</a>, <a class="el" href="classDD_1_1Image_1_1Scene.html#ad825a571c92d0611e08af922eb19e3f4">DD::Image::Scene::evaluate_lights()</a>, <a class="el" href="classDD_1_1Image_1_1Write.html#ae76f84680bb2d23603e7bc3b32ef0de5">DD::Image::Write::execute()</a>, <a class="el" href="classDD_1_1Image_1_1GeoOp.html#a17753ecca2ed2a766efd0d17f0635912">DD::Image::GeoOp::get_geometry_hash()</a>, <a class="el" href="classDD_1_1Image_1_1Transform.html#a1131cfc5fd81215ebf0574c192193a3e">DD::Image::Transform::matrixAt()</a>, <a class="el" href="classDD_1_1Image_1_1Iop.html#aff7644f25c5a00b95bd7bbf1c33ecd9e">DD::Image::Iop::merge_info()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#a2bb868632c6116e335c689d78b18ba7a">open()</a>, <a class="el" href="classDD_1_1Image_1_1RenderScene.html#a2b0c59f4f37482a24984916ef5084d47">DD::Image::RenderScene::render_camera()</a>, <a class="el" href="classDD_1_1Image_1_1Iop.html#aaf9107a6e181c98a7fb142c4564a8712">DD::Image::Iop::request()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#ab007448be5c7c917810e59515c209718">tryValidate()</a>, <a class="el" href="classDD_1_1Image_1_1InternalOCIOOp.html#a21088fe01d89152aa6dff96c18b30709">DD::Image::InternalOCIOOp::validate()</a>, and <a class="el" href="classDD_1_1Image_1_1Scene.html#a17c761ac5b382f3dfa243bbd9ae998fc">DD::Image::Scene::validate()</a>.</p>

</div>
</div>
<a class="anchor" id="ae745e59a2aacee53458f598174fc4b9c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Op::force_validate </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>for_real</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Acts as though <a class="el" href="classDD_1_1Image_1_1Op.html#a353707a4e92ff1f1b5073550ef379a05" title="Returns true if it has been validated - including if there was an error. ">valid()</a> is off and does <a class="el" href="classDD_1_1Image_1_1Op.html#a54fe7079e0236ae45b247dd9f5e300b4">validate()</a>. Thus you can be certain that <a class="el" href="classDD_1_1Image_1_1Op.html#ae1dc586d97dd3e752bd3573bb7665b84">_validate()</a> is called. </p>

<p>Reimplemented in <a class="el" href="classDD_1_1Image_1_1Iop.html#a0d95f2d8257ac82a6bcae96b7aa308db">DD::Image::Iop</a>, and <a class="el" href="classDD_1_1Image_1_1MultiTileIop.html#a3500dcd2c77294aa200ff10d816c5a48">DD::Image::MultiTileIop</a>.</p>

<p>References <a class="el" href="classDD_1_1Image_1_1Op.html#ae1dc586d97dd3e752bd3573bb7665b84">_validate()</a>, and <a class="el" href="classDD_1_1Image_1_1OpMessageHandler.html#a463a93b12015f32e00a22b3475c99852">DD::Image::OpMessageHandler::markMessagesAsOld()</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Iop.html#a0d95f2d8257ac82a6bcae96b7aa308db">DD::Image::Iop::force_validate()</a>, and <a class="el" href="classDD_1_1Image_1_1Op.html#a54fe7079e0236ae45b247dd9f5e300b4">validate()</a>.</p>

</div>
</div>
<a class="anchor" id="a353707a4e92ff1f1b5073550ef379a05"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DD::Image::Op::valid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if it has been validated - including if there was an error. </p>
<p>Returns true after validate(false) or validate(true) has been called. You should not use the data in info() for anything if this is false. Instead call <a class="el" href="classDD_1_1Image_1_1Op.html#a353707a4e92ff1f1b5073550ef379a05" title="Returns true if it has been validated - including if there was an error. ">valid()</a> first. </p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Iop.html#a5de9bcbbaebb959b498bf9baf66075d1">DD::Image::Iop::_close()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#a09523a2232d68d4a5f0d27059194a279">copyState()</a>, and <a class="el" href="classDD_1_1Image_1_1Write.html#ae76f84680bb2d23603e7bc3b32ef0de5">DD::Image::Write::execute()</a>.</p>

</div>
</div>
<a class="anchor" id="aaa7621a25cd7093ca3b4ed32cbabe525"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DD::Image::Op::real_valid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if it has been real-validated - including if there was an error. </p>
<p>Returns true after validate(true) has been called. This means the data in info() is truly correct and tested against slow things like opening files. This is used by Nuke, normal programs that never call validate(false) will not need to use this and can use <a class="el" href="classDD_1_1Image_1_1Op.html#a353707a4e92ff1f1b5073550ef379a05" title="Returns true if it has been validated - including if there was an error. ">valid()</a>. </p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Iop.html#a7f4acc5d9cda6f4fca94e71e6ed1ff78">DD::Image::Iop::copy_info()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#a09523a2232d68d4a5f0d27059194a279">copyState()</a>, <a class="el" href="classDD_1_1Image_1_1Iop.html#aff7644f25c5a00b95bd7bbf1c33ecd9e">DD::Image::Iop::merge_info()</a>, and <a class="el" href="classDD_1_1Image_1_1Iop.html#aaf9107a6e181c98a7fb142c4564a8712">DD::Image::Iop::request()</a>.</p>

</div>
</div>
<a class="anchor" id="a8d52d583d589b5acb5fd18bb38349a20"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DD::Image::Op::opened </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true after <a class="el" href="classDD_1_1Image_1_1Op.html#a2bb868632c6116e335c689d78b18ba7a">open()</a> has been called. Returns false after <a class="el" href="classDD_1_1Image_1_1Op.html#ad19589f141ad102c40fab9c26a87c5c8">invalidate()</a> or <a class="el" href="classDD_1_1Image_1_1Op.html#a009bdb3fc6cf7b4f33134c71585f2f4a">close()</a> has been called. This indicates that the operator is ready to have data extracted from it (by the engine() call in the case of an <a class="el" href="classDD_1_1Image_1_1Iop.html" title="Iop is the base class for all the image operators. ">Iop</a>). Normally this is turned on by operators calling <a class="el" href="classDD_1_1Image_1_1Op.html#a2bb868632c6116e335c689d78b18ba7a">open()</a> on themselves on the first call to get data. </p>

</div>
</div>
<a class="anchor" id="a2bb868632c6116e335c689d78b18ba7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op::open </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the operator ready for producing data. Normally this is called by operator implementations on the first call to get some data from it. The main thing this does is call <a class="el" href="classDD_1_1Image_1_1Op.html#a019d714de0d947176450c68df0f6f9e6">_open()</a> if it has not been called since the last <a class="el" href="classDD_1_1Image_1_1Op.html#ad19589f141ad102c40fab9c26a87c5c8">invalidate()</a>.</p>
<p>If this has ever called <a class="el" href="classDD_1_1Image_1_1Op.html#afc3f4acb738937d3319707849fe1b26f">error()</a> since the last time <a class="el" href="classDD_1_1Image_1_1Op.html#ad19589f141ad102c40fab9c26a87c5c8">invalidate()</a> was called, this will immediately report the same error message, turn on <a class="el" href="classDD_1_1Image_1_1Op.html#ad2bc52a1cf2100f5e21446af388e1afb" title="Abort all trees the op is in. ">abort()</a>, and return. You must test for this after calling <a class="el" href="classDD_1_1Image_1_1Op.html#a2bb868632c6116e335c689d78b18ba7a">open()</a> (this need for a test will go away when we fix it to use exceptions). </p>

<p>References <a class="el" href="classDD_1_1Image_1_1Op.html#a019d714de0d947176450c68df0f6f9e6">_open()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#ad2bc52a1cf2100f5e21446af388e1afb">abort()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#af31a7c1b2fd23639d56c4e6a11c362d9">aborted()</a>, and <a class="el" href="classDD_1_1Image_1_1Op.html#a54fe7079e0236ae45b247dd9f5e300b4">validate()</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#a4a9ebc9787a0b7c593c550a379fb5eee">DD::Image::NukeWrapper::_open()</a>, <a class="el" href="classDD_1_1Image_1_1DeepOp.html#a4a53ae63b51fdc097f314bd2108144bd">DD::Image::DeepOp::deepEngine()</a>, and <a class="el" href="classDD_1_1Image_1_1Iop.html#a688b41adc3963e0de631fb6533c219c9">DD::Image::Iop::fetchPlane()</a>.</p>

</div>
</div>
<a class="anchor" id="ad1c254a46d65cbf9a15b3ffb76d20626"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DD::Image::Op::running </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if engine() is currently executing. This is used to highlight the busy operators in Nuke. It is not very accurate (because multiple threads may turn it off) so don't use this for anything other than user feedback. </p>

</div>
</div>
<a class="anchor" id="adc30fd36bf5527f2c49a259e57340fed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DD::Image::Op::running </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Turn the running highlight in the Nuke display on/off. You should do this around any code that extracts data. This is very fast (much faster than calling <a class="el" href="classDD_1_1Image_1_1Op.html#aa3a29ea27d511f7074d053df864c5195">node_redraw()</a>), it just sets/clears a local flag. Nuke works by running a parallel thread that wakes several times a second to see if the highlight changed and redraw the DAG display with the current highlighting. </p>

</div>
</div>
<a class="anchor" id="a2140a1fbd44b54e7b127516890f1de05"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DD::Image::Op::not_closed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true after <a class="el" href="classDD_1_1Image_1_1Op.html#a2bb868632c6116e335c689d78b18ba7a">open()</a> has been called. Returns false after <a class="el" href="classDD_1_1Image_1_1Op.html#a009bdb3fc6cf7b4f33134c71585f2f4a">close()</a> has been called. <a class="el" href="classDD_1_1Image_1_1Op.html#ad19589f141ad102c40fab9c26a87c5c8">invalidate()</a> does not turn this off, this is an indicator that the <a class="el" href="classDD_1_1Image_1_1Op.html" title="Base class of all the things that can be created by Nuke nodes. ">Op</a> may have resources allocated that could be freed. </p>

</div>
</div>
<a class="anchor" id="a009bdb3fc6cf7b4f33134c71585f2f4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tell the <a class="el" href="classDD_1_1Image_1_1Op.html" title="Base class of all the things that can be created by Nuke nodes. ">Op</a> to free all recreatable data, on the assumption that this operator will not be used again soon. This calls <a class="el" href="classDD_1_1Image_1_1Op.html#a99957cf4eabecb46ddfb5497766ccca6">_close()</a> and also turns off flags so it knows that <a class="el" href="classDD_1_1Image_1_1Op.html#a019d714de0d947176450c68df0f6f9e6">_open()</a> must be called again. </p>

<p>References <a class="el" href="classDD_1_1Image_1_1Op.html#a99957cf4eabecb46ddfb5497766ccca6">_close()</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#a5de626196f56b88693fcb56a440c11ea">DD::Image::NukeWrapper::_close()</a>, and <a class="el" href="classDD_1_1Image_1_1Op.html#ac5a3799eeee2ba718507d2be641fd59f">callPendingClose()</a>.</p>

</div>
</div>
<a class="anchor" id="a2f6445522b9e247d90a14a093491e17e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op::callCloseAfter </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>seconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicate that <a class="el" href="classDD_1_1Image_1_1Op.html#a009bdb3fc6cf7b4f33134c71585f2f4a">close()</a> (and thus <a class="el" href="classDD_1_1Image_1_1Op.html#a99957cf4eabecb46ddfb5497766ccca6">_close()</a>) should be called after the given number of seconds of idle. Passing zero is useful to get <a class="el" href="classDD_1_1Image_1_1Op.html#a009bdb3fc6cf7b4f33134c71585f2f4a">close()</a> called as soon as the viewer stops updating.</p>
<p>This is a one-shot timeout, the entry is removed after <a class="el" href="classDD_1_1Image_1_1Op.html#a009bdb3fc6cf7b4f33134c71585f2f4a">close()</a> is called. Call this again if you want to be called again. Only the last call is used, it replaces any previous timeout whether larger or smaller, so calling this with INFINITY will disable the callback. </p>

</div>
</div>
<a class="anchor" id="ac5a3799eeee2ba718507d2be641fd59f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Op::callPendingClose </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>seconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Call <a class="el" href="classDD_1_1Image_1_1Op.html#a009bdb3fc6cf7b4f33134c71585f2f4a">close()</a> on some (currently only zero or one) Ops that asked for it to be called with a time less or equal to <em>seconds</em>. Return with the smallest time of any remaining callCloseAfter calls, or INFINITY if none. You should loop until this returns INFINITY (or perhaps some very large number). </p>

<p>References <a class="el" href="classDD_1_1Image_1_1Op.html#a009bdb3fc6cf7b4f33134c71585f2f4a">close()</a>.</p>

</div>
</div>
<a class="anchor" id="a5f532639c9ff313225611a4935affe64"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Op::clearPendingClose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For use by Nuke, do not use </p>

</div>
</div>
<a class="anchor" id="a09523a2232d68d4a5f0d27059194a279"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op::copyState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDD_1_1Image_1_1Op.html">Op</a> *&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is called when Nuke inserts no-op operators such as postagestamps. Change the op's valid and request state to match exactly the input, and possibly move the cache from the input to here. The hash is copied because this must be a no-op. </p>

<p>References <a class="el" href="classDD_1_1Image_1_1Iop.html#a78753f46131ea6a958f4ad5e511a6646">DD::Image::Iop::_copyState()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#a69dfe1facc10819d7dc561ae1b380d66">hash()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#ad19589f141ad102c40fab9c26a87c5c8">invalidate()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#a24e0d3db1f380929ed86e4a0a5913c1d">iop()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#aaa7621a25cd7093ca3b4ed32cbabe525">real_valid()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#a353707a4e92ff1f1b5073550ef379a05">valid()</a>, and <a class="el" href="classDD_1_1Image_1_1Op.html#a54fe7079e0236ae45b247dd9f5e300b4">validate()</a>.</p>

</div>
</div>
<a class="anchor" id="a9af1b269af5f2a30e9d72d6001509775"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DD::Image::Op::cached </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Indicates that caching of the output data is requested, so that asking for it again will be faster. Whether or not this does anything depends on the subclass of <a class="el" href="classDD_1_1Image_1_1Op.html" title="Base class of all the things that can be created by Nuke nodes. ">Op</a>, but <a class="el" href="classDD_1_1Image_1_1Iop.html" title="Iop is the base class for all the image operators. ">Iop</a> uses this. </p>

</div>
</div>
<a class="anchor" id="afd5eaba4391ab6908a8f06b4a466a103"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classDD_1_1Image_1_1Executable.html">Executable</a>* DD::Image::Op::executable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return pointer to this object as an <a class="el" href="classDD_1_1Image_1_1Executable.html" title="Class to wrap up node graph execution. ">Executable</a> if you want Nuke to call execute() on this node when the user hits render.</p>
<p><em>Don't implement this if you just want to have a button the user presses to execute the node.</em> The tcl "execute" command will still work and you can make a script_knob that calls it.</p>
<p>The default version returns nil. </p>

</div>
</div>
<a class="anchor" id="ab886234f0358b0898f17ad52c8a27b3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op::setKnobsToContext </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDD_1_1Image_1_1OutputContext.html">OutputContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the knobs to reflect the values at a different frame (or other piece of context information), and call invalidate if they are different. This can be used to determine the <a class="el" href="classDD_1_1Image_1_1Op.html" title="Base class of all the things that can be created by Nuke nodes. ">Op</a>'s animation. Make sure the knobs are set back by calling this with <a class="el" href="classDD_1_1Image_1_1Op.html#adb272858c40a05b35e6596f103377bb4">outputContext()</a> when done. </p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Transform.html#a1131cfc5fd81215ebf0574c192193a3e">DD::Image::Transform::matrixAt()</a>.</p>

</div>
</div>
<a class="anchor" id="a268210647796fd4cc9251ae3317e469f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op::gotoContext </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDD_1_1Image_1_1OutputContext.html">OutputContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>update</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change Nuke to reflect a different frame number (and perhaps other aspects of the context), and change this op and its entire input tree to reflect this context. If <em>update</em> is true then it will also pause until the entire user interface is updated with the new frame.</p>
<p>You will have to call <a class="el" href="classDD_1_1Image_1_1Op.html#a54fe7079e0236ae45b247dd9f5e300b4">validate()</a> on the inputs before using them.</p>
<p>This should only be called due to UI actions such as <a class="el" href="classDD_1_1Image_1_1Op.html#aac5d7e37ec7090d95e064575e648ae40">knob_changed()</a>. </p>

</div>
</div>
<a class="anchor" id="a178abeee0e49785e55d1a08033e9f313"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op::progressFraction </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fraction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDD_1_1Image_1_1Op.html#ad05eb8420166eff8fabdb30b8fe9c13c">StatusFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code>StatusNone</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the location of the progress bar. <em>fraction</em> should be between 0 and 1. If this is not called the fraction is zero. flags can control the behaviour of progress updates, see StatusFlags enum. Only StatusUseCallback affects <a class="el" href="classDD_1_1Image_1_1Op.html#a178abeee0e49785e55d1a08033e9f313">progressFraction()</a>. </p>

<p>References <a class="el" href="classDD_1_1Image_1_1Op.html#a84d331e6b34badaa5f9678dd6df6917b">status_callback</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Writer.html#a645d5f4f2a3ebf001c64386e3058e871">DD::Image::Writer::progressFraction()</a>, and <a class="el" href="classDD_1_1Image_1_1GeoWriter.html#af14937e56742630d4bcf70398b15114b">DD::Image::GeoWriter::status()</a>.</p>

</div>
</div>
<a class="anchor" id="a04c62b98ae62d3715b7c5b5a0c3817e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op::progressMessage </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a message to display on the progress meter. If this is not called, or if <em>fmt</em> is zero, then the message is the name of the operator. If you already have the message figured out, use a <em>fmt</em> of "%s", this is detected and the next argument is passed directly. </p>

<p>References <a class="el" href="classDD_1_1Image_1_1Op.html#a84d331e6b34badaa5f9678dd6df6917b">status_callback</a>, and <a class="el" href="DDString_8h.html#a154043ea6d83b8616f3148fbf4f24244">vsnprintf()</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Write.html#ae76f84680bb2d23603e7bc3b32ef0de5">DD::Image::Write::execute()</a>.</p>

</div>
</div>
<a class="anchor" id="a7d39f91bb365a356a69daccefae71fa0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op::progressDismiss </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make the progress meter disappear (if it was displaying this op) and reset all the progress stuff to it's default values. </p>

<p>References <a class="el" href="classDD_1_1Image_1_1Op.html#a84d331e6b34badaa5f9678dd6df6917b">status_callback</a>.</p>

</div>
</div>
<a class="anchor" id="aa7118c510e04b1e87737f9e2eec6785e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int DD::Image::Op::slowness </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>0 means no cache is necessary. This is for operators that directly calculate their output (and thus read no inputs), and for operators that internally buffer their output (so any additional caching is useless). Any operator that returns zero will disable any attempt to cache the output.</p>
<p>Non-zero numbers are supposed to indicate the slowness of the calculation. In theory this will be used to intelligently place caches where they do the most good, but the values are currently ignored. A sequence of operators would have the request() counts multiplied by their slowness and these added together to get an idea how expensive a branch is. So this value should be linear with the speed of the operator.</p>
<p>The default value is 10. This value is used by color correctors and similar pixel operators. Almost any other operator will be slower, you should judge how long it takes relative to a color corrector and multiply accordingly.</p>
<p>1 means really fast and should be returned by an operator that does not look at pixels, but simply copies blocks of them from the input to the output. Shuffle and Crop are examples of this. </p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1RenderScene.html#ab6f3b5274b541e907ba12b5ffc0844ae">DD::Image::RenderScene::_validate()</a>, <a class="el" href="classDD_1_1Image_1_1Transform.html#ad9b86ff52be5808cff50304f4344c176">DD::Image::Transform::_validate()</a>, <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#a97d2f933e4ae12f47d4b32df6d33bbed">DD::Image::NukeWrapper::_validate()</a>, <a class="el" href="classDD_1_1Image_1_1Render.html#a44a52a33fa89211f7b01b763d90e22c7">DD::Image::Render::_validate()</a>, <a class="el" href="classDD_1_1Image_1_1Transform.html#a8db8bf069d8e68b9c1366f41ce550149">DD::Image::Transform::degenerate()</a>, <a class="el" href="classDD_1_1Image_1_1Iop.html#ab1903d94f8e04ca446968ba731b074bb">DD::Image::Iop::get()</a>, and <a class="el" href="classDD_1_1Image_1_1Iop.html#aff68935b59294285e07d8e33e53cbfd7">DD::Image::Iop::Iop()</a>.</p>

</div>
</div>
<a class="anchor" id="a1356e393d10799db80da19e27310ac82"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Op::firstEngineRendersWholeRequest </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Override this method and return true if the first engine call renders the entire request area and locks all the other render threads.</p>
<p>This may be used to reuse the spare render threads in other parts of the tree and only call this op's engine call from one thread.</p>
<p>It is also useful in Nuke as it will hide the 'white-lines' if this method returns true and the viewer is connected to this op.</p>
<p>Note it is valid to return true or false dynamically from this method between validate passes. </p>

<p>Reimplemented in <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#a8a7958f38bbecda0968fd8bf875e31b1">DD::Image::NukeWrapper</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#a8a7958f38bbecda0968fd8bf875e31b1">DD::Image::NukeWrapper::firstEngineRendersWholeRequest()</a>.</p>

</div>
</div>
<a class="anchor" id="ac7a97a23daa29fcc1466a99d88595b73"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool DD::Image::Op::updateUI </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDD_1_1Image_1_1OutputContext.html">OutputContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>can be overriden by ops to update their UI when their control panel is open. if you override it, return true, otherwise it will not be called again. </p>

</div>
</div>
<a class="anchor" id="ad131c925b04abdeb048c5a0ae0012f97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDD_1_1Image_1_1Format.html">Format</a> &amp; Op::input_format </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the full_size_format() of node_input(0). This is needed to convert uv values to pixels or to look at the pixel aspect ratio. It can also be used to initialize default values of fields in the constructor. If the input is not connected, or not connected to a node producing an <a class="el" href="classDD_1_1Image_1_1Iop.html" title="Iop is the base class for all the image operators. ">Iop</a>, the format of <a class="el" href="classDD_1_1Image_1_1Iop.html#a6f2f504a83ec6ed4bdb8f6b8cca1490b">Iop::default_input()</a> is returned.</p>
<p>Note that until <a class="el" href="classDD_1_1Image_1_1Op.html#a54fe7079e0236ae45b247dd9f5e300b4">validate()</a> is called, this returns only a "guess". Be prepared for the format being different in <a class="el" href="classDD_1_1Image_1_1Op.html#a54fe7079e0236ae45b247dd9f5e300b4">validate()</a>. </p>

<p>References <a class="el" href="classDD_1_1Image_1_1Op.html#a1e65ba0209479090ca51fc3d0b60e8ea">node()</a>.</p>

</div>
</div>
<a class="anchor" id="aec4cf62da84ac80bf8c53ee99aeebb66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDD_1_1Image_1_1OutputContext.html">OutputContext</a> &amp; Op::uiContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the "user interface Context" from the node that generated this <a class="el" href="classDD_1_1Image_1_1Op.html" title="Base class of all the things that can be created by Nuke nodes. ">Op</a>. See Knob::outputContext() for more information. This is most useful for finding out the frame number or view the user is interested in right now. This is not necessarily the same as the Context passed to <a class="el" href="classDD_1_1Image_1_1Op.html#a17945fe59b77fdaeb7450d424fe4a7e2">setOutputContext()</a>! </p>

<p>References <a class="el" href="classDD_1_1Image_1_1Op.html#a1e65ba0209479090ca51fc3d0b60e8ea">node()</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1ReadGeo.html#aef6bfba04a696b14fcbae079755b6924">DD::Image::ReadGeo::_validate()</a>, and <a class="el" href="classDD_1_1Image_1_1RenderScene.html#acf63b203c79c4f3570481944ec91c1de">DD::Image::RenderScene::build_handles()</a>.</p>

</div>
</div>
<a class="anchor" id="afc3f4acb738937d3319707849fe1b26f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op::error </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An operator can call this to report an error. This will abort all trees that the op is in - i. e. calling <em><a class="el" href="classDD_1_1Image_1_1Op.html#af31a7c1b2fd23639d56c4e6a11c362d9" title="True if one of the trees the op is in was aborted; ops should check this while processing and return ...">aborted()</a></em> on this op or any op in one of the trees it's in will subsequently return true.</p>
<p>The fact that this was called is recorded and <a class="el" href="classDD_1_1Image_1_1Op.html#a2bb868632c6116e335c689d78b18ba7a">open()</a> will immediately cause the error again and return unless you call <a class="el" href="classDD_1_1Image_1_1Op.html#ad19589f141ad102c40fab9c26a87c5c8">invalidate()</a> on this.</p>
<p>The current version truncates the error message at 2048 characters unless the format is "%s" in which case it knows to use the first argument directly. </p>

<p>References <a class="el" href="classDD_1_1Image_1_1OpMessageHandler.html#ae22af988e26e419306bb3c75be9c4f3f">DD::Image::OpMessageHandler::addMessage()</a>, <a class="el" href="classDD_1_1Image_1_1OpTreeHandler.html#ab26870659b375b634334955ef818f266">DD::Image::OpTreeHandler::lockTrees()</a>, <a class="el" href="classDD_1_1Image_1_1OpTreeHandler.html#a760a937e4b446eea19695e52bb9b13f8">DD::Image::OpTreeHandler::unlockTrees()</a>, and <a class="el" href="DDString_8h.html#a154043ea6d83b8616f3148fbf4f24244">vsnprintf()</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1DrawIop.html#af9ef29ef2bc4a6c56c9df5925a6acfe7">DD::Image::DrawIop::_validate()</a>, <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#a97d2f933e4ae12f47d4b32df6d33bbed">DD::Image::NukeWrapper::_validate()</a>, <a class="el" href="classDD_1_1Image_1_1Write.html#a24b3332f92388c30a53211b413c4a885">DD::Image::Write::_validate()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#ab9ffa08d0a7e8b1d071a6f7bdcb5e106">create()</a>, <a class="el" href="classDD_1_1Image_1_1ReadGeo.html#aa4f4b7ddd0a3ec203dd9d05cc0c0c002">DD::Image::ReadGeo::internalError()</a>, <a class="el" href="classDD_1_1Image_1_1DeepWriter.html#ad348edfc22c985e898b1352fd4eddf81">DD::Image::DeepWriter::openFile()</a>, and <a class="el" href="classDD_1_1Image_1_1Iop.html#a5f7a57fc2339f0d84040d017e3f04b00">DD::Image::Iop::request()</a>.</p>

</div>
</div>
<a class="anchor" id="ad20367c3afd62cd40a9c4f13848e3ae3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op::warning </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print a warning message. On Unix these go to stderr and are prefixed with <a class="el" href="classDD_1_1Image_1_1Op.html#a6ae750a8ab437bef1c4d9996932c661b">print_name()</a>. </p>

<p>References <a class="el" href="classDD_1_1Image_1_1OpMessageHandler.html#ae22af988e26e419306bb3c75be9c4f3f">DD::Image::OpMessageHandler::addMessage()</a>, <a class="el" href="classDD_1_1Image_1_1OpTreeHandler.html#ab26870659b375b634334955ef818f266">DD::Image::OpTreeHandler::lockTrees()</a>, <a class="el" href="classDD_1_1Image_1_1OpTreeHandler.html#a760a937e4b446eea19695e52bb9b13f8">DD::Image::OpTreeHandler::unlockTrees()</a>, and <a class="el" href="DDString_8h.html#a154043ea6d83b8616f3148fbf4f24244">vsnprintf()</a>.</p>

<p>Referenced by <a class="el" href="namespaceDD_1_1Image.html#a2608bb039f71244261ae581a2382dfa9">DD::Image::PrintKnobChangedInValidateWarning()</a>, and <a class="el" href="classDD_1_1Image_1_1Iop.html#a5f7a57fc2339f0d84040d017e3f04b00">DD::Image::Iop::request()</a>.</p>

</div>
</div>
<a class="anchor" id="ae2058a0ade50b432f556bf5495a7cb3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op::critical </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An operator can call this to report an error. This will abort all trees that the op is in - i. e. calling <em><a class="el" href="classDD_1_1Image_1_1Op.html#af31a7c1b2fd23639d56c4e6a11c362d9" title="True if one of the trees the op is in was aborted; ops should check this while processing and return ...">aborted()</a></em> on this op or any op in one of the trees it's in will subsequently return true.</p>
<p>The fact that this was called is recorded and <a class="el" href="classDD_1_1Image_1_1Op.html#a2bb868632c6116e335c689d78b18ba7a">open()</a> will immediately cause the error again and return unless you call <a class="el" href="classDD_1_1Image_1_1Op.html#ad19589f141ad102c40fab9c26a87c5c8">invalidate()</a> on this.</p>
<p>The current version truncates the error message at 2048 characters unless the format is "%s" in which case it knows to use the first argument directly. </p>

<p>References <a class="el" href="classDD_1_1Image_1_1OpMessageHandler.html#ae22af988e26e419306bb3c75be9c4f3f">DD::Image::OpMessageHandler::addMessage()</a>, <a class="el" href="classDD_1_1Image_1_1OpTreeHandler.html#ab26870659b375b634334955ef818f266">DD::Image::OpTreeHandler::lockTrees()</a>, <a class="el" href="classDD_1_1Image_1_1OpTreeHandler.html#a760a937e4b446eea19695e52bb9b13f8">DD::Image::OpTreeHandler::unlockTrees()</a>, and <a class="el" href="DDString_8h.html#a154043ea6d83b8616f3148fbf4f24244">vsnprintf()</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1FileWriter.html#adfee0ca3c2f41671309ddb95a10e34d6">DD::Image::FileWriter::close()</a>, <a class="el" href="classDD_1_1Image_1_1Write.html#ae76f84680bb2d23603e7bc3b32ef0de5">DD::Image::Write::execute()</a>, <a class="el" href="classDD_1_1Image_1_1WriteGeo.html#abceab2d81b7c07498e068ede150dc173">DD::Image::WriteGeo::internalError()</a>, <a class="el" href="classDD_1_1Image_1_1Write.html#a6e86525fcefa036f39dcce06e3dd9d1c">DD::Image::Write::internalError()</a>, <a class="el" href="classDD_1_1Image_1_1FileWriter.html#aed230e8dc225591345530115a204b058">DD::Image::FileWriter::open()</a>, <a class="el" href="namespaceDD_1_1Image.html#a3b0769f6ffda7e365d106d112a3d452d">DD::Image::RenameTempToFinal()</a>, <a class="el" href="classDD_1_1Image_1_1FileWriter.html#ab71a5429578fca27206a0640b32f3488">DD::Image::FileWriter::seek()</a>, and <a class="el" href="classDD_1_1Image_1_1FileWriter.html#a032ad50c55b85e4ffa241b985d23c08e">DD::Image::FileWriter::write()</a>.</p>

</div>
</div>
<a class="anchor" id="ae90a6cff9b671dac3e5fcfd9809770f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Op::debug </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print a debug message. These will only go to stdout/stderr, unless the user has turned on verbose mode </p>

<p>References <a class="el" href="classDD_1_1Image_1_1OpMessageHandler.html#ae22af988e26e419306bb3c75be9c4f3f">DD::Image::OpMessageHandler::addMessage()</a>, <a class="el" href="classDD_1_1Image_1_1OpTreeHandler.html#ab26870659b375b634334955ef818f266">DD::Image::OpTreeHandler::lockTrees()</a>, <a class="el" href="classDD_1_1Image_1_1OpTreeHandler.html#a760a937e4b446eea19695e52bb9b13f8">DD::Image::OpTreeHandler::unlockTrees()</a>, and <a class="el" href="DDString_8h.html#a154043ea6d83b8616f3148fbf4f24244">vsnprintf()</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Reader.html#a5edd034e4aa116743f352579aacf296c">DD::Image::Reader::engine()</a>, <a class="el" href="classDD_1_1Image_1_1Iop.html#a9cceff1fd9ac712c3c08dbfefdafe5d6">DD::Image::Iop::engine()</a>, <a class="el" href="classDD_1_1Image_1_1GeoWriter.html#a971ed220e5a94a6a5e0916b71330f42d">DD::Image::GeoWriter::execute()</a>, <a class="el" href="classDD_1_1Image_1_1Writer.html#a6c8248c49feaa2817c6d8fd97e62a43b">DD::Image::Writer::execute()</a>, <a class="el" href="classDD_1_1Image_1_1Reader.html#abf017b301fd4a03a270ed9dafb8ea5d6">DD::Image::Reader::fetchPlane()</a>, <a class="el" href="classDD_1_1Image_1_1Material.html#ae3282d74f93080295a99f16abfcb1bf3">DD::Image::Material::fragment_shader()</a>, <a class="el" href="classDD_1_1Image_1_1GeoReader.html#ab2207af9b7e0cacc5f9247bf7b91b517">DD::Image::GeoReader::geometry_engine()</a>, <a class="el" href="classDD_1_1Image_1_1DrawIop.html#a451d857f14e82128b72f571696e38460">DD::Image::DrawIop::pixel_engine()</a>, <a class="el" href="classDD_1_1Image_1_1PixelIop.html#a4916b2509ae369e83174d9ce8b896d60">DD::Image::PixelIop::pixel_engine()</a>, <a class="el" href="classDD_1_1Image_1_1Iop.html#a5f7a57fc2339f0d84040d017e3f04b00">DD::Image::Iop::request()</a>, <a class="el" href="classDD_1_1Image_1_1Material.html#a9e3418132d7a5fe19e03287377029c1c">DD::Image::Material::shade_GL()</a>, and <a class="el" href="classDD_1_1Image_1_1Material.html#ad2136f1b249fb6002e4766a712ca8b80">DD::Image::Material::vertex_shader()</a>.</p>

</div>
</div>
<a class="anchor" id="a3fd4d927f78192165d0a4da61a8a2803"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDD_1_1Image_1_1Op.html">Op</a> * Op::error_op </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an op with an active error (the first one found if any), or NULL if none. Deprecated. Use other error functions such as <em><a class="el" href="classDD_1_1Image_1_1Op.html#a443106e419573550ccc22812c0bb3f18">Op::hasError()</a></em> or <em><a class="el" href="classDD_1_1Image_1_1OpTree.html#a40f74991227d86cec7d8fdec405930d3" title="Returns the first op in the tree with an error set, or NULL if none do. ">OpTree::getFirstOpWithError()</a></em> instead. </p>

<p>References <a class="el" href="classDD_1_1Image_1_1OpTree.html#a40f74991227d86cec7d8fdec405930d3">DD::Image::OpTree::getFirstOpWithError()</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Op.html#a3a2ac728424be8a75b609801fde5804b">error_message()</a>.</p>

</div>
</div>
<a class="anchor" id="a3a2ac728424be8a75b609801fde5804b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * Op::error_message </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the error string from an op with an active error (the return from <em><a class="el" href="classDD_1_1Image_1_1Op.html#a3fd4d927f78192165d0a4da61a8a2803">error_op()</a></em>), or NULL if none. Deprecated. Use other error functions such as <em>OpMessageHandler::getFirstError()</em> instead. </p>

<p>References <a class="el" href="classDD_1_1Image_1_1Op.html#a3fd4d927f78192165d0a4da61a8a2803">error_op()</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1WriteGeo.html#a4e9b0b6e0a0e9ce20af933cb6ac54a26">DD::Image::WriteGeo::set_file_type_from_filename()</a>.</p>

</div>
</div>
<a class="anchor" id="a443106e419573550ccc22812c0bb3f18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Op::hasError </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true if this op, or any of it's children, is in an error state Not thread safe; only call from the main thread </p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1OpTree.html#a9446475e4e6bab92c7521e7cc8be1c6d">DD::Image::OpTree::addMessageOp()</a>, <a class="el" href="classDD_1_1Image_1_1Write.html#ae76f84680bb2d23603e7bc3b32ef0de5">DD::Image::Write::execute()</a>, and <a class="el" href="classDD_1_1Image_1_1OpTree.html#ac62bfc05251938616e54d3f961359107">DD::Image::OpTree::removeMessageOp()</a>.</p>

</div>
</div>
<a class="anchor" id="ab8a66b0df5e35b445a2e820018b842b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Op::opOrChildHasError </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The same as opOrChildHasError, but will return the first <a class="el" href="classDD_1_1Image_1_1Op.html" title="Base class of all the things that can be created by Nuke nodes. ">Op</a> which is in an error state. Not thread safe; only call from the main thread </p>

</div>
</div>
<a class="anchor" id="ab007448be5c7c917810e59515c209718"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Op::tryValidate </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>for_real</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call <a class="el" href="classDD_1_1Image_1_1Op.html#a54fe7079e0236ae45b247dd9f5e300b4">validate()</a> and return true if it did not cause <a class="el" href="classDD_1_1Image_1_1Op.html#afc3f4acb738937d3319707849fe1b26f">error()</a> to be called. During this call calls to <a class="el" href="classDD_1_1Image_1_1Op.html#afc3f4acb738937d3319707849fe1b26f">error()</a> do not cause <a class="el" href="classDD_1_1Image_1_1Op.html#ad2bc52a1cf2100f5e21446af388e1afb" title="Abort all trees the op is in. ">abort()</a>, and thus will not kill running parallel threads.</p>
<p>All new code should call this instead of <a class="el" href="classDD_1_1Image_1_1Op.html#a54fe7079e0236ae45b247dd9f5e300b4">validate()</a> to be compatible with future versions.</p>
<p>Returns false if error was called. More detail can be retrieved from the message in the op's message handler - see <em>getMsgHandler()</em>. Returns true if <a class="el" href="classDD_1_1Image_1_1Op.html#afc3f4acb738937d3319707849fe1b26f">error()</a> was not called. </p>

<p>References <a class="el" href="classDD_1_1Image_1_1OpTree.html#a8b37d0992bc1e48d1075b3c9092f7dda">DD::Image::OpTree::hasError()</a>, and <a class="el" href="classDD_1_1Image_1_1Op.html#a54fe7079e0236ae45b247dd9f5e300b4">validate()</a>.</p>

</div>
</div>
<a class="anchor" id="a4fc5fd8a59a843cfd322b132b5ae426d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * DD::Image::Op::Class </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the command name that will be stored in Nuke scripts. This must be unique for each different function and must be the same string (ie the same pointer) as is in the <a class="el" href="classDD_1_1Image_1_1Op_1_1Description.html">Op::Description</a> object that constructed this instance.</p>
<p>If you don't plan to make a Nuke operator you can have this return null. </p>

<p>Implemented in <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#a053da3dbdf49885ce075db168670d5d8">DD::Image::NukeWrapper</a>, and <a class="el" href="classDD_1_1Image_1_1Convolve.html#a398f2bc4753adbd074aa5c622f4c2acc">DD::Image::Convolve</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1ParticleOp.html#adee80501072cc12fa02ee350e575e1d0">DD::Image::ParticleOp::appendSimulationCurve()</a>, <a class="el" href="classDD_1_1Image_1_1GeoOp.html#a109c9154b37b72033a8689e1442d1225">DD::Image::GeoOp::build_scene()</a>, <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#a053da3dbdf49885ce075db168670d5d8">DD::Image::NukeWrapper::Class()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#a833d6b240f57340f721e6d58b0b7ed3b">displayName()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#aa284f1588298fbf3a65f7e6eb3dfcfe9">docsPath()</a>, <a class="el" href="classDD_1_1Image_1_1Material.html#ae3282d74f93080295a99f16abfcb1bf3">DD::Image::Material::fragment_shader()</a>, <a class="el" href="classDD_1_1Image_1_1Iop.html#ab1903d94f8e04ca446968ba731b074bb">DD::Image::Iop::get()</a>, <a class="el" href="classDD_1_1Image_1_1GeoOp.html#a382c89d2fd4ece23ed5728f4a5c2579d">DD::Image::GeoOp::get_geometry()</a>, <a class="el" href="classDD_1_1Image_1_1BufferIop.html#a957ab9dc31baee9e1631abd76a1cdfac">DD::Image::BufferIop::getName()</a>, <a class="el" href="namespaceDD_1_1Image.html#a5b01bd15dbdeff52e8474a0154cf3238">DD::Image::GetOpText()</a>, <a class="el" href="namespaceDD_1_1Image.html#a95e15345ea081cb17ff4e9592951ce45">DD::Image::opHints()</a>, <a class="el" href="classDD_1_1Image_1_1GeoOp.html#a534c7ffdb4de73b950340c51ff25e4a3">DD::Image::GeoOp::print_info()</a>, <a class="el" href="classDD_1_1Image_1_1Material.html#a9e3418132d7a5fe19e03287377029c1c">DD::Image::Material::shade_GL()</a>, <a class="el" href="classDD_1_1Image_1_1GeometryList.html#aeac5bee2ce79881779db1d9f59d7cf5c">DD::Image::GeometryList::synchronize_objects()</a>, and <a class="el" href="classDD_1_1Image_1_1Material.html#ad2136f1b249fb6002e4766a712ca8b80">DD::Image::Material::vertex_shader()</a>.</p>

</div>
</div>
<a class="anchor" id="a13168087d6ac700724e51387ab747c5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string Op::libraryDisplayName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the library name and version that the <a class="el" href="classDD_1_1Image_1_1Op.html" title="Base class of all the things that can be created by Nuke nodes. ">Op</a> is using if they have been set, otherwise return an empty string. </p>

<p>References <a class="el" href="classDD_1_1Image_1_1Op.html#abcd7e0b3d7926230d932d16f7ff7f995">getLibraryName()</a>, and <a class="el" href="classDD_1_1Image_1_1Op.html#ad70244d478609ac267f25c5da19dd7c7">getVersionInfoStr()</a>.</p>

</div>
</div>
<a class="anchor" id="a833d6b240f57340f721e6d58b0b7ed3b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * Op::displayName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a name for this class that will be shown to the user. The default implementation returns <a class="el" href="classDD_1_1Image_1_1Op.html#a4fc5fd8a59a843cfd322b132b5ae426d">Class()</a>. You can return a different (ie more user-friendly) name instead here, and there is no need for this to be unique.</p>
<p>Nuke currently will remove any trailing digits and underscores from this and add a new number to make a unique name for the new node. </p>

<p>Reimplemented in <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#ac76f16b2f75ae52e74cda04526c25914">DD::Image::NukeWrapper</a>, and <a class="el" href="classDD_1_1Image_1_1LightOp.html#a3c06573505450e63c2589c717ad8130a">DD::Image::LightOp</a>.</p>

<p>References <a class="el" href="classDD_1_1Image_1_1Op.html#a4fc5fd8a59a843cfd322b132b5ae426d">Class()</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#ac76f16b2f75ae52e74cda04526c25914">DD::Image::NukeWrapper::displayName()</a>.</p>

</div>
</div>
<a class="anchor" id="aa284f1588298fbf3a65f7e6eb3dfcfe9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Op::docsPath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the default path used to search for online help. Usually the <a class="el" href="classDD_1_1Image_1_1Op.html#a4fc5fd8a59a843cfd322b132b5ae426d">Class()</a> but can be overridden. </p>

<p>Reimplemented in <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#a62b40bc37a07498724780e2f36763921">DD::Image::NukeWrapper</a>.</p>

<p>References <a class="el" href="classDD_1_1Image_1_1Op.html#a4fc5fd8a59a843cfd322b132b5ae426d">Class()</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1NukeWrapper.html#a62b40bc37a07498724780e2f36763921">DD::Image::NukeWrapper::docsPath()</a>.</p>

</div>
</div>
<a class="anchor" id="a77dbe02db9c352f699eb20a527b5a95b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool DD::Image::Op::onAction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDD_1_1Image_1_1ViewerContext.html">ViewerContext</a> *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DD::Image::Flags&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A function <em>designed</em> to send keyboard (and other) events to the selected node. Could be used for a variety of event &amp; data. </p>

</div>
</div>
<a class="anchor" id="ac8dbbc4a153095c890f0bc50754fd53d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDD_1_1Image_1_1Op.html">Op</a> * Op::get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDD_1_1Image_1_1Op_1_1Description.html">Description</a> *&#160;</td>
          <td class="paramname"><em>description</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is used to insert operators that produce data needed by the user interface, such as TextureMap, Histograms, and PostageStamp. Usually this is called by one of the outputs of this op to insert something that operator needs for the user interface.</p>
<p>Nuke will create the described operator and connect it to the output of this-&gt;firstOp(), inserting it between it and whatever was connected to there. The new operator is returned. You can then <a class="el" href="classDD_1_1Image_1_1Op.html#a54fe7079e0236ae45b247dd9f5e300b4">validate()</a> it and execute() it to get information from it. Or you can rely on side-effects of lines being pulled through the operator, or on execute() being called during idle by Nuke, which will avoid slowing down the main calculation.</p>
<p>If this is called again with the same description the previous created one is returned again. So at most one operator of each type is created for any Node. </p>

</div>
</div>
<a class="anchor" id="acebc17c770453f35c1cf012abc3a34d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDD_1_1Image_1_1Op_1_1Description.html">Op::Description</a> * Op::find_description </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDD_1_1Image_1_1Op.html">Op</a> *&#160;</td>
          <td class="paramname"><em>op_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search for an <a class="el" href="classDD_1_1Image_1_1Op_1_1Description.html">Op::Description</a> that has the given name. Returns the description if found. If it fails, it throws a std::runtime_error which contains the message from <a class="el" href="namespaceDD_1_1Image.html#a12af1a16de5d3317b0f330d529624fcd">plugin_error()</a>.</p>
<p>First this searches all the ones that are known about. Then it tries to load a plugin using <a class="el" href="namespaceDD_1_1Image.html#a58351c10a08cf1980a2123ba12763c1b" title="load a plugin with the basename &#39;name&#39; (or &#39;altname&#39; if specified and nothing by name can be found) ...">plugin_load()</a> and sees if that defines the operator. </p>

<p>References <a class="el" href="namespaceDD_1_1Image.html#a12af1a16de5d3317b0f330d529624fcd">DD::Image::plugin_error()</a>, and <a class="el" href="namespaceDD_1_1Image.html#a58351c10a08cf1980a2123ba12763c1b">DD::Image::plugin_load()</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Op.html#ab9ffa08d0a7e8b1d071a6f7bdcb5e106">create()</a>.</p>

</div>
</div>
<a class="anchor" id="a285efb59707933179ee733d71331ffcc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Op::message_f </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function prints a formated message to stdout. If DDImage runs in Nuke in interactive mode, this function will open a modal dialog box instead.</p>
<ul>
<li>t defines the type of dialog that will appear:<ul>
<li>'i' will show a message dialog</li>
<li>'!' will show an alert dialog</li>
<li>'?' will show a question and return 1 if the user click 'yes', and 0 otherwise </li>
</ul>
</li>
</ul>

</div>
</div>
<a class="anchor" id="a90bfc1752627fa7caa67fddcd1fc1c9c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Op::message_vf </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>va</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classDD_1_1Image_1_1Op.html#a285efb59707933179ee733d71331ffcc">Op::message_f</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2cb3d3b16d4e4f70dc5ec0b0545a99da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Op::add_timeout </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TimeoutHandler&#160;</td>
          <td class="paramname"><em>toh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>v</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add a one-shot timeout callback.</p>
<p>The function will be called by Nuke at <em>t</em> seconds after this function is called. The optional void* argument is passed to the callback (you may want to pass <em>this</em>).</p>
<p>The timeout will be called even if the <a class="el" href="classDD_1_1Image_1_1Op.html" title="Base class of all the things that can be created by Nuke nodes. ">Op</a> is destroyed. If you don't want this to happen, make sure you call remove_timeout in the destructor. </p>

</div>
</div>
<a class="anchor" id="ac1043cf2af70846b8f7481c45e1ebead"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Op::repeat_timeout </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TimeoutHandler&#160;</td>
          <td class="paramname"><em>toh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>v</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inside a timeout callback you can call this to add another timeout. Rather than the time being measured from "now", it is measured from when the system call elapsed that caused this timeout to be called. This will result in far more accurate spacing of the timeout callbacks, it also has slightly less system call overhead.</p>
<p>It is undefined what this does if called from outside a timeout callback. </p>

</div>
</div>
<a class="anchor" id="a865f2230aa48e64e4ac7afbebe1ff1a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Op::has_timeout </td>
          <td>(</td>
          <td class="paramtype">TimeoutHandler&#160;</td>
          <td class="paramname"><em>toh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>v</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the timeout exists and has not been called yet. </p>

</div>
</div>
<a class="anchor" id="a01f1546aca4511bae387fa46fd84fe3e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Op::remove_timeout </td>
          <td>(</td>
          <td class="paramtype">TimeoutHandler&#160;</td>
          <td class="paramname"><em>toh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>v</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes a timeout callback. It is harmless to remove a timeout callback that no longer exists. </p>

</div>
</div>
<a class="anchor" id="a578ecede84d9c432c3cd8b4496d4b16e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDD_1_1Image_1_1Op.html#a896b162a5d1b1d07f9397b667362ce49">Op::PrevalidateResult</a> Op::doPreValidate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDD_1_1Image_1_1ViewerContext.html">ViewerContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDD_1_1Image_1_1PreValidateContext.html">PreValidateContext</a> *&#160;</td>
          <td class="paramname"><em>pvc</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>virtual function that is called by preValidate to do actual work. The base class version calls <a class="el" href="classDD_1_1Image_1_1Op.html#a44f1e97f589ca7c7d16b5eb15ea94824">preValidate()</a> recursively on all inputs. An override of this should either call that and return its return value if non-eFinished, eCancelled if the user actually clicked 'cancel' in a progress bar, or eAbandoned if the tree became obsolete. </p>

<p>Reimplemented in <a class="el" href="classDD_1_1Image_1_1ParticleRender.html#ababfeb287f4ad417820b2d85d1f8392c">DD::Image::ParticleRender</a>.</p>

<p>References <a class="el" href="classDD_1_1Image_1_1Op.html#a3f8fb27d42f6da712722fa73eda6b5b0">input()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#a1f2eaf5b7de5354cc5838e608cf25543">inputs()</a>, and <a class="el" href="classDD_1_1Image_1_1Op.html#a44f1e97f589ca7c7d16b5eb15ea94824">preValidate()</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Op.html#a44f1e97f589ca7c7d16b5eb15ea94824">preValidate()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="ae6f647e85b45e6b7079bb17471273d90"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void(* Op::node_redraw_cb)(const <a class="el" href="classDD_1_1Image_1_1Op.html">Op</a> *)=default_redraw</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Programs (e.g. Nuke) can set this callback to change what code is called when <a class="el" href="classDD_1_1Image_1_1Op.html#aa3a29ea27d511f7074d053df864c5195">node_redraw()</a> is called. The default version does nothing. </p>

</div>
</div>
<a class="anchor" id="ad54373ae41fee669bef9bc61827944fe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void(* Op::print_name_cb)(std::ostream &amp;o, const <a class="el" href="classDD_1_1Image_1_1Op.html">Op</a> *i)=default_print_name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Programs can set this callback so they can use the <a class="el" href="classDD_1_1Image_1_1Op.html#a1e65ba0209479090ca51fc3d0b60e8ea">node()</a> to print the name of the <a class="el" href="classDD_1_1Image_1_1Op.html" title="Base class of all the things that can be created by Nuke nodes. ">Op</a>. By default this just prints the <a class="el" href="classDD_1_1Image_1_1Op.html#a4fc5fd8a59a843cfd322b132b5ae426d">Class()</a> of this and all <a class="el" href="classDD_1_1Image_1_1Op.html#a0d4340b2a813327a249698c0dee107bb">parent()</a> operators. </p>

</div>
</div>
<a class="anchor" id="a84d331e6b34badaa5f9678dd6df6917b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void(* Op::status_callback)(const <a class="el" href="classDD_1_1Image_1_1Op.html">Op</a> *, float, float, const char *, <a class="el" href="classDD_1_1Image_1_1Op.html#ad05eb8420166eff8fabdb30b8fe9c13c">Op::StatusFlags</a>)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Non-Nuke programs may set this pointer to get called when operators call <a class="el" href="classDD_1_1Image_1_1Op.html#a178abeee0e49785e55d1a08033e9f313">progressFraction()</a> and <a class="el" href="classDD_1_1Image_1_1Op.html#a04c62b98ae62d3715b7c5b5a0c3817e5">progressMessage()</a>. This is mostly useful to get <a class="el" href="classDD_1_1Image_1_1Write.html">Write</a> operators to print a display.</p>
<p>The <a class="el" href="classDD_1_1Image_1_1Op.html" title="Base class of all the things that can be created by Nuke nodes. ">Op</a> argument is set to the op that status() was called on.</p>
<p>The fraction is passed unchanged.</p>
<p>Total is unused and should be ignored.</p>
<p>The message is the printed message from <a class="el" href="classDD_1_1Image_1_1Op.html#a04c62b98ae62d3715b7c5b5a0c3817e5">progressMessage()</a>. This buffered result will be freed when this returns, so you must copy it if you want to keep it.</p>
<p>Flags indicate whether operating in modal mode, and whether doProgressUpdate should be called.</p>
<p>An implementation should show the message (if any) to the user, and use the fraction to update a percent-done indicator. You should avoid expensive operations if the indicator has not changed. Here is a sample:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="classDD_1_1Image_1_1Op.html#a84d331e6b34badaa5f9678dd6df6917b">status_callback</a>(<span class="keyword">const</span> Op*, <span class="keywordtype">float</span> fraction, <span class="keywordtype">float</span> total, <span class="keyword">const</span> <span class="keywordtype">char</span>* t, <a class="code" href="classDD_1_1Image_1_1Op.html#ad05eb8420166eff8fabdb30b8fe9c13c">StatusFlags</a> flags)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">int</span> previous = 0;</div>
<div class="line">  <span class="keywordtype">int</span> percent = int(fraction*100+.5);</div>
<div class="line">  <span class="keywordflow">if</span> (t)</div>
<div class="line">    printf(<span class="stringliteral">&quot;\r%s:\033[K&quot;</span>, t);</div>
<div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (percent == previous)</div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">  previous = percent;</div>
<div class="line">  printf(<span class="stringliteral">&quot;%3d%%\b\b\b\b&quot;</span>, percent);</div>
<div class="line">  fflush(stdout);</div>
<div class="line">}</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"><a class="code" href="classDD_1_1Image_1_1Op.html#a84d331e6b34badaa5f9678dd6df6917b">Op::status_callback</a> = <a class="code" href="classDD_1_1Image_1_1Op.html#a84d331e6b34badaa5f9678dd6df6917b">status_callback</a>;</div>
</div><!-- fragment --> 
<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Op.html#a7d39f91bb365a356a69daccefae71fa0">progressDismiss()</a>, <a class="el" href="classDD_1_1Image_1_1Op.html#a178abeee0e49785e55d1a08033e9f313">progressFraction()</a>, and <a class="el" href="classDD_1_1Image_1_1Op.html#a04c62b98ae62d3715b7c5b5a0c3817e5">progressMessage()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<br>
<hr>
<table width="100%"  border="0" cellspacing="0" cellpadding="0">
  <tr>
    <td><span class="legal">&copy;2022 The Foundry Visionmongers, Ltd.  All Rights Reserved. </span></td>
    <td><div align="right"><span class="legal"><a href="http://www.thefoundry.co.uk" target="_blank">www.thefoundry.co.uk</a></span></div></td>
  </tr>
</table>
</body>
</html>
