<html><head><link href="doxygen.css" rel="stylesheet" type="text/css">
<title>Nuke Developer Kit (NDK) 13.2.4: DD::Image::Row Class Reference</title></head><body>
<!-- Generated by Doxygen 1.8.10 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classDD_1_1Image_1_1Row.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classDD_1_1Image_1_1Row-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">DD::Image::Row Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2a52aa0a2449c6f51e4f84469d223b54"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a52aa0a2449c6f51e4f84469d223b54"></a>
typedef float *&#160;</td><td class="memItemRight" valign="bottom"><b>WritablePtr</b></td></tr>
<tr class="separator:a2a52aa0a2449c6f51e4f84469d223b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d69a75d5ec3d39a78b4a956face514"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa9d69a75d5ec3d39a78b4a956face514"></a>
typedef const float *&#160;</td><td class="memItemRight" valign="bottom"><b>ReadablePtr</b></td></tr>
<tr class="separator:aa9d69a75d5ec3d39a78b4a956face514"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2187106dd2c7ed271e7f843d5e14576b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2187106dd2c7ed271e7f843d5e14576b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getLeft</b> () const </td></tr>
<tr class="separator:a2187106dd2c7ed271e7f843d5e14576b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c82c63027ecedb27596108e8c98154f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c82c63027ecedb27596108e8c98154f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getRight</b> () const </td></tr>
<tr class="separator:a0c82c63027ecedb27596108e8c98154f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a294f173d27b8c3592086e85ee252bde1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Row.html#a294f173d27b8c3592086e85ee252bde1">Row</a> (int X, int R)</td></tr>
<tr class="separator:a294f173d27b8c3592086e85ee252bde1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc0869c91dc94ee595069309ba15690"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Row.html#a8cc0869c91dc94ee595069309ba15690">~Row</a> ()</td></tr>
<tr class="separator:a8cc0869c91dc94ee595069309ba15690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a1f7039e90b7ad34134abec843bdb11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Row.html#a7a1f7039e90b7ad34134abec843bdb11">release</a> ()</td></tr>
<tr class="separator:a7a1f7039e90b7ad34134abec843bdb11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a248131b283859d1fa6037f396acf5545"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Row.html#a248131b283859d1fa6037f396acf5545">holdsCacheLine</a> () const </td></tr>
<tr class="separator:a248131b283859d1fa6037f396acf5545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68926c14799d88f8a77080210b0f75f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Row.html#a68926c14799d88f8a77080210b0f75f7">setCacheLine</a> (std::unique_ptr&lt; CacheLineUnlockGuard &gt; &amp;&amp;guard)</td></tr>
<tr class="separator:a68926c14799d88f8a77080210b0f75f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa559e2c6ae27884d1793fc5018c22bbf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Row.html#aa559e2c6ae27884d1793fc5018c22bbf">range</a> (int X, int R)</td></tr>
<tr class="separator:aa559e2c6ae27884d1793fc5018c22bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a897595ce9d871e00426f531fc775c0fe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a897595ce9d871e00426f531fc775c0fe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>forceRange</b> (int X, int R)</td></tr>
<tr class="separator:a897595ce9d871e00426f531fc775c0fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69fdee8cfde095c4e2d5ef8d9789f98a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Row.html#a69fdee8cfde095c4e2d5ef8d9789f98a">offset</a> (int delta)</td></tr>
<tr class="separator:a69fdee8cfde095c4e2d5ef8d9789f98a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62272de0e2e35ed266e66b68d092f780"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Row.html#a62272de0e2e35ed266e66b68d092f780">write</a> (<a class="el" href="namespaceDD_1_1Image.html#a51fc415b5f1d266eed9ef420b3e0142d">Channel</a>, float *)</td></tr>
<tr class="separator:a62272de0e2e35ed266e66b68d092f780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4119ab82ae22e0c8cadf39a7eddec680"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Row.html#a4119ab82ae22e0c8cadf39a7eddec680">read</a> (<a class="el" href="namespaceDD_1_1Image.html#a51fc415b5f1d266eed9ef420b3e0142d">Channel</a>, float *)</td></tr>
<tr class="separator:a4119ab82ae22e0c8cadf39a7eddec680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc58365bf54ff0b4e280521c21cdcf5d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Row.html#abc58365bf54ff0b4e280521c21cdcf5d">mFnDeprecatedInNuke13</a> (&quot;setPreallocatedWriteBuffer(<a class="el" href="namespaceDD_1_1Image.html#a51fc415b5f1d266eed9ef420b3e0142d">Channel</a>, float*) has been deprecated. Use <a class="el" href="classDD_1_1Image_1_1Row.html#a62272de0e2e35ed266e66b68d092f780">write</a>(<a class="el" href="namespaceDD_1_1Image.html#a51fc415b5f1d266eed9ef420b3e0142d">Channel</a>, float*) instead.\n&quot;) void setPreallocatedWriteBuffer(<a class="el" href="namespaceDD_1_1Image.html#a51fc415b5f1d266eed9ef420b3e0142d">Channel</a></td></tr>
<tr class="separator:abc58365bf54ff0b4e280521c21cdcf5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6231732d81242ff0f2900db0de3cc598"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6231732d81242ff0f2900db0de3cc598"></a>
float *ChannelMask&#160;</td><td class="memItemRight" valign="bottom"><b>writable_channels</b> () const </td></tr>
<tr class="separator:a6231732d81242ff0f2900db0de3cc598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f0fc6fc9e2c40228797df969feb9ce"><td class="memItemLeft" align="right" valign="top">ReadablePtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Row.html#a03f0fc6fc9e2c40228797df969feb9ce">operator[]</a> (<a class="el" href="namespaceDD_1_1Image.html#a51fc415b5f1d266eed9ef420b3e0142d">Channel</a> z) const </td></tr>
<tr class="separator:a03f0fc6fc9e2c40228797df969feb9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a0b479b306e1faf25c71a54eaa087c"><td class="memItemLeft" align="right" valign="top">WritablePtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Row.html#aa4a0b479b306e1faf25c71a54eaa087c">writable</a> (<a class="el" href="namespaceDD_1_1Image.html#a51fc415b5f1d266eed9ef420b3e0142d">Channel</a> z)</td></tr>
<tr class="separator:aa4a0b479b306e1faf25c71a54eaa087c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb35804cc4235ff18aadacc13b1a59d"><td class="memItemLeft" align="right" valign="top">WritablePtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Row.html#a8cb35804cc4235ff18aadacc13b1a59d">writableConstant</a> (const float val, <a class="el" href="namespaceDD_1_1Image.html#a51fc415b5f1d266eed9ef420b3e0142d">Channel</a> z)</td></tr>
<tr class="separator:a8cb35804cc4235ff18aadacc13b1a59d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88ce6607fa1df9f174bc08e2fda01f18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Row.html#a88ce6607fa1df9f174bc08e2fda01f18">pre_copy</a> (<a class="el" href="namespaceDD_1_1Image.html#a51fc415b5f1d266eed9ef420b3e0142d">Channel</a> z, <a class="el" href="classDD_1_1Image_1_1Row.html">Row</a> &amp;, <a class="el" href="namespaceDD_1_1Image.html#a51fc415b5f1d266eed9ef420b3e0142d">Channel</a> source_channel) const </td></tr>
<tr class="separator:a88ce6607fa1df9f174bc08e2fda01f18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18c9cfd6ce1a46725dc4c3704b4fa88e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a18c9cfd6ce1a46725dc4c3704b4fa88e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pre_copy</b> (<a class="el" href="classDD_1_1Image_1_1Row.html">Row</a> &amp;s, <a class="el" href="namespaceDD_1_1Image.html#a51fc415b5f1d266eed9ef420b3e0142d">Channel</a> z) const </td></tr>
<tr class="separator:a18c9cfd6ce1a46725dc4c3704b4fa88e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a472bb4fcfe91abc3f57530d86d0c7675"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Row.html#a472bb4fcfe91abc3f57530d86d0c7675">copy</a> (<a class="el" href="namespaceDD_1_1Image.html#a51fc415b5f1d266eed9ef420b3e0142d">Channel</a> z, const <a class="el" href="classDD_1_1Image_1_1Row.html">Row</a> &amp;, <a class="el" href="namespaceDD_1_1Image.html#a51fc415b5f1d266eed9ef420b3e0142d">Channel</a> source_channel, int x, int r)</td></tr>
<tr class="separator:a472bb4fcfe91abc3f57530d86d0c7675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aaa7682bdb5fe2ff69591fbcd8003eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2aaa7682bdb5fe2ff69591fbcd8003eb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>copy</b> (const <a class="el" href="classDD_1_1Image_1_1Row.html">Row</a> &amp;s, <a class="el" href="namespaceDD_1_1Image.html#a51fc415b5f1d266eed9ef420b3e0142d">Channel</a> z, int x, int r)</td></tr>
<tr class="separator:a2aaa7682bdb5fe2ff69591fbcd8003eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ab4a998dc51e8be64072903fec02a94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Row.html#a4ab4a998dc51e8be64072903fec02a94">pre_copy</a> (<a class="el" href="classDD_1_1Image_1_1Row.html">Row</a> &amp;, ChannelMask) const </td></tr>
<tr class="separator:a4ab4a998dc51e8be64072903fec02a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d08e14bd60cc101f3b53d35b37c276"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Row.html#a42d08e14bd60cc101f3b53d35b37c276">copy</a> (const <a class="el" href="classDD_1_1Image_1_1Row.html">Row</a> &amp;, ChannelMask, int x, int r)</td></tr>
<tr class="separator:a42d08e14bd60cc101f3b53d35b37c276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9532a1d8c8abd73908ba13234f29135e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Row.html#a9532a1d8c8abd73908ba13234f29135e">get</a> (<a class="el" href="classDD_1_1Image_1_1Iop.html">Iop</a> &amp;, int y, int x, int r, ChannelMask)</td></tr>
<tr class="separator:a9532a1d8c8abd73908ba13234f29135e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a051c26ae09058cc00b24cb98b7ba38b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Row.html#a051c26ae09058cc00b24cb98b7ba38b2">erase</a> (ChannelMask)</td></tr>
<tr class="separator:a051c26ae09058cc00b24cb98b7ba38b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac781583144b07d43eec3d90d959ec0ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Row.html#ac781583144b07d43eec3d90d959ec0ed">erase</a> (<a class="el" href="namespaceDD_1_1Image.html#a51fc415b5f1d266eed9ef420b3e0142d">Channel</a>)</td></tr>
<tr class="separator:ac781583144b07d43eec3d90d959ec0ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdde82e893cefa592d752d076405aa48"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Row.html#acdde82e893cefa592d752d076405aa48">is_zero</a> (<a class="el" href="namespaceDD_1_1Image.html#a51fc415b5f1d266eed9ef420b3e0142d">Channel</a> channel) const </td></tr>
<tr class="separator:acdde82e893cefa592d752d076405aa48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea6bcc89a0a9b8d668c1a2dc807eb6ce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea6bcc89a0a9b8d668c1a2dc807eb6ce"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_debug</b> (int x, int r, ChannelMask channels) const </td></tr>
<tr class="separator:aea6bcc89a0a9b8d668c1a2dc807eb6ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e7091fe933e46ee85e3cd2d3e490d11"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e7091fe933e46ee85e3cd2d3e490d11"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>debug</b> (int x, int r, ChannelMask channels) const </td></tr>
<tr class="separator:a6e7091fe933e46ee85e3cd2d3e490d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aec7f89791dade754f1c62a5dead3416b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec7f89791dade754f1c62a5dead3416b"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_zero</b> (const float *, int X, int R)</td></tr>
<tr class="separator:aec7f89791dade754f1c62a5dead3416b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a7bfcb57b9ab8c6b416fc62b20c7cd0"><td class="memItemLeft" align="right" valign="top">static const float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Row.html#a1a7bfcb57b9ab8c6b416fc62b20c7cd0">zero_buffer</a> (unsigned size)</td></tr>
<tr class="separator:a1a7bfcb57b9ab8c6b416fc62b20c7cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71f8a2d3f072a52c969811d205c36cce"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Row.html#a71f8a2d3f072a52c969811d205c36cce">is_zero_buffer</a> (const float *)</td></tr>
<tr class="separator:a71f8a2d3f072a52c969811d205c36cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fca28bde5e075699d3186d40e4a54ae"><td class="memItemLeft" align="right" valign="top">static float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Row.html#a3fca28bde5e075699d3186d40e4a54ae">junk_buffer</a> (unsigned size)</td></tr>
<tr class="separator:a3fca28bde5e075699d3186d40e4a54ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ac9d22b110b724211d946d911ecacdf64"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac9d22b110b724211d946d911ecacdf64"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Cache</b></td></tr>
<tr class="separator:ac9d22b110b724211d946d911ecacdf64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f7d7cc29058111423c71b7dce79c985"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Row.html#a2f7d7cc29058111423c71b7dce79c985">operator&lt;&lt;</a> (std::ostream &amp;, const <a class="el" href="classDD_1_1Image_1_1Row.html">Row</a> &amp;)</td></tr>
<tr class="separator:a2f7d7cc29058111423c71b7dce79c985"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains a read-write buffer of pixels representing a set of channels for a single horizontal line in an image. This is the standard method of passing image data around in DDImage.</p>
<p>A <a class="el" href="classDD_1_1Image_1_1Row.html">Row</a> acts like an array of 32 arrays of float pixel values, one for each possible channel. Each of these "buffers" can be indexed by X position. Only the locations greater or equal to a "left" position and less than a "right" position are legal, this range is set by the constructor or by the <a class="el" href="classDD_1_1Image_1_1Row.html#aa559e2c6ae27884d1793fc5018c22bbf">range()</a> or <a class="el" href="classDD_1_1Image_1_1Row.html#a69fdee8cfde095c4e2d5ef8d9789f98a">offset()</a> methods. (the stored pointer is offset from the allocated memory block by -left and the memory block is at least right-left long).</p>
<p>The normal method of putting data into a <a class="el" href="classDD_1_1Image_1_1Row.html">Row</a> is to call one of the <a class="el" href="classDD_1_1Image_1_1Row.html#a9532a1d8c8abd73908ba13234f29135e">get()</a> functions. You can also call <a class="el" href="classDD_1_1Image_1_1Row.html#aa4a0b479b306e1faf25c71a54eaa087c">writable()</a> to get a pointer to write to, or use <a class="el" href="classDD_1_1Image_1_1Row.html#a051c26ae09058cc00b24cb98b7ba38b2">erase()</a> or <a class="el" href="classDD_1_1Image_1_1Row.html#a472bb4fcfe91abc3f57530d86d0c7675">copy()</a>.</p>
<p>A great deal of code is dedicated to allowing the buffers to be shared between <a class="el" href="classDD_1_1Image_1_1Row.html">Row</a>, <a class="el" href="classDD_1_1Image_1_1Interest.html">Interest</a>, caches, and local arrays, to avoid the expense of allocating them and especially of copying them. Each buffer may either be owned by the <a class="el" href="classDD_1_1Image_1_1Row.html">Row</a> (in which case it is writable and it is deleted when the <a class="el" href="classDD_1_1Image_1_1Row.html">Row</a> is destroyed), or it can be a read-only pointer to another piece of memory. Rows and other objects can copy the pointers from each other and can also transfer the "write" ownership of a buffer between them.</p>
<p>Notice that getting your data into a <a class="el" href="classDD_1_1Image_1_1Row.html">Row</a> and then looking at it is <em>enormously</em> faster than calling <a class="el" href="classDD_1_1Image_1_1Iop.html#a7b4ab95fc1ad9a99c27c6f19652d58b8">Iop::at()</a>. You should do this if at all possible. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a294f173d27b8c3592086e85ee252bde1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Row::Row </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a <a class="el" href="classDD_1_1Image_1_1Row.html">Row</a> where the legal range of horizontal indexes is x &gt;= X and x &lt; R. No buffers are allocated and attempts to index them without calling <a class="el" href="classDD_1_1Image_1_1Row.html#aa4a0b479b306e1faf25c71a54eaa087c">writable()</a> first are undefined. </p>

</div>
</div>
<a class="anchor" id="a8cc0869c91dc94ee595069309ba15690"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Row::~Row </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The destructor does <a class="el" href="classDD_1_1Image_1_1Row.html#a7a1f7039e90b7ad34134abec843bdb11">release()</a> and deletes any buffers allocated by <a class="el" href="classDD_1_1Image_1_1Row.html#aa4a0b479b306e1faf25c71a54eaa087c">writable()</a>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a7a1f7039e90b7ad34134abec843bdb11"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Row::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Rows may have pointers directly into <a class="el" href="classDD_1_1Image_1_1Iop.html" title="Iop is the base class for all the image operators. ">Iop</a> caches, where they increment a reference count to lock the data into the cache. However this reference count is ignored when caches are cleared or deleted, so it is vital that you get rid of these pointers before this happens (which is when invalidate() is called on an <a class="el" href="classDD_1_1Image_1_1Iop.html" title="Iop is the base class for all the image operators. ">Iop</a>).</p>
<p>This is usually done by the <a class="el" href="classDD_1_1Image_1_1Row.html">Row</a> destructor but if you want to keep the row around for some reason, you can call this. </p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Iop.html#ab1903d94f8e04ca446968ba731b074bb">DD::Image::Iop::get()</a>.</p>

</div>
</div>
<a class="anchor" id="a248131b283859d1fa6037f396acf5545"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Row::holdsCacheLine </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks whether row has a pointer to an <a class="el" href="classDD_1_1Image_1_1Iop.html" title="Iop is the base class for all the image operators. ">Iop</a> cache. </p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Iop.html#ab1903d94f8e04ca446968ba731b074bb">DD::Image::Iop::get()</a>.</p>

</div>
</div>
<a class="anchor" id="a68926c14799d88f8a77080210b0f75f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Row::setCacheLine </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; CacheLineUnlockGuard &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>guard</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the pointer to an <a class="el" href="classDD_1_1Image_1_1Iop.html" title="Iop is the base class for all the image operators. ">Iop</a> cache. This is for internal use and should not be used. </p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Iop.html#ab1903d94f8e04ca446968ba731b074bb">DD::Image::Iop::get()</a>.</p>

</div>
</div>
<a class="anchor" id="aa559e2c6ae27884d1793fc5018c22bbf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Row::range </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the <a class="el" href="classDD_1_1Image_1_1Row.html">Row</a> to contain at least the horizontal range X..R. The actual range will be the <em>union</em> of the range passed to the constructor, and all calls to <a class="el" href="classDD_1_1Image_1_1Row.html#aa559e2c6ae27884d1793fc5018c22bbf">range()</a> since then.</p>
<p>This is useful if <a class="el" href="classDD_1_1Image_1_1Iop.html#a9cceff1fd9ac712c3c08dbfefdafe5d6">Iop::engine()</a> would like to write pixels outside the x,r range passed to it. Without this call, writing these pixels could crash because that memory may not be allocated.</p>
<p>An example of such an <a class="el" href="classDD_1_1Image_1_1Iop.html" title="Iop is the base class for all the image operators. ">Iop</a> is file readers which need to decompress starting at pixel zero. It is far easier and faster to write the decompressor so it can store all the pixels as it calculates them, rather than having to test each to see if it is in range. So most such file readers call range(0,width) and then write the entire width.</p>
<p>Because callers typically reuse rows for multiple requests, the reallocated buffers and larger size will likely be preserved for the next call. This means that much less memory allocation and freeing will be done than it looks like this does.</p>
<p><em>WARNING: this will (possibly) free all buffers. Any pointers returned by [z] or by <a class="el" href="classDD_1_1Image_1_1Row.html#aa4a0b479b306e1faf25c71a54eaa087c">writable()</a> are no longer valid.</em></p>
<p>See also the <a class="el" href="classDD_1_1Image_1_1Row.html#a69fdee8cfde095c4e2d5ef8d9789f98a">offset()</a> function, which does not free buffers, but can only change the range to a new one of the same length. </p>

<p>References <a class="el" href="DDMath_8h.html#ac3079625bb4cfcaf71c637124d8c19ed">MAX()</a>, and <a class="el" href="DDMath_8h.html#a9ba27a1522ba5f04dc07525d721ee159">MIN()</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Read.html#ab0412c85718fa73304c849d006248d01">DD::Image::Read::engine()</a>, and <a class="el" href="classDD_1_1Image_1_1Iop.html#ab1903d94f8e04ca446968ba731b074bb">DD::Image::Iop::get()</a>.</p>

</div>
</div>
<a class="anchor" id="a69fdee8cfde095c4e2d5ef8d9789f98a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Row::offset </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>delta</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Move all the data and the left/right range of the row right by <em>delta</em>. This can be used to horizontally shift data without copying it.</p>
<p>If the <a class="el" href="classDD_1_1Image_1_1Row.html">Row</a> does not belong to you, you must restore the shift by calling this with -delta before returning.</p>
<p>This can be used by an operator that horizontally shifts an image, for instance the Position operator does this (dx and dy contain the translation in pixels):</p>
<div class="fragment"><div class="line">row.offset(-dx);</div>
<div class="line">row.get(input0(), Y-dy, X-dx, R-dx, channels);</div>
<div class="line">row.offset(dx);</div>
</div><!-- fragment --> 
<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Iop.html#ab1903d94f8e04ca446968ba731b074bb">DD::Image::Iop::get()</a>.</p>

</div>
</div>
<a class="anchor" id="a62272de0e2e35ed266e66b68d092f780"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Row::write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceDD_1_1Image.html#a51fc415b5f1d266eed9ef420b3e0142d">Channel</a>&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>You can make a <a class="el" href="classDD_1_1Image_1_1Row.html">Row</a> write to your own allocated memory by calling this. The area from buffer[left] to buffer[right-1] (where left and right are the current range of the <a class="el" href="classDD_1_1Image_1_1Row.html">Row</a>) must exist and it must stay around until after the <a class="el" href="classDD_1_1Image_1_1Row.html">Row</a> is destroyed.</p>
<p>There is no guarantee that the buffer will be written to, Iops may just change the pointer to caches, zeros, or other data. You should check if row[z]==buffer and if not you want to copy the data from row[z]+x to row[z]+r to buffer+x. </p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Row.html#a88ce6607fa1df9f174bc08e2fda01f18">pre_copy()</a>.</p>

</div>
</div>
<a class="anchor" id="a4119ab82ae22e0c8cadf39a7eddec680"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Row::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceDD_1_1Image.html#a51fc415b5f1d266eed9ef420b3e0142d">Channel</a>&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>You can make a <a class="el" href="classDD_1_1Image_1_1Row.html">Row</a> read from your own allocated memory by calling this. The area from buffer[left] to buffer[right-1] (where left and right are the current range of the <a class="el" href="classDD_1_1Image_1_1Row.html">Row</a>) must exist and it must stay around at least until the <a class="el" href="classDD_1_1Image_1_1Row.html">Row</a> is destroyed. </p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Iop.html#ab1903d94f8e04ca446968ba731b074bb">DD::Image::Iop::get()</a>.</p>

</div>
</div>
<a class="anchor" id="abc58365bf54ff0b4e280521c21cdcf5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DD::Image::Row::mFnDeprecatedInNuke13 </td>
          <td>(</td>
          <td class="paramtype">&quot;setPreallocatedWriteBuffer(<a class="el" href="namespaceDD_1_1Image.html#a51fc415b5f1d266eed9ef420b3e0142d">Channel</a>, float*) has been deprecated. Use <a class="el" href="classDD_1_1Image_1_1Row.html#a62272de0e2e35ed266e66b68d092f780">write</a>(<a class="el" href="namespaceDD_1_1Image.html#a51fc415b5f1d266eed9ef420b3e0142d">Channel</a>, float*) instead.\n&quot;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>You can give this <a class="el" href="classDD_1_1Image_1_1Row.html">Row</a> a pointer to your own preallocated memory without setting the row as writable. If/when <a class="el" href="classDD_1_1Image_1_1Row.html#aa4a0b479b306e1faf25c71a54eaa087c">writable()</a> is then called on the row, instead of calling allocate() to create new writable memory, the pointer provided here will be used instead. </p>

</div>
</div>
<a class="anchor" id="a03f0fc6fc9e2c40228797df969feb9ce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ReadablePtr DD::Image::Row::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceDD_1_1Image.html#a51fc415b5f1d266eed9ef420b3e0142d">Channel</a>&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a pointer to the pixel at x == 0 in channel <em>z</em>.</p>
<p>Only the region of this buffer between the X and R passed to the constructor actually exists. Indexing outside that area will produce garbage or a core dump. If this channel has not been requested with <a class="el" href="classDD_1_1Image_1_1Row.html#a9532a1d8c8abd73908ba13234f29135e">get()</a> or <a class="el" href="classDD_1_1Image_1_1Row.html#aa4a0b479b306e1faf25c71a54eaa087c">writable()</a> the returned value is garbage.</p>
<p>To access an arbitrary pixel at channel z, horizontal position x, call <code>row[z][x]</code>. For maximum speed it is best to use a local pointer with <code>const float* IN = row[z]+x</code> and then increment it across the row. </p>

</div>
</div>
<a class="anchor" id="aa4a0b479b306e1faf25c71a54eaa087c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Row::WritablePtr Row::writable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceDD_1_1Image.html#a51fc415b5f1d266eed9ef420b3e0142d">Channel</a>&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a pointer to pixel at x == 0 in channel <em>z</em>, this pointer points at memory that may be written. If the current buffer is not writable, it is thrown away and a buffer is allocated.</p>
<p>Converting a row to writable <em>does not preserve the contents</em>. However you can assume that multiple calls to <a class="el" href="classDD_1_1Image_1_1Row.html#aa4a0b479b306e1faf25c71a54eaa087c">writable()</a> will return the same pointer.</p>
<p>You can only write to the region between the X and R passed to the constructor. Writing outside that area is a sure way to get a core dump!</p>
<p>If z is Chan_Black then a pointer is returned to the shared <a class="el" href="classDD_1_1Image_1_1Row.html#a3fca28bde5e075699d3186d40e4a54ae">junk_buffer()</a>, where you can safely dispose of your data without having to put a test for Chan_Black into your code. However all operators and threads share this buffer so you cannot rely on the data staying unchanged after you store it, this is a write-only buffer! </p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Row.html#a472bb4fcfe91abc3f57530d86d0c7675">copy()</a>, <a class="el" href="classDD_1_1Image_1_1Render.html#addce74cc03baad7bf43ab970725335e2">DD::Image::Render::draw_primitives()</a>, <a class="el" href="classDD_1_1Image_1_1Material.html#a4908ef8d9716d3080746606214dbd2ec">DD::Image::Material::engine()</a>, <a class="el" href="classDD_1_1Image_1_1Write.html#a1e59898a002f04415e495aaf0b5ad162">DD::Image::Write::engine()</a>, <a class="el" href="classDD_1_1Image_1_1Read.html#ab0412c85718fa73304c849d006248d01">DD::Image::Read::engine()</a>, <a class="el" href="classDD_1_1Image_1_1Iop.html#ab1903d94f8e04ca446968ba731b074bb">DD::Image::Iop::get()</a>, <a class="el" href="classDD_1_1Image_1_1ImagePlane.html#a08d6afaf590b1b5d7315cf81372f07b7">DD::Image::ImagePlane::getRow()</a>, and <a class="el" href="classDD_1_1Image_1_1DrawIop.html#a451d857f14e82128b72f571696e38460">DD::Image::DrawIop::pixel_engine()</a>.</p>

</div>
</div>
<a class="anchor" id="a8cb35804cc4235ff18aadacc13b1a59d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Row::WritablePtr Row::writableConstant </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceDD_1_1Image.html#a51fc415b5f1d266eed9ef420b3e0142d">Channel</a>&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Utility function. Allocate a buffer at channel <em>z</em> where all the values are set to <em>val</em>. Otherwise behaves exactly the same as <a class="el" href="classDD_1_1Image_1_1Row.html#aa4a0b479b306e1faf25c71a54eaa087c">writable()</a>. </p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Read.html#ab0412c85718fa73304c849d006248d01">DD::Image::Read::engine()</a>.</p>

</div>
</div>
<a class="anchor" id="a88ce6607fa1df9f174bc08e2fda01f18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Row::pre_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceDD_1_1Image.html#a51fc415b5f1d266eed9ef420b3e0142d">Channel</a>&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDD_1_1Image_1_1Row.html">Row</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceDD_1_1Image.html#a51fc415b5f1d266eed9ef420b3e0142d">Channel</a>&#160;</td>
          <td class="paramname"><em>source_channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set things up so a later <a class="el" href="classDD_1_1Image_1_1Row.html#a472bb4fcfe91abc3f57530d86d0c7675">copy()</a> with the same arguments may run a lot faster.</p>
<p>This is done by modifying <em>source</em> to share buffer pointers with this <a class="el" href="classDD_1_1Image_1_1Row.html">Row</a>. This is a hack: you must not do any calls to <em>this</em> <a class="el" href="classDD_1_1Image_1_1Row.html">Row</a> other than the matching <a class="el" href="classDD_1_1Image_1_1Row.html#a472bb4fcfe91abc3f57530d86d0c7675">copy()</a> until <em>source</em> is deleted. Any attempt to use this <a class="el" href="classDD_1_1Image_1_1Row.html">Row</a> may cause some buffers to be freed and then the <em>source</em> row will be pointing at freed memory.</p>
<p>The arguments are exactly like <a class="el" href="classDD_1_1Image_1_1Row.html#a472bb4fcfe91abc3f57530d86d0c7675">copy()</a> and you call this method on the <em>destination</em> row, even though it really modifies the source row. This was done so that you can easily duplicate the arguments to <a class="el" href="classDD_1_1Image_1_1Row.html#a472bb4fcfe91abc3f57530d86d0c7675">copy()</a> when making this function. See <a class="el" href="classDD_1_1Image_1_1Row.html#a472bb4fcfe91abc3f57530d86d0c7675">copy()</a> for descriptions of the arguments.</p>
<p>Sample usage: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> MyIop::engine(<span class="keywordtype">int</span> y, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> r, ChannelMask channels, Row&amp; out) {</div>
<div class="line">ChannelSet achannels = channels; achannels &amp;= (copied_channels);</div>
<div class="line">ChannelSet bchannels = channels; bchannels -= (copied_channels);</div>
<div class="line">Row arow(x,r);</div>
<div class="line">out.pre_copy(arow, uncooked);</div>
<div class="line">arow.get(input1(), y, x, r, achannels);</div>
<div class="line">out.get(input0(), y, x, r, bchannels);</div>
<div class="line">out.copy(arow, uncooked, x, r);</div>
<div class="line">}</div>
</div><!-- fragment --> 
<p>References <a class="el" href="classDD_1_1Image_1_1Row.html#a62272de0e2e35ed266e66b68d092f780">write()</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Write.html#a1e59898a002f04415e495aaf0b5ad162">DD::Image::Write::engine()</a>, and <a class="el" href="classDD_1_1Image_1_1DrawIop.html#a451d857f14e82128b72f571696e38460">DD::Image::DrawIop::pixel_engine()</a>.</p>

</div>
</div>
<a class="anchor" id="a472bb4fcfe91abc3f57530d86d0c7675"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Row::copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceDD_1_1Image.html#a51fc415b5f1d266eed9ef420b3e0142d">Channel</a>&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDD_1_1Image_1_1Row.html">Row</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceDD_1_1Image.html#a51fc415b5f1d266eed9ef420b3e0142d">Channel</a>&#160;</td>
          <td class="paramname"><em>source_channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy a channel from the <em>source</em> <a class="el" href="classDD_1_1Image_1_1Row.html">Row</a> to this row.</p>
<p>WARNING: <em>X</em> and <em>R</em> indicate what region you <em>require</em> to be copied, but more than that may be copied! This is not a merge! To merge data, you must copy the pixels yourself.</p>
<p>Calling <a class="el" href="classDD_1_1Image_1_1Row.html#a88ce6607fa1df9f174bc08e2fda01f18">pre_copy()</a> with the same arguments before filling the source row can greatly speed this up by allowing an already-existing output buffer to be shared. In this case the copy may already be done and this will return immediately. </p>

<p>References <a class="el" href="classDD_1_1Image_1_1Row.html#a051c26ae09058cc00b24cb98b7ba38b2">erase()</a>, and <a class="el" href="classDD_1_1Image_1_1Row.html#aa4a0b479b306e1faf25c71a54eaa087c">writable()</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Row.html#a42d08e14bd60cc101f3b53d35b37c276">copy()</a>, <a class="el" href="classDD_1_1Image_1_1Render.html#addce74cc03baad7bf43ab970725335e2">DD::Image::Render::draw_primitives()</a>, <a class="el" href="classDD_1_1Image_1_1Write.html#a1e59898a002f04415e495aaf0b5ad162">DD::Image::Write::engine()</a>, and <a class="el" href="classDD_1_1Image_1_1DrawIop.html#a451d857f14e82128b72f571696e38460">DD::Image::DrawIop::pixel_engine()</a>.</p>

</div>
</div>
<a class="anchor" id="a4ab4a998dc51e8be64072903fec02a94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Row::pre_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDD_1_1Image_1_1Row.html">Row</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ChannelMask&#160;</td>
          <td class="paramname"><em>channels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set things up so a later <a class="el" href="classDD_1_1Image_1_1Row.html#a472bb4fcfe91abc3f57530d86d0c7675">copy()</a> with the same arguments may run a lot faster.</p>
<p>This is the same as calling pre_copy(z,source,z) for all the given channels. </p>

<p>References <a class="el" href="classDD_1_1Image_1_1Row.html#a62272de0e2e35ed266e66b68d092f780">write()</a>.</p>

</div>
</div>
<a class="anchor" id="a42d08e14bd60cc101f3b53d35b37c276"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Row::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDD_1_1Image_1_1Row.html">Row</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ChannelMask&#160;</td>
          <td class="paramname"><em>channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as "foreach(z,channels) copy(z, source, z, x, r)" but this may be faster. </p>

<p>References <a class="el" href="classDD_1_1Image_1_1Row.html#a472bb4fcfe91abc3f57530d86d0c7675">copy()</a>.</p>

</div>
</div>
<a class="anchor" id="a9532a1d8c8abd73908ba13234f29135e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Row::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDD_1_1Image_1_1Iop.html">Iop</a> &amp;&#160;</td>
          <td class="paramname"><em>iop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ChannelMask&#160;</td>
          <td class="paramname"><em>channels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For back compatibility only, this is the same as doing iop.get(y, x, r, channels, this); </p>

<p>References <a class="el" href="classDD_1_1Image_1_1Iop.html#ab1903d94f8e04ca446968ba731b074bb">DD::Image::Iop::get()</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Iop.html#a81446bbe6c0a31b5d12e61b339c377e5">DD::Image::Iop::doFetchPlane()</a>, <a class="el" href="classDD_1_1Image_1_1Material.html#a4908ef8d9716d3080746606214dbd2ec">DD::Image::Material::engine()</a>, and <a class="el" href="classDD_1_1Image_1_1PlanarIop.html#aea141834c4333e0887074f2a79183535">DD::Image::PlanarIop::engine()</a>.</p>

</div>
</div>
<a class="anchor" id="a1a7bfcb57b9ab8c6b416fc62b20c7cd0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const float * Row::zero_buffer </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an array containing at least <em>size</em> 0.0 values. This can be used as a source of zeros in an algorithim that does not want the overhead of checking whether a pointer is null or not. It is also used by the <a class="el" href="classDD_1_1Image_1_1Row.html#a051c26ae09058cc00b24cb98b7ba38b2">erase()</a> method and pointers are checked against the return values for the is_zero() method. </p>

</div>
</div>
<a class="anchor" id="a71f8a2d3f072a52c969811d205c36cce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Row::is_zero_buffer </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if <em>array</em> is equal to one of the return values from <a class="el" href="classDD_1_1Image_1_1Row.html#a1a7bfcb57b9ab8c6b416fc62b20c7cd0">zero_buffer()</a>. </p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Row.html#acdde82e893cefa592d752d076405aa48">is_zero()</a>.</p>

</div>
</div>
<a class="anchor" id="a3fca28bde5e075699d3186d40e4a54ae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float * Row::junk_buffer </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an array containing at least <em>size</em> locations you can write to. This can be used as a "data sink" for algorithims that produce data that might be ignored. A pointer to this is returned when writable(Chan_Black) is called. </p>

</div>
</div>
<a class="anchor" id="a051c26ae09058cc00b24cb98b7ba38b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Row::erase </td>
          <td>(</td>
          <td class="paramtype">ChannelMask&#160;</td>
          <td class="paramname"><em>channels</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear the channels to zero. This is done by changing the pointer to point at <a class="el" href="classDD_1_1Image_1_1Row.html#a1a7bfcb57b9ab8c6b416fc62b20c7cd0">zero_buffer()</a>. This will make the is_zero() test return true. </p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Row.html#a472bb4fcfe91abc3f57530d86d0c7675">copy()</a>, <a class="el" href="classDD_1_1Image_1_1Render.html#addce74cc03baad7bf43ab970725335e2">DD::Image::Render::draw_primitives()</a>, <a class="el" href="classDD_1_1Image_1_1Write.html#a1e59898a002f04415e495aaf0b5ad162">DD::Image::Write::engine()</a>, <a class="el" href="classDD_1_1Image_1_1Read.html#ab0412c85718fa73304c849d006248d01">DD::Image::Read::engine()</a>, <a class="el" href="classDD_1_1Image_1_1Iop.html#ab1903d94f8e04ca446968ba731b074bb">DD::Image::Iop::get()</a>, <a class="el" href="classDD_1_1Image_1_1ImagePlane.html#a08d6afaf590b1b5d7315cf81372f07b7">DD::Image::ImagePlane::getRow()</a>, and <a class="el" href="classDD_1_1Image_1_1DrawIop.html#a451d857f14e82128b72f571696e38460">DD::Image::DrawIop::pixel_engine()</a>.</p>

</div>
</div>
<a class="anchor" id="ac781583144b07d43eec3d90d959ec0ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Row::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceDD_1_1Image.html#a51fc415b5f1d266eed9ef420b3e0142d">Channel</a>&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear the entire channel to zero. This is done by changing the pointer to point at <a class="el" href="classDD_1_1Image_1_1Row.html#a1a7bfcb57b9ab8c6b416fc62b20c7cd0">zero_buffer()</a>. This makes the is_zero() test return true. </p>

</div>
</div>
<a class="anchor" id="acdde82e893cefa592d752d076405aa48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Row::is_zero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceDD_1_1Image.html#a51fc415b5f1d266eed9ef420b3e0142d">Channel</a>&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fast test to see if all of the given channel is zero. This will return true if <a class="el" href="classDD_1_1Image_1_1Row.html#a051c26ae09058cc00b24cb98b7ba38b2">erase()</a> was called, or if other code such as caches has detected that the row is entirely zero. </p>

<p>References <a class="el" href="classDD_1_1Image_1_1Row.html#a71f8a2d3f072a52c969811d205c36cce">is_zero_buffer()</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a2f7d7cc29058111423c71b7dce79c985"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDD_1_1Image_1_1Row.html">Row</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Not implemented in the library but you can define it. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<br>
<hr>
<table width="100%"  border="0" cellspacing="0" cellpadding="0">
  <tr>
    <td><span class="legal">&copy;2022 The Foundry Visionmongers, Ltd.  All Rights Reserved. </span></td>
    <td><div align="right"><span class="legal"><a href="http://www.thefoundry.co.uk" target="_blank">www.thefoundry.co.uk</a></span></div></td>
  </tr>
</table>
</body>
</html>
