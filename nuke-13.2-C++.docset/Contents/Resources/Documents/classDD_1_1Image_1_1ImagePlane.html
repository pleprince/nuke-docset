<html><head><link href="doxygen.css" rel="stylesheet" type="text/css">
<title>Nuke Developer Kit (NDK) 13.2.4: DD::Image::ImagePlane Class Reference</title></head><body>
<!-- Generated by Doxygen 1.8.10 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classDD_1_1Image_1_1ImagePlane.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classDD_1_1Image_1_1ImagePlane-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">DD::Image::ImagePlane Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Inherits <a class="el" href="classDD_1_1Image_1_1ImagePlaneDescriptor.html">DD::Image::ImagePlaneDescriptor</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7c87d8b259313d04cdeef057c7e3594e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c87d8b259313d04cdeef057c7e3594e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1ImagePlane.html#a7c87d8b259313d04cdeef057c7e3594e">ImagePlane</a> (const <a class="el" href="classDD_1_1Image_1_1Box.html">DD::Image::Box</a> &amp;bounds, bool packed, <a class="el" href="classDD_1_1Image_1_1ChannelSet.html">DD::Image::ChannelSet</a> mask, int nComps)</td></tr>
<tr class="memdesc:a7c87d8b259313d04cdeef057c7e3594e"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct based upon bounds, packedness, mask and number of compenents <br /></td></tr>
<tr class="separator:a7c87d8b259313d04cdeef057c7e3594e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c21e5d401c1d14a5f27580b695a6411"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c21e5d401c1d14a5f27580b695a6411"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1ImagePlane.html#a6c21e5d401c1d14a5f27580b695a6411">ImagePlane</a> (const <a class="el" href="classDD_1_1Image_1_1Box.html">DD::Image::Box</a> &amp;bounds, bool packed, <a class="el" href="classDD_1_1Image_1_1ChannelSet.html">DD::Image::ChannelSet</a> mask)</td></tr>
<tr class="memdesc:a6c21e5d401c1d14a5f27580b695a6411"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct based upon bounds, packedness, mask and number of components <br /></td></tr>
<tr class="separator:a6c21e5d401c1d14a5f27580b695a6411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f0d8a14752caca1e9cfa2f3e8fa3df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab9f0d8a14752caca1e9cfa2f3e8fa3df"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1ImagePlane.html#ab9f0d8a14752caca1e9cfa2f3e8fa3df">ImagePlane</a> (const <a class="el" href="classDD_1_1Image_1_1ImagePlane.html">ImagePlane</a> &amp;ip)</td></tr>
<tr class="memdesc:ab9f0d8a14752caca1e9cfa2f3e8fa3df"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy construct <br /></td></tr>
<tr class="separator:ab9f0d8a14752caca1e9cfa2f3e8fa3df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0854090ea64bb66894b9ff2510d6a5d9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0854090ea64bb66894b9ff2510d6a5d9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1ImagePlane.html#a0854090ea64bb66894b9ff2510d6a5d9">ImagePlane</a> (const <a class="el" href="classDD_1_1Image_1_1Box.html">DD::Image::Box</a> &amp;bounds)</td></tr>
<tr class="memdesc:a0854090ea64bb66894b9ff2510d6a5d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct based upon BBox. <br /></td></tr>
<tr class="separator:a0854090ea64bb66894b9ff2510d6a5d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a978662ec67b298c9a01d3740bb817e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a978662ec67b298c9a01d3740bb817e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1ImagePlane.html#a2a978662ec67b298c9a01d3740bb817e">ImagePlane</a> ()</td></tr>
<tr class="memdesc:a2a978662ec67b298c9a01d3740bb817e"><td class="mdescLeft">&#160;</td><td class="mdescRight">empty constructor <br /></td></tr>
<tr class="separator:a2a978662ec67b298c9a01d3740bb817e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac38359f72f744c0981b04b9236a8d5fb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac38359f72f744c0981b04b9236a8d5fb"></a>
<a class="el" href="classDD_1_1Image_1_1ImagePlane.html">ImagePlane</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classDD_1_1Image_1_1ImagePlane.html">ImagePlane</a> &amp;ip)</td></tr>
<tr class="separator:ac38359f72f744c0981b04b9236a8d5fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad66e413372cd5d959593287c5e0aecb9"><td class="memItemLeft" align="right" valign="top">float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1ImagePlane.html#ad66e413372cd5d959593287c5e0aecb9">writable</a> ()</td></tr>
<tr class="separator:ad66e413372cd5d959593287c5e0aecb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12c29b625095c0a800b26bc8d37f32cb"><td class="memItemLeft" align="right" valign="top">const float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1ImagePlane.html#a12c29b625095c0a800b26bc8d37f32cb">readable</a> () const </td></tr>
<tr class="separator:a12c29b625095c0a800b26bc8d37f32cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a540301e5a0e079f1fd6b563739edbbec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1ImagePlane.html#a540301e5a0e079f1fd6b563739edbbec">makeWritable</a> (size_t alignment=0)</td></tr>
<tr class="separator:a540301e5a0e079f1fd6b563739edbbec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd48d51e00597aa19d8734b871a4394"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9dd48d51e00597aa19d8734b871a4394"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1ImagePlane.html#a9dd48d51e00597aa19d8734b871a4394">makeUnique</a> ()</td></tr>
<tr class="memdesc:a9dd48d51e00597aa19d8734b871a4394"><td class="mdescLeft">&#160;</td><td class="mdescRight">make the buffer unique - copy the underlying data if this has more than one reference <br /></td></tr>
<tr class="separator:a9dd48d51e00597aa19d8734b871a4394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12cf6814f3a3d03d85f5117b8ab18e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1ImagePlane.html#ad12cf6814f3a3d03d85f5117b8ab18e5">copyIntersectionFrom</a> (const <a class="el" href="classDD_1_1Image_1_1ImagePlane.html">ImagePlane</a> &amp;other, bool forceDeep=false)</td></tr>
<tr class="separator:ad12cf6814f3a3d03d85f5117b8ab18e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a829ef02623eed22a5044ceaee149c09b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1ImagePlane.html#a829ef02623eed22a5044ceaee149c09b">chanNo</a> (<a class="el" href="namespaceDD_1_1Image.html#a51fc415b5f1d266eed9ef420b3e0142d">Channel</a> z) const </td></tr>
<tr class="separator:a829ef02623eed22a5044ceaee149c09b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81f88276363a95eb6491c9bcb44d1108"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a81f88276363a95eb6491c9bcb44d1108"></a>
const float &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1ImagePlane.html#a81f88276363a95eb6491c9bcb44d1108">at</a> (int x, int y, int z) const </td></tr>
<tr class="memdesc:a81f88276363a95eb6491c9bcb44d1108"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a reference to the data at (x, y) with the channel number /z/. <br /></td></tr>
<tr class="separator:a81f88276363a95eb6491c9bcb44d1108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03efdbb1b905e1185419dac182eace1e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a03efdbb1b905e1185419dac182eace1e"></a>
const float &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>at</b> (int x, int y, <a class="el" href="namespaceDD_1_1Image.html#a51fc415b5f1d266eed9ef420b3e0142d">Channel</a> z)</td></tr>
<tr class="separator:a03efdbb1b905e1185419dac182eace1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a848e4150757c065e311751fd76d283e4"><td class="memItemLeft" align="right" valign="top">float &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1ImagePlane.html#a848e4150757c065e311751fd76d283e4">writableAt</a> (int x, int y, int z)</td></tr>
<tr class="separator:a848e4150757c065e311751fd76d283e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa8923c6fd7383c9073d923befe8375"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDD_1_1Image_1_1PtrStridedIterator.html">ImageTilePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1ImagePlane.html#a9fa8923c6fd7383c9073d923befe8375">writableAt</a> (int y, int z)</td></tr>
<tr class="separator:a9fa8923c6fd7383c9073d923befe8375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b07b12567c314d60f50579a3db2b17"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9b07b12567c314d60f50579a3db2b17"></a>
<a class="el" href="structDD_1_1Image_1_1PtrStridedIterator.html">ImageTileReadOnlyPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>readableAt</b> (int y, int z) const </td></tr>
<tr class="separator:af9b07b12567c314d60f50579a3db2b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3401ac2277451e339a024f30e958c87"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1ImagePlane.html#ae3401ac2277451e339a024f30e958c87">colStride</a> () const </td></tr>
<tr class="separator:ae3401ac2277451e339a024f30e958c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a836d833a8d8062cefdec6092fd40e879"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1ImagePlane.html#a836d833a8d8062cefdec6092fd40e879">rowStride</a> () const </td></tr>
<tr class="separator:a836d833a8d8062cefdec6092fd40e879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b2a87fd6f62731165634bf4156a45f1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1ImagePlane.html#a4b2a87fd6f62731165634bf4156a45f1">chanStride</a> () const </td></tr>
<tr class="separator:a4b2a87fd6f62731165634bf4156a45f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d44cff3784d5c26cc4b6b230f9e5628"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d44cff3784d5c26cc4b6b230f9e5628"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>usage</b> () const </td></tr>
<tr class="separator:a5d44cff3784d5c26cc4b6b230f9e5628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0987492b625a8673868551c2cfaf34e6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0987492b625a8673868551c2cfaf34e6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="separator:a0987492b625a8673868551c2cfaf34e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50a3c08ad743b60c58a5b8afe1100845"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50a3c08ad743b60c58a5b8afe1100845"></a>
const <a class="el" href="classDD_1_1Image_1_1RefCountedFloatBuffer.html">RefCountedFloatBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>memory</b> () const </td></tr>
<tr class="separator:a50a3c08ad743b60c58a5b8afe1100845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51cd4506cbd005da29250201c8dfc681"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a51cd4506cbd005da29250201c8dfc681"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setMemory</b> (<a class="el" href="classDD_1_1Image_1_1RefCountedFloatBuffer.html">RefCountedFloatBuffer</a> &amp;memory)</td></tr>
<tr class="separator:a51cd4506cbd005da29250201c8dfc681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e94d9bc41525056ec31ae515176209"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a75e94d9bc41525056ec31ae515176209"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1ImagePlane.html#a75e94d9bc41525056ec31ae515176209">fillChannel</a> (<a class="el" href="namespaceDD_1_1Image.html#a51fc415b5f1d266eed9ef420b3e0142d">Channel</a> z, float value)</td></tr>
<tr class="memdesc:a75e94d9bc41525056ec31ae515176209"><td class="mdescLeft">&#160;</td><td class="mdescRight">fill a channel with /value/ <br /></td></tr>
<tr class="separator:a75e94d9bc41525056ec31ae515176209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cee33b33f768d86de3ca60a911af9ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1ImagePlane.html#a0cee33b33f768d86de3ca60a911af9ef">fillChannelThreaded</a> (<a class="el" href="namespaceDD_1_1Image.html#a51fc415b5f1d266eed9ef420b3e0142d">Channel</a> z, float value, unsigned int numThreads=0)</td></tr>
<tr class="separator:a0cee33b33f768d86de3ca60a911af9ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad58f7a57a9b3e3998b08d8ca8254db"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ad58f7a57a9b3e3998b08d8ca8254db"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1ImagePlane.html#a4ad58f7a57a9b3e3998b08d8ca8254db">copyChannel</a> (<a class="el" href="namespaceDD_1_1Image.html#a51fc415b5f1d266eed9ef420b3e0142d">Channel</a> dst, <a class="el" href="namespaceDD_1_1Image.html#a51fc415b5f1d266eed9ef420b3e0142d">Channel</a> src)</td></tr>
<tr class="memdesc:a4ad58f7a57a9b3e3998b08d8ca8254db"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy channel /src/ into /dst/ <br /></td></tr>
<tr class="separator:a4ad58f7a57a9b3e3998b08d8ca8254db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08d6afaf590b1b5d7315cf81372f07b7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a08d6afaf590b1b5d7315cf81372f07b7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1ImagePlane.html#a08d6afaf590b1b5d7315cf81372f07b7">getRow</a> (int y, int x, int r, DD::Image::ChannelMask m, <a class="el" href="classDD_1_1Image_1_1Row.html">DD::Image::Row</a> &amp;row, bool customChannels)</td></tr>
<tr class="memdesc:a08d6afaf590b1b5d7315cf81372f07b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a row into the <a class="el" href="namespaceDD.html" title="Private support functions for OpHints. ">DD</a> scanline <br /></td></tr>
<tr class="separator:a08d6afaf590b1b5d7315cf81372f07b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classDD_1_1Image_1_1ImagePlaneDescriptor"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classDD_1_1Image_1_1ImagePlaneDescriptor')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classDD_1_1Image_1_1ImagePlaneDescriptor.html">DD::Image::ImagePlaneDescriptor</a></td></tr>
<tr class="memitem:a2e0d31cfeb0e26218e2c5ce67963be10 inherit pub_methods_classDD_1_1Image_1_1ImagePlaneDescriptor"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e0d31cfeb0e26218e2c5ce67963be10"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ImagePlaneDescriptor</b> (const <a class="el" href="classDD_1_1Image_1_1Box.html">DD::Image::Box</a> &amp;bounds, bool packed, <a class="el" href="classDD_1_1Image_1_1ChannelSet.html">DD::Image::ChannelSet</a> mask, int nComps)</td></tr>
<tr class="separator:a2e0d31cfeb0e26218e2c5ce67963be10 inherit pub_methods_classDD_1_1Image_1_1ImagePlaneDescriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d406ad2b08b67cf4d4871538e736eb3 inherit pub_methods_classDD_1_1Image_1_1ImagePlaneDescriptor"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d406ad2b08b67cf4d4871538e736eb3"></a>
<a class="el" href="classDD_1_1Image_1_1Box.html">DD::Image::Box</a>&#160;</td><td class="memItemRight" valign="bottom"><b>bounds</b> () const </td></tr>
<tr class="separator:a3d406ad2b08b67cf4d4871538e736eb3 inherit pub_methods_classDD_1_1Image_1_1ImagePlaneDescriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f4efa8079b4efdecede21aa7f4d6be0 inherit pub_methods_classDD_1_1Image_1_1ImagePlaneDescriptor"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f4efa8079b4efdecede21aa7f4d6be0"></a>
<a class="el" href="classDD_1_1Image_1_1ChannelSet.html">ChannelSet</a>&#160;</td><td class="memItemRight" valign="bottom"><b>channels</b> () const </td></tr>
<tr class="separator:a0f4efa8079b4efdecede21aa7f4d6be0 inherit pub_methods_classDD_1_1Image_1_1ImagePlaneDescriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a9a937f47b5dedc8a22ee7a56bec705 inherit pub_methods_classDD_1_1Image_1_1ImagePlaneDescriptor"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a9a937f47b5dedc8a22ee7a56bec705"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>packed</b> () const </td></tr>
<tr class="separator:a8a9a937f47b5dedc8a22ee7a56bec705 inherit pub_methods_classDD_1_1Image_1_1ImagePlaneDescriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d8969ba130b02e11a68fddba286353 inherit pub_methods_classDD_1_1Image_1_1ImagePlaneDescriptor"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9d8969ba130b02e11a68fddba286353"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>nComps</b> () const </td></tr>
<tr class="separator:ad9d8969ba130b02e11a68fddba286353 inherit pub_methods_classDD_1_1Image_1_1ImagePlaneDescriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9384fd0528579899d58e6e9069e5b5d4 inherit pub_methods_classDD_1_1Image_1_1ImagePlaneDescriptor"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1ImagePlaneDescriptor.html#a9384fd0528579899d58e6e9069e5b5d4">intersects</a> (const <a class="el" href="classDD_1_1Image_1_1ImagePlaneDescriptor.html">ImagePlaneDescriptor</a> &amp;other) const </td></tr>
<tr class="separator:a9384fd0528579899d58e6e9069e5b5d4 inherit pub_methods_classDD_1_1Image_1_1ImagePlaneDescriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9400e6a41ac8512ee4015ea60e04f495 inherit pub_methods_classDD_1_1Image_1_1ImagePlaneDescriptor"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9400e6a41ac8512ee4015ea60e04f495"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>intersects</b> (int y, int t) const </td></tr>
<tr class="separator:a9400e6a41ac8512ee4015ea60e04f495 inherit pub_methods_classDD_1_1Image_1_1ImagePlaneDescriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e92c69406baeca98954fbbb9a6925f5 inherit pub_methods_classDD_1_1Image_1_1ImagePlaneDescriptor"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e92c69406baeca98954fbbb9a6925f5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>satisfiedBy</b> (const <a class="el" href="classDD_1_1Image_1_1ImagePlaneDescriptor.html">ImagePlaneDescriptor</a> &amp;candidate)</td></tr>
<tr class="separator:a4e92c69406baeca98954fbbb9a6925f5 inherit pub_methods_classDD_1_1Image_1_1ImagePlaneDescriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:af2aaf0a2ca9045c0c98a0696db5bbb2b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2aaf0a2ca9045c0c98a0696db5bbb2b"></a>
<a class="el" href="classDD_1_1Image_1_1RefCountedFloatBuffer.html">RefCountedFloatBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>buffer</b> (int x, int y) const </td></tr>
<tr class="separator:af2aaf0a2ca9045c0c98a0696db5bbb2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aaa868ce62da507e650fcc56513e41b97"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa868ce62da507e650fcc56513e41b97"></a>
<a class="el" href="classDD_1_1Image_1_1RefCountedFloatBuffer.html">RefCountedFloatBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>_data</b></td></tr>
<tr class="separator:aaa868ce62da507e650fcc56513e41b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classDD_1_1Image_1_1ImagePlaneDescriptor"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classDD_1_1Image_1_1ImagePlaneDescriptor')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classDD_1_1Image_1_1ImagePlaneDescriptor.html">DD::Image::ImagePlaneDescriptor</a></td></tr>
<tr class="memitem:aafbd51018f809d2732faae012e666bd6 inherit pro_attribs_classDD_1_1Image_1_1ImagePlaneDescriptor"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aafbd51018f809d2732faae012e666bd6"></a>
<a class="el" href="classDD_1_1Image_1_1Box.html">DD::Image::Box</a>&#160;</td><td class="memItemRight" valign="bottom"><b>_bounds</b></td></tr>
<tr class="separator:aafbd51018f809d2732faae012e666bd6 inherit pro_attribs_classDD_1_1Image_1_1ImagePlaneDescriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ab48abf2c1596165faea7e63faabb5e inherit pro_attribs_classDD_1_1Image_1_1ImagePlaneDescriptor"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ab48abf2c1596165faea7e63faabb5e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>_packed</b></td></tr>
<tr class="separator:a7ab48abf2c1596165faea7e63faabb5e inherit pro_attribs_classDD_1_1Image_1_1ImagePlaneDescriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d12b5aab8fbb6bbfacb92954f8e7b7 inherit pro_attribs_classDD_1_1Image_1_1ImagePlaneDescriptor"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a49d12b5aab8fbb6bbfacb92954f8e7b7"></a>
<a class="el" href="classDD_1_1Image_1_1ChannelSet.html">ChannelSet</a>&#160;</td><td class="memItemRight" valign="bottom"><b>_mask</b></td></tr>
<tr class="separator:a49d12b5aab8fbb6bbfacb92954f8e7b7 inherit pro_attribs_classDD_1_1Image_1_1ImagePlaneDescriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a6f96d990c6400de678d21f6b26420f inherit pro_attribs_classDD_1_1Image_1_1ImagePlaneDescriptor"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4a6f96d990c6400de678d21f6b26420f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>_nComps</b></td></tr>
<tr class="separator:a4a6f96d990c6400de678d21f6b26420f inherit pro_attribs_classDD_1_1Image_1_1ImagePlaneDescriptor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class that represents an <a class="el" href="classDD_1_1Image_1_1ImagePlane.html">ImagePlane</a>. ImagePlanes can be of any size, have any set of channels.</p>
<p>The data is a reference-counted float buffer consisting of contiguous pixel data for the defined bounding box and channels.</p>
<p>This is a relatively low-level class intended for code that interfaces with external code and has to operate in a particular. More complex mechanisms can be built upon this. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ad66e413372cd5d959593287c5e0aecb9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float* DD::Image::ImagePlane::writable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocate data if needed and return a non-const pointer to it. The pointer is to element (x, y, z), where x = bounds().x(), y = bounds().y() and z is the lowest Channel in channels() </p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Iop.html#a81446bbe6c0a31b5d12e61b339c377e5">DD::Image::Iop::doFetchPlane()</a>.</p>

</div>
</div>
<a class="anchor" id="a12c29b625095c0a800b26bc8d37f32cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const float* DD::Image::ImagePlane::readable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>return a non-const pointer to the data. The pointer is to element (x, y, z), where x = bounds().x(), y = bounds().y() and z is the lowest Channel in channels() </p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1ImagePlane.html#ad12cf6814f3a3d03d85f5117b8ab18e5">copyIntersectionFrom()</a>, <a class="el" href="classDD_1_1Image_1_1ImagePlane.html#a08d6afaf590b1b5d7315cf81372f07b7">getRow()</a>, and <a class="el" href="classDD_1_1Image_1_1GeneralTile.html#ace35c36a8b85cc842b683749e7e65173">DD::Image::GeneralTile::load_range()</a>.</p>

</div>
</div>
<a class="anchor" id="a540301e5a0e079f1fd6b563739edbbec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DD::Image::ImagePlane::makeWritable </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>alignment</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>allocate data if needed. This locks the image plane to make sure only one thread will try to allocate the data buffer. Optionally align memory (also rounds up allocated amount to multiple of alignment) </p>

<p>References <a class="el" href="classDD_1_1Image_1_1RefCountedFloatBuffer.html#a9446c78606d82bf2d3967862967fe4de">DD::Image::RefCountedFloatBuffer::allocate()</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1PlanarIop.html#a464b14c2bde6968967d4dcc986829390">DD::Image::PlanarIop::doFetchPlane()</a>, <a class="el" href="classDD_1_1Image_1_1ImagePlane.html#a9dd48d51e00597aa19d8734b871a4394">makeUnique()</a>, and <a class="el" href="classDD_1_1Image_1_1Read.html#a1526566b46bd57e0c67d01f410d86c72">DD::Image::Read::renderStripe()</a>.</p>

</div>
</div>
<a class="anchor" id="ad12cf6814f3a3d03d85f5117b8ab18e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DD::Image::ImagePlane::copyIntersectionFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDD_1_1Image_1_1ImagePlane.html">ImagePlane</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forceDeep</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>copy the intersection in channels and bbox from the other plane to this one in the most efficient way possible. Note that this may involve a pointer copy rather than a memory copy if the intersection is a subset of the other plane (or identical to it); unless forceDeep is set to true, in which case it will always do a deep copy.</p>
<p>Allocates memory if needed, is (and preferred) valid to call it without having called <a class="el" href="classDD_1_1Image_1_1ImagePlane.html#ad66e413372cd5d959593287c5e0aecb9">writable()</a>. </p>

<p>References <a class="el" href="classDD_1_1Image_1_1Box.html#af0539577992b61a3c6fe8ca117200b4d">DD::Image::Box::r()</a>, <a class="el" href="classDD_1_1Image_1_1ImagePlane.html#a12c29b625095c0a800b26bc8d37f32cb">readable()</a>, <a class="el" href="classDD_1_1Image_1_1ChannelSet.html#ad7abaca740fd33f5f970f7c6cc315b33">DD::Image::ChannelSet::size()</a>, <a class="el" href="classDD_1_1Image_1_1Box.html#acac26badb7370442785b675e6e1b9d2c">DD::Image::Box::t()</a>, <a class="el" href="classDD_1_1Image_1_1Box.html#a0c774d50942dd7a5be89cd58dd15bcef">DD::Image::Box::x()</a>, and <a class="el" href="classDD_1_1Image_1_1Box.html#a68df2eb73868b705b33b1d0b4638320f">DD::Image::Box::y()</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1PlanarIop.html#a464b14c2bde6968967d4dcc986829390">DD::Image::PlanarIop::doFetchPlane()</a>, and <a class="el" href="classDD_1_1Image_1_1ImagePlane.html#a9dd48d51e00597aa19d8734b871a4394">makeUnique()</a>.</p>

</div>
</div>
<a class="anchor" id="a829ef02623eed22a5044ceaee149c09b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int DD::Image::ImagePlane::chanNo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceDD_1_1Image.html#a51fc415b5f1d266eed9ef420b3e0142d">Channel</a>&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>find out the index within this plane for the given Channel. E.g. a Mask_RGBA plane will have Chan_Red = 0, Chan_Green = 1, Chan_Blue = 2, Chan_Alpha = 3, but a Mask_Green | Mask_Alpha plane will have Chan_Green = 0 and Chan_Alpha = 1.</p>
<p>Returns -1 if the channel is not present. This is the value that is passed as the last parameter of <a class="el" href="classDD_1_1Image_1_1ImagePlane.html#a81f88276363a95eb6491c9bcb44d1108" title="get a reference to the data at (x, y) with the channel number /z/. ">at()</a> and would be multiplied by the <a class="el" href="classDD_1_1Image_1_1ImagePlane.html#a4b2a87fd6f62731165634bf4156a45f1">chanStride()</a>. </p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1GeneralTile.html#a1a21eb0c7e17c3378180f9832747aa44">DD::Image::GeneralTile::at()</a>, <a class="el" href="classDD_1_1Image_1_1ImagePlane.html#a4ad58f7a57a9b3e3998b08d8ca8254db">copyChannel()</a>, and <a class="el" href="classDD_1_1Image_1_1ImagePlane.html#a08d6afaf590b1b5d7315cf81372f07b7">getRow()</a>.</p>

</div>
</div>
<a class="anchor" id="a848e4150757c065e311751fd76d283e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float&amp; DD::Image::ImagePlane::writableAt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>get a writable reference to the data at (x, y) with the channel number /z/. you need to have called <a class="el" href="classDD_1_1Image_1_1ImagePlane.html#a540301e5a0e079f1fd6b563739edbbec">makeWritable()</a> or similar first. </p>

</div>
</div>
<a class="anchor" id="a9fa8923c6fd7383c9073d923befe8375"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDD_1_1Image_1_1PtrStridedIterator.html">ImageTilePtr</a> DD::Image::ImagePlane::writableAt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>get a writable ImageTilePtr pointing at the data at (0, y) with the channel number /z/. Like <a class="el" href="classDD_1_1Image_1_1Row.html#a03f0fc6fc9e2c40228797df969feb9ce">Row::operator[]</a> and <a class="el" href="classDD_1_1Image_1_1Row.html#aa4a0b479b306e1faf25c71a54eaa087c">Row::writable()</a> you must always have add the horizontal offset before deferencing this pointer.</p>
<p>you need to have called <a class="el" href="classDD_1_1Image_1_1ImagePlane.html#a540301e5a0e079f1fd6b563739edbbec">makeWritable()</a> or similar first. </p>

</div>
</div>
<a class="anchor" id="ae3401ac2277451e339a024f30e958c87"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int DD::Image::ImagePlane::colStride </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>get the stride between columns. Is the number of channels for packed planes. For unpacked planes is 1. </p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1ImagePlane.html#a4ad58f7a57a9b3e3998b08d8ca8254db">copyChannel()</a>, and <a class="el" href="classDD_1_1Image_1_1ImagePlane.html#a08d6afaf590b1b5d7315cf81372f07b7">getRow()</a>.</p>

</div>
</div>
<a class="anchor" id="a836d833a8d8062cefdec6092fd40e879"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int DD::Image::ImagePlane::rowStride </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>return the stride between rows. Is the number of channels times the width for packed planes. For unpacked planes is the width. </p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Iop.html#a81446bbe6c0a31b5d12e61b339c377e5">DD::Image::Iop::doFetchPlane()</a>.</p>

</div>
</div>
<a class="anchor" id="a4b2a87fd6f62731165634bf4156a45f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int DD::Image::ImagePlane::chanStride </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>return the stride between channels. Is 1 for packed planes. For unpacked planes is the width times the height. </p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1ImagePlane.html#a4ad58f7a57a9b3e3998b08d8ca8254db">copyChannel()</a>, and <a class="el" href="classDD_1_1Image_1_1Iop.html#a81446bbe6c0a31b5d12e61b339c377e5">DD::Image::Iop::doFetchPlane()</a>.</p>

</div>
</div>
<a class="anchor" id="a0cee33b33f768d86de3ca60a911af9ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DD::Image::ImagePlane::fillChannelThreaded </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceDD_1_1Image.html#a51fc415b5f1d266eed9ef420b3e0142d">Channel</a>&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>numThreads</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>fill a channel with /value/ (using multiple threads). /numThreads/ specifies the number of threads to use. Setting /numThreads/ to 0 lets the function decide on the number of threads to use. </p>

<p>References <a class="el" href="classDD_1_1Image_1_1Thread.html#a719f4fef8ea2dc5252d2e7c213c72fbe">DD::Image::Thread::numThreads</a>, <a class="el" href="classDD_1_1Image_1_1Thread.html#aec337e4db467fd486ef2c0bf50c3e8bb">DD::Image::Thread::spawn()</a>, and <a class="el" href="classDD_1_1Image_1_1Thread.html#aecec2849e23dbc85f01fabf8b9f40b65">DD::Image::Thread::wait()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<br>
<hr>
<table width="100%"  border="0" cellspacing="0" cellpadding="0">
  <tr>
    <td><span class="legal">&copy;2022 The Foundry Visionmongers, Ltd.  All Rights Reserved. </span></td>
    <td><div align="right"><span class="legal"><a href="http://www.thefoundry.co.uk" target="_blank">www.thefoundry.co.uk</a></span></div></td>
  </tr>
</table>
</body>
</html>
