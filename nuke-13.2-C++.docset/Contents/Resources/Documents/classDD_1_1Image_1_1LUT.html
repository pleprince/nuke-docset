<html><head><link href="doxygen.css" rel="stylesheet" type="text/css">
<title>Nuke Developer Kit (NDK) 13.2.4: DD::Image::LUT Class Reference</title></head><body>
<!-- Generated by Doxygen 1.8.10 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classDD_1_1Image_1_1LUT.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classDD_1_1Image_1_1LUT-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">DD::Image::LUT Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Inherited by AlexaV3LogC_LUT_Class, ArriLogC4_LUT_Class, BlackMagicGEN5_LUT_Class, Cineon_LUT_Class, CLog_LUT_Class, Gamma_LUT_Class, HybridLogGamma_LUT_Class, Linear_LUT_Class, Log3G10_LUT_Class, Log3G12_LUT_Class, Panalog_LUT_Class, PLogLin_LUT_Class, Protune_LUT_Class, rec709_LUT_Class, REDLog_LUT_Class, SLog1_LUT_Class, SLog2_LUT_Class, SLog3_LUT_Class, SLog_LUT_Class, sRGB_LUT_Class, ST2084_LUT_Class, and ViperLog_LUT_Class.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a89bd73fe4b8988c93e84940f4672a248"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a89bd73fe4b8988c93e84940f4672a248"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>DataType</b> { <br />
&#160;&#160;<b>INVALID</b>, 
<b>MONITOR</b>, 
<b>VIEWER</b>, 
<b>INT8</b>, 
<br />
&#160;&#160;<b>INT16</b>, 
<b>LOG</b>, 
<b>FLOAT</b>, 
<b>GAMMA1_8</b>, 
<br />
&#160;&#160;<b>GAMMA2_2</b>, 
<b>GAMMA2_4</b>, 
<b>PANALOG</b>, 
<b>REDLOG</b>, 
<br />
&#160;&#160;<b>VIPERLOG</b>, 
<b>ALEXAV3LOGC</b>, 
<b>PLOGLIN</b>, 
<b>SLOG</b>, 
<br />
&#160;&#160;<b>SLOG1</b>, 
<b>SLOG2</b>, 
<b>SLOG3</b>, 
<b>CLOG</b>, 
<br />
&#160;&#160;<b>PROTUNE</b>, 
<b>GAMMA2_6</b>, 
<b>LOG3G10</b>, 
<b>LOG3G12</b>, 
<br />
&#160;&#160;<b>BT1886</b>, 
<b>HDR2084</b>, 
<b>HYBRIDLOGGAMMA</b>, 
<b>ST2084</b>, 
<br />
&#160;&#160;<b>BLACKMAGIC_GEN5</b>, 
<b>ARRILOGC4</b>, 
<b>TYPES_END</b>
<br />
 }<tr class="separator:a89bd73fe4b8988c93e84940f4672a248"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:a1fa41c9a5d69b9b7ef03d952e0b1bd17"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1fa41c9a5d69b9b7ef03d952e0b1bd17"></a>
typedef int&#160;</td><td class="memItemRight" valign="bottom"><b>BuiltinLUTId</b></td></tr>
<tr class="separator:a1fa41c9a5d69b9b7ef03d952e0b1bd17"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6d026313921ab0cb94c9f5a53a0d079d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1LUT.html#a6d026313921ab0cb94c9f5a53a0d079d">isToTableValid</a> () const </td></tr>
<tr class="separator:a6d026313921ab0cb94c9f5a53a0d079d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d1b1e7fab5fb7086b436d35afc3b921"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1LUT.html#a2d1b1e7fab5fb7086b436d35afc3b921">test</a> (float) const </td></tr>
<tr class="separator:a2d1b1e7fab5fb7086b436d35afc3b921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae95ee40f7e235832c711189eb1525fad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1LUT.html#ae95ee40f7e235832c711189eb1525fad">linear</a> () const </td></tr>
<tr class="separator:ae95ee40f7e235832c711189eb1525fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a886ca4e6e700fe7b16e8493b40b14"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1LUT.html#a57a886ca4e6e700fe7b16e8493b40b14">zero</a> () const </td></tr>
<tr class="separator:a57a886ca4e6e700fe7b16e8493b40b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9527690c8af9ce1149b3b0a50995de8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1LUT.html#ad9527690c8af9ce1149b3b0a50995de8">append</a> (<a class="el" href="classDD_1_1Image_1_1Hash.html">Hash</a> &amp;) const </td></tr>
<tr class="separator:ad9527690c8af9ce1149b3b0a50995de8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af26aa68ab7b07d286d49c8c802fdfa0a"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1LUT.html#af26aa68ab7b07d286d49c8c802fdfa0a">to_byte</a> (float) const  =0</td></tr>
<tr class="separator:af26aa68ab7b07d286d49c8c802fdfa0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f56dcb93eae730e90510e5e2cde8cdf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1LUT.html#a1f56dcb93eae730e90510e5e2cde8cdf">to_byte</a> (uchar *, const float *, int W, int delta=1) const </td></tr>
<tr class="separator:a1f56dcb93eae730e90510e5e2cde8cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1e6f43ddafeeb86de1c17f18815f84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1LUT.html#a7d1e6f43ddafeeb86de1c17f18815f84">to_byte</a> (uchar *, const float *, const float *alpha, int W, int delta=1) const </td></tr>
<tr class="separator:a7d1e6f43ddafeeb86de1c17f18815f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95eddbaf9dacfeeddcfaf202b428f732"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1LUT.html#a95eddbaf9dacfeeddcfaf202b428f732">to_short</a> (U16 *, const float *, int W, int bits=16, int delta=1) const </td></tr>
<tr class="separator:a95eddbaf9dacfeeddcfaf202b428f732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8adcf31d1dd8c56445145373bc58b42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1LUT.html#ac8adcf31d1dd8c56445145373bc58b42">to_short</a> (U16 *, const float *, const float *alpha, int W, int bits=16, int delta=1) const </td></tr>
<tr class="separator:ac8adcf31d1dd8c56445145373bc58b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8af775715589edbaa122a56e734da0e6"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1LUT.html#a8af775715589edbaa122a56e734da0e6">from_byte</a> (float) const  =0</td></tr>
<tr class="separator:a8af775715589edbaa122a56e734da0e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75899333338f00490f188fe319358fb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1LUT.html#a75899333338f00490f188fe319358fb6">from_byte</a> (float *, const uchar *, int W, int delta=1) const </td></tr>
<tr class="separator:a75899333338f00490f188fe319358fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6af02323e697b4cab6910f3b73180a5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1LUT.html#a6af02323e697b4cab6910f3b73180a5c">from_byte</a> (float *, const uchar *, const uchar *alpha, int W, int delta=1) const </td></tr>
<tr class="separator:a6af02323e697b4cab6910f3b73180a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49bb64e7153540b1f3662f0497a52123"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1LUT.html#a49bb64e7153540b1f3662f0497a52123">from_short</a> (float *, const U16 *, int W, int bits=16, int delta=1) const </td></tr>
<tr class="separator:a49bb64e7153540b1f3662f0497a52123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5278d057b08296e315bd09a4508cd14c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1LUT.html#a5278d057b08296e315bd09a4508cd14c">from_short</a> (float *, const U16 *, const U16 *alpha, int W, int bits=16, int delta=1) const </td></tr>
<tr class="separator:a5278d057b08296e315bd09a4508cd14c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66d77e4706ab7af1295ebe06cfd077c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1LUT.html#a66d77e4706ab7af1295ebe06cfd077c2">to_float</a> (float *, const float *, int W, int delta=1) const </td></tr>
<tr class="separator:a66d77e4706ab7af1295ebe06cfd077c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ac50f635e0a9cfa355015c5a1ae0b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1LUT.html#a24ac50f635e0a9cfa355015c5a1ae0b5">to_float</a> (float *, const float *, const float *alpha, int W, int delta=1) const </td></tr>
<tr class="separator:a24ac50f635e0a9cfa355015c5a1ae0b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eb90c945a282709fd0667bfd5a1063a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1LUT.html#a1eb90c945a282709fd0667bfd5a1063a">from_float</a> (float *, const float *, int W, int delta=1) const </td></tr>
<tr class="separator:a1eb90c945a282709fd0667bfd5a1063a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeefc23327b8f6a8657531f086db56480"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1LUT.html#aeefc23327b8f6a8657531f086db56480">from_float</a> (float *, const float *, const float *alpha, int W, int delta=1) const </td></tr>
<tr class="separator:aeefc23327b8f6a8657531f086db56480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa1d88b5f8e79f8e393efb4950005ea"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1LUT.html#a1aa1d88b5f8e79f8e393efb4950005ea">fromFloat</a> (float v) const </td></tr>
<tr class="separator:a1aa1d88b5f8e79f8e393efb4950005ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a842afc011e23df8a753bb0618724cbfa"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1LUT.html#a842afc011e23df8a753bb0618724cbfa">fromFloatFast</a> (float v) const </td></tr>
<tr class="separator:a842afc011e23df8a753bb0618724cbfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a2bc62170d9f8ec6486c50038ff881"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1LUT.html#af8a2bc62170d9f8ec6486c50038ff881">toFloat</a> (float v) const </td></tr>
<tr class="separator:af8a2bc62170d9f8ec6486c50038ff881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa38cfcdd85a6da7b7e6894666443d9fe"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1LUT.html#aa38cfcdd85a6da7b7e6894666443d9fe">toFloatFast</a> (float v) const </td></tr>
<tr class="separator:aa38cfcdd85a6da7b7e6894666443d9fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a97ac218bcf99a5f547e701150da2d035"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classDD_1_1Image_1_1LUT.html">LUT</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1LUT.html#a97ac218bcf99a5f547e701150da2d035">Linear</a> ()</td></tr>
<tr class="separator:a97ac218bcf99a5f547e701150da2d035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70db1dbbdfb82fbc25517a75579125c2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70db1dbbdfb82fbc25517a75579125c2"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>setBuiltin</b> (BuiltinLUTId n, const char *name, <a class="el" href="classDD_1_1Image_1_1LUT.html">LUT</a> *lut)</td></tr>
<tr class="separator:a70db1dbbdfb82fbc25517a75579125c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1515fabc24a45ef763a8eb34ed2f901b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classDD_1_1Image_1_1LUT.html">LUT</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1LUT.html#a1515fabc24a45ef763a8eb34ed2f901b">GetBuiltinLUT</a> (BuiltinLUTId id)</td></tr>
<tr class="separator:a1515fabc24a45ef763a8eb34ed2f901b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeaafd989c64819eca178dffa73cd4cb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classDD_1_1Image_1_1LUT.html">LUT</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1LUT.html#aeeaafd989c64819eca178dffa73cd4cb">GetBuiltinLutByName</a> (const char *name)</td></tr>
<tr class="separator:aeeaafd989c64819eca178dffa73cd4cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5978a2b7be5bff9d2576115a98021d55"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5978a2b7be5bff9d2576115a98021d55"></a>
static <a class="el" href="classDD_1_1Image_1_1LUT.html">LUT</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>Builtin</b> (BuiltinLUTId n, <a class="el" href="classDD_1_1Image_1_1Reader.html">Reader</a> *)</td></tr>
<tr class="separator:a5978a2b7be5bff9d2576115a98021d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade4d74301f852fc43d12b0cb11031724"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade4d74301f852fc43d12b0cb11031724"></a>
static <a class="el" href="classDD_1_1Image_1_1LUT.html">LUT</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>Builtin</b> (const char *name, <a class="el" href="classDD_1_1Image_1_1Reader.html">Reader</a> *)</td></tr>
<tr class="separator:ade4d74301f852fc43d12b0cb11031724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd0342baa500aaf45f7508ef08868a0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3cd0342baa500aaf45f7508ef08868a0"></a>
static <a class="el" href="classDD_1_1Image_1_1LUT.html">LUT</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>Builtin</b> (BuiltinLUTId n, <a class="el" href="classDD_1_1Image_1_1Writer.html">Writer</a> *)</td></tr>
<tr class="separator:a3cd0342baa500aaf45f7508ef08868a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36f25c9366ce5d7ac053971677608021"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a36f25c9366ce5d7ac053971677608021"></a>
static <a class="el" href="classDD_1_1Image_1_1LUT.html">LUT</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>Builtin</b> (const char *name, <a class="el" href="classDD_1_1Image_1_1Writer.html">Writer</a> *)</td></tr>
<tr class="separator:a36f25c9366ce5d7ac053971677608021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e027537f028d56d1f827a2fa8c3c79"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1LUT.html#a29e027537f028d56d1f827a2fa8c3c79">append</a> (BuiltinLUTId n, <a class="el" href="classDD_1_1Image_1_1Hash.html">Hash</a> &amp;)</td></tr>
<tr class="separator:a29e027537f028d56d1f827a2fa8c3c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab36716c4a96984f1fa2088a3d7e95f0e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classDD_1_1Image_1_1LUT.html">LUT</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1LUT.html#ab36716c4a96984f1fa2088a3d7e95f0e">GetDefaultLutForType</a> (DataType)</td></tr>
<tr class="separator:ab36716c4a96984f1fa2088a3d7e95f0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a817807e27519d24aa2cb7def44da8847"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a817807e27519d24aa2cb7def44da8847"></a>
static <a class="el" href="classDD_1_1Image_1_1LUT.html">LUT</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetLut</b> (DataType, const <a class="el" href="classDD_1_1Image_1_1Reader.html">Reader</a> *)</td></tr>
<tr class="separator:a817807e27519d24aa2cb7def44da8847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c3e193b91b3bd705794fc580039020"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16c3e193b91b3bd705794fc580039020"></a>
static <a class="el" href="classDD_1_1Image_1_1LUT.html">LUT</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetLut</b> (DataType, const <a class="el" href="classDD_1_1Image_1_1Writer.html">Writer</a> *)</td></tr>
<tr class="separator:a16c3e193b91b3bd705794fc580039020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49e3a2a110c309bfeb3161d41aa429ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a49e3a2a110c309bfeb3161d41aa429ea"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>SetLut</b> (DataType, <a class="el" href="classDD_1_1Image_1_1LUT.html">LUT</a> *)</td></tr>
<tr class="separator:a49e3a2a110c309bfeb3161d41aa429ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcc39dfb938ec532b90a5df938346740"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afcc39dfb938ec532b90a5df938346740"></a>
static <a class="el" href="classDD_1_1Image_1_1LUT.html">LUT</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>sRGB</b> ()</td></tr>
<tr class="separator:afcc39dfb938ec532b90a5df938346740"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a4693982bba102eefca109d745e3af639"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1LUT.html#a4693982bba102eefca109d745e3af639">builtin_names</a> []</td></tr>
<tr class="separator:a4693982bba102eefca109d745e3af639"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a076b895d1d4a26e4f930dfcebfb1b84b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1LUT.html#a076b895d1d4a26e4f930dfcebfb1b84b">fillToTable</a> () const </td></tr>
<tr class="separator:a076b895d1d4a26e4f930dfcebfb1b84b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34da6768663cc1b135522b5a8888d7d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1LUT.html#a34da6768663cc1b135522b5a8888d7d0">fillFromTable</a> ()</td></tr>
<tr class="separator:a34da6768663cc1b135522b5a8888d7d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdd8fb725fa27a5ebbc3542d95ae0660"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1LUT.html#acdd8fb725fa27a5ebbc3542d95ae0660">validate</a> ()</td></tr>
<tr class="separator:acdd8fb725fa27a5ebbc3542d95ae0660"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:abe2938af2b7431824a1865f850b63d67"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe2938af2b7431824a1865f850b63d67"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>InitialiseBuiltin</b> (BuiltinLUTId id)</td></tr>
<tr class="separator:abe2938af2b7431824a1865f850b63d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a9697a931eacfb293115f9c731e541976"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9697a931eacfb293115f9c731e541976"></a>
<a class="el" href="classDD_1_1Image_1_1Hash.html">Hash</a>&#160;</td><td class="memItemRight" valign="bottom"><b>hash</b></td></tr>
<tr class="separator:a9697a931eacfb293115f9c731e541976"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A <a class="el" href="classDD_1_1Image_1_1LUT.html">LUT</a> defines a mapping function. One side is the floating point numbers used in Nuke. The other side (the side it goes "to" and "from") is generally values that are used in a file or by a piece of hardware.</p>
<p>The <a class="el" href="classDD_1_1Image_1_1LUT.html">LUT</a> class can very quickly convert between an array of floating point number in Nuke and arrays of 8 bit or 16 bit numbers. It can also convert float&lt;-&gt;float and may be faster depending on the complexity of the function. All this is done by using lookup tables and linear interpolation between the table entries. When converting to integers, error diffusion is used to hide posterization.</p>
<p>Any subclass must implement <a class="el" href="classDD_1_1Image_1_1LUT.html#af26aa68ab7b07d286d49c8c802fdfa0a">to_byte()</a> and <a class="el" href="classDD_1_1Image_1_1LUT.html#a8af775715589edbaa122a56e734da0e6">from_byte()</a>. For historical reasons these convert to the range 0..255 rather than 0..1.</p>
<p>There is also the pseudo-subclass <a class="el" href="classDD_1_1Image_1_1Linear.html">Linear</a>, which has the same API but does straight line transfer only, avoiding the if statement used to detect this in the <a class="el" href="classDD_1_1Image_1_1LUT.html">LUT</a> class functions. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a076b895d1d4a26e4f930dfcebfb1b84b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LUT::fillToTable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fill in the table used by <a class="el" href="classDD_1_1Image_1_1LUT.html#aa38cfcdd85a6da7b7e6894666443d9fe">toFloatFast()</a> and thus by all the to functions. This is done by calling <a class="el" href="classDD_1_1Image_1_1LUT.html#af26aa68ab7b07d286d49c8c802fdfa0a">to_byte()</a>. This can be used by a <a class="el" href="classDD_1_1Image_1_1LUT.html#a8af775715589edbaa122a56e734da0e6">from_byte()</a> implementation that works by using interpolation to invert the <a class="el" href="classDD_1_1Image_1_1LUT.html#af26aa68ab7b07d286d49c8c802fdfa0a">to_byte()</a> function. Does nothing if called a second time. </p>

<p>References <a class="el" href="DDMath_8h.html#ae8b3324592ffd89dca7d558083667f1f">fast_rint()</a>, <a class="el" href="classDD_1_1Image_1_1LUT.html#ae95ee40f7e235832c711189eb1525fad">linear()</a>, <a class="el" href="classDD_1_1Image_1_1LUT.html#af26aa68ab7b07d286d49c8c802fdfa0a">to_byte()</a>, and <a class="el" href="classDD_1_1Image_1_1LUT.html#a57a886ca4e6e700fe7b16e8493b40b14">zero()</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1LUT.html#a2d1b1e7fab5fb7086b436d35afc3b921">test()</a>, <a class="el" href="classDD_1_1Image_1_1LUT.html#a1f56dcb93eae730e90510e5e2cde8cdf">to_byte()</a>, <a class="el" href="classDD_1_1Image_1_1LUT.html#a66d77e4706ab7af1295ebe06cfd077c2">to_float()</a>, <a class="el" href="classDD_1_1Image_1_1LUT.html#a95eddbaf9dacfeeddcfaf202b428f732">to_short()</a>, and <a class="el" href="classDD_1_1Image_1_1LUT.html#aa38cfcdd85a6da7b7e6894666443d9fe">toFloatFast()</a>.</p>

</div>
</div>
<a class="anchor" id="a34da6768663cc1b135522b5a8888d7d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LUT::fillFromTable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fill in the table used by <a class="el" href="classDD_1_1Image_1_1LUT.html#a842afc011e23df8a753bb0618724cbfa">fromFloatFast()</a> and thus all the from functions. This is done by calling <a class="el" href="classDD_1_1Image_1_1LUT.html#a8af775715589edbaa122a56e734da0e6">from_byte()</a>. This can be used by a <a class="el" href="classDD_1_1Image_1_1LUT.html#af26aa68ab7b07d286d49c8c802fdfa0a">to_byte()</a> implementation taht works by using interpolation to invert the <a class="el" href="classDD_1_1Image_1_1LUT.html#a8af775715589edbaa122a56e734da0e6">from_byte()</a> function. Does nothing if called a second time. </p>

<p>References <a class="el" href="classDD_1_1Image_1_1LUT.html#a8af775715589edbaa122a56e734da0e6">from_byte()</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1LUT.html#acdd8fb725fa27a5ebbc3542d95ae0660">validate()</a>.</p>

</div>
</div>
<a class="anchor" id="acdd8fb725fa27a5ebbc3542d95ae0660"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LUT::validate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Forces <a class="el" href="classDD_1_1Image_1_1LUT.html#a076b895d1d4a26e4f930dfcebfb1b84b">fillToTable()</a> and <a class="el" href="classDD_1_1Image_1_1LUT.html#a34da6768663cc1b135522b5a8888d7d0">fillFromTable()</a> to fill the tables again and calls them, and calculates a value for hash(). The constructor calls this, but subclasses may want to call this directly if the <a class="el" href="classDD_1_1Image_1_1LUT.html">LUT</a> has other controls that can change it's results. </p>

<p>References <a class="el" href="classDD_1_1Image_1_1LUT.html#a34da6768663cc1b135522b5a8888d7d0">fillFromTable()</a>, and <a class="el" href="classDD_1_1Image_1_1Hash.html#a7149aff58da4ef79d32f78f22bddacb1">DD::Image::Hash::reset()</a>.</p>

</div>
</div>
<a class="anchor" id="a6d026313921ab0cb94c9f5a53a0d079d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DD::Image::LUT::isToTableValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the <a class="el" href="classDD_1_1Image_1_1LUT.html">LUT</a> table used by the to functions is valid. It becomes valid after the first time one of the to functions is used. </p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Write.html#ae76f84680bb2d23603e7bc3b32ef0de5">DD::Image::Write::execute()</a>.</p>

</div>
</div>
<a class="anchor" id="a2d1b1e7fab5fb7086b436d35afc3b921"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float LUT::test </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the value that to_byte(uchar...) is being calculated to by the lookup table. </p>

<p>References <a class="el" href="classDD_1_1Image_1_1LUT.html#a076b895d1d4a26e4f930dfcebfb1b84b">fillToTable()</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Write.html#a24b3332f92388c30a53211b413c4a885">DD::Image::Write::_validate()</a>, and <a class="el" href="classDD_1_1Image_1_1Read.html#a1f229ef410d606573a1f23544e6d7a8b">DD::Image::Read::_validate()</a>.</p>

</div>
</div>
<a class="anchor" id="ae95ee40f7e235832c711189eb1525fad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DD::Image::LUT::linear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if to_byte(x) appears to return x*255. This is tested when the table is filled in. If true some operators are much faster. </p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1LUT.html#a076b895d1d4a26e4f930dfcebfb1b84b">fillToTable()</a>, <a class="el" href="classDD_1_1Image_1_1LUT.html#a1eb90c945a282709fd0667bfd5a1063a">from_float()</a>, and <a class="el" href="classDD_1_1Image_1_1LUT.html#a49bb64e7153540b1f3662f0497a52123">from_short()</a>.</p>

</div>
</div>
<a class="anchor" id="a57a886ca4e6e700fe7b16e8493b40b14"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DD::Image::LUT::zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if to_byte(0) returns a value &lt;= 0. This is tested when the table is filled in. If true some operators are much faster. </p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1LUT.html#a076b895d1d4a26e4f930dfcebfb1b84b">fillToTable()</a>.</p>

</div>
</div>
<a class="anchor" id="ad9527690c8af9ce1149b3b0a50995de8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LUT::append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDD_1_1Image_1_1Hash.html">Hash</a> &amp;&#160;</td>
          <td class="paramname"><em>hash</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add the contents of this <a class="el" href="classDD_1_1Image_1_1LUT.html">LUT</a> to the hash. This is pretty fast (it just appends a single internal <a class="el" href="classDD_1_1Image_1_1Hash.html">Hash</a>) because it needs to be called a lot to determine if images have changed. </p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1LUT.html#a29e027537f028d56d1f827a2fa8c3c79">append()</a>.</p>

</div>
</div>
<a class="anchor" id="af26aa68ab7b07d286d49c8c802fdfa0a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float DD::Image::LUT::to_byte </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This virtual function must be overridden to do the math that converts floating point values to byte values in the range 0-255. Notice that you want as accurate as a result as possible, do not round to the nearest integer. <a class="el" href="classDD_1_1Image_1_1LUT.html">LUT</a> assumes that for any values in the range 0-1.0 that this function is the inverse of to_byte(float). </p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1LUT.html#a076b895d1d4a26e4f930dfcebfb1b84b">fillToTable()</a>, and <a class="el" href="classDD_1_1Image_1_1Writer.html#a6c086ab3be86b963b0f65738c72c780f">DD::Image::Writer::to_byte()</a>.</p>

</div>
</div>
<a class="anchor" id="a1f56dcb93eae730e90510e5e2cde8cdf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LUT::to_byte </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>delta</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert an array of floating point pixel values to an array of bytes, with error diffusion. This is very well optimized and quite fast, and is used by the Nuke viewer when drawing it's display.</p>
<p><em>W</em> is the number of pixels to convert.</p>
<p><em>delta</em> is how far apart to put the resulting bytes, allowing you to write to an interlaced buffer.</p>
<p>The input and output buffers must not overlap in memory. </p>

<p>References <a class="el" href="namespaceDD_1_1Image.html#a10d4fc69dd43186166d7796e4cc2fb34">DD::Image::end()</a>, and <a class="el" href="classDD_1_1Image_1_1LUT.html#a076b895d1d4a26e4f930dfcebfb1b84b">fillToTable()</a>.</p>

</div>
</div>
<a class="anchor" id="a7d1e6f43ddafeeb86de1c17f18815f84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LUT::to_byte </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>delta</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert an array of floating point pixel values to an array of bytes, with error diffusion.</p>
<p><em>alpha</em> is the unconverted alpha for a premultiplied image. This is used to correct the premultiply so it matches how premultiply is usually stored on disk (the stored values are the converted values multiplied by the alpha, rather than the linear values multiplied by the alpha. The alpha channel itself should be converted with Linear::to_byte().</p>
<p><em>W</em> is the number of pixels to convert.</p>
<p><em>delta</em> is how far apart to put the resulting bytes, allowing you to write to an interlaced buffer.</p>
<p>The input and output buffers must not overlap in memory. </p>

<p>References <a class="el" href="namespaceDD_1_1Image.html#a10d4fc69dd43186166d7796e4cc2fb34">DD::Image::end()</a>, and <a class="el" href="classDD_1_1Image_1_1LUT.html#a076b895d1d4a26e4f930dfcebfb1b84b">fillToTable()</a>.</p>

</div>
</div>
<a class="anchor" id="a95eddbaf9dacfeeddcfaf202b428f732"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LUT::to_short </td>
          <td>(</td>
          <td class="paramtype">U16 *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bits</em> = <code>16</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>delta</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fill an array of <em>W</em> shorts with n-bit conversion of the floating point pixels. Input values less than zero turn into zero, input values greater than 1 turn into all 1's (even though larger numbers can be represented when bits &lt; 16). See to_byte for how all the other arguments are treated.</p>
<p>Currently no error diffusion is done. </p>

<p>References <a class="el" href="classDD_1_1Image_1_1LUT.html#a076b895d1d4a26e4f930dfcebfb1b84b">fillToTable()</a>, and <a class="el" href="classDD_1_1Image_1_1Linear.html#a349f8f71addc4f5847d468bb8e46ee59">DD::Image::Linear::to_short()</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Writer.html#a151e9f153faa823e94ab5fef41c1f8ad">DD::Image::Writer::to_short()</a>.</p>

</div>
</div>
<a class="anchor" id="ac8adcf31d1dd8c56445145373bc58b42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LUT::to_short </td>
          <td>(</td>
          <td class="paramtype">U16 *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bits</em> = <code>16</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>delta</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fill an array of <em>W</em> shorts with n-bit conversion of the floating point pixels. Input values less than zero turn into zero, input values greater than 1 turn into all 1's (even though larger numbers can be represented when bits &lt; 16). See to_byte for how all the other arguments are treated. </p>

<p>References <a class="el" href="classDD_1_1Image_1_1LUT.html#a076b895d1d4a26e4f930dfcebfb1b84b">fillToTable()</a>, and <a class="el" href="classDD_1_1Image_1_1Linear.html#a349f8f71addc4f5847d468bb8e46ee59">DD::Image::Linear::to_short()</a>.</p>

</div>
</div>
<a class="anchor" id="a8af775715589edbaa122a56e734da0e6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float DD::Image::LUT::from_byte </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This virtual function should be overridden to do the math that converts byte values in the range 0-255 to floating point. <a class="el" href="classDD_1_1Image_1_1LUT.html">LUT</a> assumes that this function is the inverse of to_byte(float). </p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1LUT.html#a34da6768663cc1b135522b5a8888d7d0">fillFromTable()</a>, and <a class="el" href="classDD_1_1Image_1_1Reader.html#a88840f7e58934404af4d0c7c31c5dcbc">DD::Image::Reader::from_byte()</a>.</p>

</div>
</div>
<a class="anchor" id="a75899333338f00490f188fe319358fb6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LUT::from_byte </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>delta</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts bytes through the from_byte(float) virtual function. A 256-entry lookup table filled in by <a class="el" href="classDD_1_1Image_1_1LUT.html#acdd8fb725fa27a5ebbc3542d95ae0660">validate()</a> is used for maximum speed.</p>
<p>The input data is <em>W</em> bytes in the range 0-255 pointed to by <em>from</em>. <em>delta</em> is the distance between the input bytes (for the common case where the input is interlaced rgba samples).</p>
<p>The output is written to the first <em>W</em> floats of <em>buf</em>.</p>
<p>The input and output may be the same memory array as long as <em>delta</em> is less or equal to 4. The conversion is done in backwards order so this is possible. </p>

</div>
</div>
<a class="anchor" id="a6af02323e697b4cab6910f3b73180a5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LUT::from_byte </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>delta</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Similar to the previous <a class="el" href="classDD_1_1Image_1_1LUT.html#a8af775715589edbaa122a56e734da0e6">from_byte()</a> except this divides by the <em>alpha</em> channel then does the conversion, then multiplies by the alpha channel again. This corrects the values for premultiplied pixels in the common case where the renderer multiplied them in 8-bit space rather than in linear light levels. If dividing by the alpha produces a result greater than 1 it assumes it is 1.</p>
<p>The alpha channel should be run through Linear::from_byte() to get the correct alpha channel.</p>
<p><em>delta</em> is assumed to apply to both the <em>from</em> and <em>alpha</em> arrays.</p>
<p>The input, alpha, and output may be the same memory array as long as <em>delta</em> is less or equal to 4. The conversion is done in backwards order so this is possible. </p>

</div>
</div>
<a class="anchor" id="a49bb64e7153540b1f3662f0497a52123"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LUT::from_short </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U16 *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bits</em> = <code>16</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>delta</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts 16-bit data to linear floating point. <em>n</em> 1's is considered 1.0. The resulting floating point numbers are from_byte(255*x/(2^n-1)). The current implementation is not really fast and calls the virtual <a class="el" href="classDD_1_1Image_1_1LUT.html#a8af775715589edbaa122a56e734da0e6">from_byte()</a> function for each sample.</p>
<p>The input data is <em>W</em> 16-bit words pointed to by <em>from</em>. <em>delta</em> is the distance between each (for the common case where the input is interlaced rgba samples).</p>
<p>The output is written to the first <em>W</em> floats of <em>buf</em>.</p>
<p>The input and output may be the same memory array as long as <em>delta</em> is less or equal to 2. The conversion is done in backwards order so this is possible. </p>

<p>References <a class="el" href="classDD_1_1Image_1_1Linear.html#a1b369e491ca6444fab1a552270cd3f89">DD::Image::Linear::from_short()</a>, and <a class="el" href="classDD_1_1Image_1_1LUT.html#ae95ee40f7e235832c711189eb1525fad">linear()</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Reader.html#a46e1e38a580e639649f4c83c47de6e5b">DD::Image::Reader::from_short()</a>.</p>

</div>
</div>
<a class="anchor" id="a5278d057b08296e315bd09a4508cd14c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LUT::from_short </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U16 *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U16 *&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bits</em> = <code>16</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>delta</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Similar to the previous <a class="el" href="classDD_1_1Image_1_1LUT.html#a8af775715589edbaa122a56e734da0e6">from_byte()</a> except this divides by the <em>alpha</em> channel then does the conversion, then multiplies by the alpha channel again. This corrects the values for premultiplied pixels in the common case where the renderer multiplied them in 8-bit space rather than in linear light levels. If dividing by the alpha produces a result greater than 1 it assumes it is 1.</p>
<p>The alpha channel should be run through Linear::from_byte() to get the correct alpha channel.</p>
<p><em>delta</em> is assumed to apply to both the <em>from</em> and <em>alpha</em> arrays.</p>
<p>The input, alpha, and output may be the same memory array as long as <em>delta</em> is less or equal to 2. The conversion is done in backwards order so this is possible. </p>

<p>References <a class="el" href="classDD_1_1Image_1_1Linear.html#a1b369e491ca6444fab1a552270cd3f89">DD::Image::Linear::from_short()</a>, and <a class="el" href="classDD_1_1Image_1_1LUT.html#ae95ee40f7e235832c711189eb1525fad">linear()</a>.</p>

</div>
</div>
<a class="anchor" id="a66d77e4706ab7af1295ebe06cfd077c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LUT::to_float </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>delta</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert an array of <em>W</em> floating-point values by calling <a class="el" href="classDD_1_1Image_1_1LUT.html#aa38cfcdd85a6da7b7e6894666443d9fe">toFloatFast()</a> and write them to <em>to</em> separated by <em>delta</em>. </p>

<p>References <a class="el" href="classDD_1_1Image_1_1LUT.html#a076b895d1d4a26e4f930dfcebfb1b84b">fillToTable()</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Writer.html#aac1a7cf9c7855961f27c9b68c57878ad">DD::Image::Writer::to_float()</a>.</p>

</div>
</div>
<a class="anchor" id="a24ac50f635e0a9cfa355015c5a1ae0b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LUT::to_float </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>delta</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert an array of floating-point values from the 0-1 linear range by calling toFloatFast(x/a)*a where a is the value from the alpha arrays. I.e. unpremultliply by alpha, convert, and then multiply back. </p>

<p>References <a class="el" href="classDD_1_1Image_1_1LUT.html#a076b895d1d4a26e4f930dfcebfb1b84b">fillToTable()</a>.</p>

</div>
</div>
<a class="anchor" id="a1eb90c945a282709fd0667bfd5a1063a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LUT::from_float </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>delta</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert an array of <em>W</em> floating point values separated by <em>delta</em> using <a class="el" href="classDD_1_1Image_1_1LUT.html#a842afc011e23df8a753bb0618724cbfa">fromFloatFast()</a> and write them to <em>dst</em>, separated by 1. <em>src</em> and <em>dst</em> may point to the same memory. </p>

<p>References <a class="el" href="classDD_1_1Image_1_1LUT.html#ae95ee40f7e235832c711189eb1525fad">linear()</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Reader.html#ac78837a3819dd92cecf01af36464a1d7">DD::Image::Reader::from_float()</a>.</p>

</div>
</div>
<a class="anchor" id="aeefc23327b8f6a8657531f086db56480"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LUT::from_float </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>delta</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert using fromFloatFast(x/a)*a, where a is the values from the alpha array. I.e. unpremultiply, convert, then multiply again. <em>src</em> and <em>dst</em> may point to the same memory. </p>

<p>References <a class="el" href="classDD_1_1Image_1_1LUT.html#ae95ee40f7e235832c711189eb1525fad">linear()</a>.</p>

</div>
</div>
<a class="anchor" id="a1aa1d88b5f8e79f8e393efb4950005ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float DD::Image::LUT::fromFloat </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calls from_byte(x*255), and thus converts a single floating point value accurately to linear. This may be slow, see <a class="el" href="classDD_1_1Image_1_1LUT.html#a842afc011e23df8a753bb0618724cbfa">fromFloatFast()</a>. </p>

</div>
</div>
<a class="anchor" id="a842afc011e23df8a753bb0618724cbfa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float LUT::fromFloatFast </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a single floating point value to linear by using the lookup tables. The value is clamped to the 0-1 range as that is the range of the tables! </p>

</div>
</div>
<a class="anchor" id="af8a2bc62170d9f8ec6486c50038ff881"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float DD::Image::LUT::toFloat </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calls to_byte(x)*255, and thus converts a single floating point linear value accurately. This may be slow, see <a class="el" href="classDD_1_1Image_1_1LUT.html#aa38cfcdd85a6da7b7e6894666443d9fe">toFloatFast()</a>. </p>

</div>
</div>
<a class="anchor" id="aa38cfcdd85a6da7b7e6894666443d9fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float LUT::toFloatFast </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a single floating point value from linear to the <a class="el" href="classDD_1_1Image_1_1LUT.html">LUT</a> space by using the lookup tables. </p>

<p>References <a class="el" href="classDD_1_1Image_1_1LUT.html#a076b895d1d4a26e4f930dfcebfb1b84b">fillToTable()</a>.</p>

</div>
</div>
<a class="anchor" id="a97ac218bcf99a5f547e701150da2d035"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDD_1_1Image_1_1LUT.html">LUT</a> * LUT::Linear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a pointer to a <a class="el" href="classDD_1_1Image_1_1LUT.html">LUT</a> that converts colors linear. </p>

<p>References <a class="el" href="classDD_1_1Image_1_1Lock.html#a25b83fc4b5f8b1af270a62e3ab6cfcee">DD::Image::Lock::lock()</a>, and <a class="el" href="classDD_1_1Image_1_1Lock.html#adcf847566b25465d0491d6b6c1b5b8a3">DD::Image::Lock::unlock()</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Write.html#ae76f84680bb2d23603e7bc3b32ef0de5">DD::Image::Write::execute()</a>.</p>

</div>
</div>
<a class="anchor" id="a1515fabc24a45ef763a8eb34ed2f901b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDD_1_1Image_1_1LUT.html">LUT</a> * LUT::GetBuiltinLUT </td>
          <td>(</td>
          <td class="paramtype">BuiltinLUTId&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return <a class="el" href="classDD_1_1Image_1_1LUT.html">LUT</a> based on enumeration. If you create an Enumeration_knob using the builtin_names then you can pass the index it stores as an argument to this function to get the chosen <a class="el" href="classDD_1_1Image_1_1LUT.html">LUT</a>.</p>
<p>If you pass zero then getLut(MONITOR) is returned, however this is supposed to indicate that you are to intelligently choose based on data type and call getLut(). </p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1LUT.html#a29e027537f028d56d1f827a2fa8c3c79">append()</a>, and <a class="el" href="classDD_1_1Image_1_1LUTInfo.html#ae91384dde26e21da3dd6ac27516c709a">DD::Image::LUTInfo::getBuiltinLUTName()</a>.</p>

</div>
</div>
<a class="anchor" id="aeeaafd989c64819eca178dffa73cd4cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDD_1_1Image_1_1LUT.html">LUT</a> * LUT::GetBuiltinLutByName </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the BuiltinLUT named "name". If no match is found, returns the <a class="el" href="classDD_1_1Image_1_1LUT.html">LUT</a> associated with the MONITOR datatype. </p>

</div>
</div>
<a class="anchor" id="a29e027537f028d56d1f827a2fa8c3c79"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LUT::append </td>
          <td>(</td>
          <td class="paramtype">BuiltinLUTId&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDD_1_1Image_1_1Hash.html">Hash</a> &amp;&#160;</td>
          <td class="paramname"><em>hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as builtin(n)-&gt;append(hash), except if n==0 it will append the hash for all the types of data, on the assumption that the one to be chosen will be one of them. This is to generate a hash that will change at the right times for file readers. </p>

<p>References <a class="el" href="classDD_1_1Image_1_1LUT.html#ad9527690c8af9ce1149b3b0a50995de8">append()</a>, and <a class="el" href="classDD_1_1Image_1_1LUT.html#a1515fabc24a45ef763a8eb34ed2f901b">GetBuiltinLUT()</a>.</p>

</div>
</div>
<a class="anchor" id="ab36716c4a96984f1fa2088a3d7e95f0e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDD_1_1Image_1_1LUT.html">LUT</a> * LUT::GetDefaultLutForType </td>
          <td>(</td>
          <td class="paramtype">DataType&#160;</td>
          <td class="paramname"><em>dataTypeHint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the <a class="el" href="classDD_1_1Image_1_1LUT.html">LUT</a> to use by default for the given data type. </p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1ToBuffer.html#a4b6e8a0328d1f5f9a9242386ade6732a">DD::Image::ToBuffer::to_buffer()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a4693982bba102eefca109d745e3af639"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * LUT::builtin_names</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a null-terminated array of string names of the built-in <a class="el" href="classDD_1_1Image_1_1LUT.html">LUT</a> types as used by builtin(). This can be used to provide labels for an Enumeration_knob. The first entry says "auto-detect", but you can skip this by adding 1 to the returned value. </p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1LUTInfo.html#ae91384dde26e21da3dd6ac27516c709a">DD::Image::LUTInfo::getBuiltinLUTName()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<br>
<hr>
<table width="100%"  border="0" cellspacing="0" cellpadding="0">
  <tr>
    <td><span class="legal">&copy;2022 The Foundry Visionmongers, Ltd.  All Rights Reserved. </span></td>
    <td><div align="right"><span class="legal"><a href="http://www.thefoundry.co.uk" target="_blank">www.thefoundry.co.uk</a></span></div></td>
  </tr>
</table>
</body>
</html>
