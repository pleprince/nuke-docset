<html><head><link href="doxygen.css" rel="stylesheet" type="text/css">
<title>Nuke Developer Kit (NDK) 13.2.4: DD::Image::Memory Class Reference</title></head><body>
<!-- Generated by Doxygen 1.8.10 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classDD_1_1Image_1_1Memory.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classDD_1_1Image_1_1Memory-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">DD::Image::Memory Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Memory_1_1bytes.html">bytes</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Memory_1_1MemoryInfo.html">MemoryInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2697362912bc7637adcf5ede688fdf3a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2697362912bc7637adcf5ede688fdf3a"></a>
typedef std::vector&lt; <a class="el" href="classDD_1_1Image_1_1Memory_1_1MemoryInfo.html">MemoryInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>MemoryInfoArray</b></td></tr>
<tr class="separator:a2697362912bc7637adcf5ede688fdf3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9593020a69445c1121c7f48ef2920e57"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9593020a69445c1121c7f48ef2920e57"></a>
typedef std::map&lt; const NodeI *, MemoryInfoArray &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>MemoryInfoMap</b></td></tr>
<tr class="separator:a9593020a69445c1121c7f48ef2920e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a5d4396d8e4ef4b95c7989eb2b1d74065"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Memory.html#a5d4396d8e4ef4b95c7989eb2b1d74065">count_users</a> ()</td></tr>
<tr class="separator:a5d4396d8e4ef4b95c7989eb2b1d74065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa494cd4a0cbdc5d3277bf954db224d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3fa494cd4a0cbdc5d3277bf954db224d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3fa494cd4a0cbdc5d3277bf954db224d"><td class="memTemplItemLeft" align="right" valign="top">static T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>allocate</b> (size_t num, size_t alignment=0)</td></tr>
<tr class="separator:a3fa494cd4a0cbdc5d3277bf954db224d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a229b51d4d4bb3c6525cc8e5a2e448315"><td class="memTemplParams" colspan="2"><a class="anchor" id="a229b51d4d4bb3c6525cc8e5a2e448315"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a229b51d4d4bb3c6525cc8e5a2e448315"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>deallocate</b> (T *ptr)</td></tr>
<tr class="separator:a229b51d4d4bb3c6525cc8e5a2e448315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf032990242de37db0054de75581aeff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf032990242de37db0054de75581aeff"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>generateMemoryInfo</b> (MemoryInfoMap &amp;outMemInfoMap, const void *restrict_to=nullptr)</td></tr>
<tr class="separator:aaf032990242de37db0054de75581aeff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d0fb90fb54d1cad0116e5a926fefd3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Memory.html#a07d0fb90fb54d1cad0116e5a926fefd3">dump_info</a> (std::ostream &amp;output, bool <a class="el" href="classDD_1_1Image_1_1Memory.html#af9c39dd4e8ea5a3f85947ec2dd9e2467">format_bytes</a>, bool includeNodeInfo, const void *restrict_to)</td></tr>
<tr class="separator:a07d0fb90fb54d1cad0116e5a926fefd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1126864d2abb3329fe2ca04f1e23103"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Memory.html#ad1126864d2abb3329fe2ca04f1e23103">register_allocator</a> (<a class="el" href="classDD_1_1Image_1_1IAllocator.html">IAllocator</a> *pAllocator)</td></tr>
<tr class="separator:ad1126864d2abb3329fe2ca04f1e23103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df67e1b83f620d0de4ab2d81a7eda45"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Memory.html#a4df67e1b83f620d0de4ab2d81a7eda45">unregister_allocator</a> (<a class="el" href="classDD_1_1Image_1_1IAllocator.html">IAllocator</a> *pAllocator)</td></tr>
<tr class="separator:a4df67e1b83f620d0de4ab2d81a7eda45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4452d0e84765694b40c4138b4a999b12"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Memory.html#a4452d0e84765694b40c4138b4a999b12">get_num_registered_allocators</a> ()</td></tr>
<tr class="separator:a4452d0e84765694b40c4138b4a999b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4ab789e72f42eff7b5138e0d65a4ce"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classDD_1_1Image_1_1IAllocator.html">IAllocator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Memory.html#a6e4ab789e72f42eff7b5138e0d65a4ce">get_allocator</a> (size_t index)</td></tr>
<tr class="separator:a6e4ab789e72f42eff7b5138e0d65a4ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b63ed122042dc566afdcd88b2ebd208"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classDD_1_1Image_1_1IAllocator.html">IAllocator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Memory.html#a6b63ed122042dc566afdcd88b2ebd208">find_allocator</a> (const char *pAllocatorName)</td></tr>
<tr class="separator:a6b63ed122042dc566afdcd88b2ebd208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ea3527abd7d139a92e6a49619d762d7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0ea3527abd7d139a92e6a49619d762d7"><td class="memTemplItemLeft" align="right" valign="top">static T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Memory.html#a0ea3527abd7d139a92e6a49619d762d7">create_allocator</a> (const char *pAllocatorName)</td></tr>
<tr class="separator:a0ea3527abd7d139a92e6a49619d762d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657baf3bedd2d47fc4ac56490ccf58ae"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Memory.html#a657baf3bedd2d47fc4ac56490ccf58ae">dump_allocatorinfoXML</a> (std::ostream &amp;output, bool <a class="el" href="classDD_1_1Image_1_1Memory.html#af9c39dd4e8ea5a3f85947ec2dd9e2467">format_bytes</a>)</td></tr>
<tr class="separator:a657baf3bedd2d47fc4ac56490ccf58ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8497f783e6df41f727a564deb5c4a4c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Memory.html#af8497f783e6df41f727a564deb5c4a4c">dump_infoXML</a> (std::ostream &amp;output, bool <a class="el" href="classDD_1_1Image_1_1Memory.html#af9c39dd4e8ea5a3f85947ec2dd9e2467">format_bytes</a>, bool includeNodeInfo, const void *restrict_to)</td></tr>
<tr class="separator:af8497f783e6df41f727a564deb5c4a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f5b01ca036997ad29718603b65108eb"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Memory.html#a0f5b01ca036997ad29718603b65108eb">print_bytes</a> (std::ostream &amp;output, long long unsigned <a class="el" href="classDD_1_1Image_1_1Memory_1_1bytes.html">bytes</a>, bool metric=true)</td></tr>
<tr class="separator:a0f5b01ca036997ad29718603b65108eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9c39dd4e8ea5a3f85947ec2dd9e2467"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Memory.html#af9c39dd4e8ea5a3f85947ec2dd9e2467">format_bytes</a> (char *buffer, long long unsigned <a class="el" href="classDD_1_1Image_1_1Memory_1_1bytes.html">bytes</a>, bool metric=true)</td></tr>
<tr class="separator:af9c39dd4e8ea5a3f85947ec2dd9e2467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe40905ade0e8b266de4caf0d1ee3d3d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Memory.html#afe40905ade0e8b266de4caf0d1ee3d3d">initialize</a> ()</td></tr>
<tr class="separator:afe40905ade0e8b266de4caf0d1ee3d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a52ff38942b0757c0d9a7c23a27f416"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a52ff38942b0757c0d9a7c23a27f416"></a>
static size_t&#160;</td><td class="memItemRight" valign="bottom"><b>max_usage</b> ()</td></tr>
<tr class="separator:a6a52ff38942b0757c0d9a7c23a27f416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae955fdcf9d5119170c9e9a92a281ae88"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Memory.html#ae955fdcf9d5119170c9e9a92a281ae88">current_usage</a> ()</td></tr>
<tr class="separator:ae955fdcf9d5119170c9e9a92a281ae88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a682242466c432cef710dd32fa0714f05"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a682242466c432cef710dd32fa0714f05"></a>
static size_t&#160;</td><td class="memItemRight" valign="bottom"><b>total_ram</b> ()</td></tr>
<tr class="separator:a682242466c432cef710dd32fa0714f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefefa9e4c6c6f9e58425f87cf74b2567"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aefefa9e4c6c6f9e58425f87cf74b2567"></a>
static U64&#160;</td><td class="memItemRight" valign="bottom"><b>total_ram_64</b> ()</td></tr>
<tr class="separator:aefefa9e4c6c6f9e58425f87cf74b2567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94ad0b446eedd9a5a61cb1bad24a0244"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94ad0b446eedd9a5a61cb1bad24a0244"></a>
static size_t&#160;</td><td class="memItemRight" valign="bottom"><b>total_vm</b> ()</td></tr>
<tr class="separator:a94ad0b446eedd9a5a61cb1bad24a0244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26a9ffc07376e1f6ae3a57503e92e8aa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a26a9ffc07376e1f6ae3a57503e92e8aa"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>free_count</b> ()</td></tr>
<tr class="separator:a26a9ffc07376e1f6ae3a57503e92e8aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a36c989324b406a625e85538fdeeca0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a36c989324b406a625e85538fdeeca0"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>new_handler_count</b> ()</td></tr>
<tr class="separator:a0a36c989324b406a625e85538fdeeca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a4152559e78050c2e74fde548c0d086"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Memory.html#a3a4152559e78050c2e74fde548c0d086">set_current_usage</a> (size_t target, const char *message=nullptr)</td></tr>
<tr class="separator:a3a4152559e78050c2e74fde548c0d086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95b443b8421ad59a529e36df7f43ba2f"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Memory.html#a95b443b8421ad59a529e36df7f43ba2f">reduce_current_usage</a> (const char *message=nullptr)</td></tr>
<tr class="separator:a95b443b8421ad59a529e36df7f43ba2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ad44cdfd2601be61b743b477acce09d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1ad44cdfd2601be61b743b477acce09d"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>set_max_usage</b> (size_t new_max)</td></tr>
<tr class="separator:a1ad44cdfd2601be61b743b477acce09d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2afc39792bc1d8378eb9808274cbf1a1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2afc39792bc1d8378eb9808274cbf1a1"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>set_hard_max_usage</b> (size_t final_max)</td></tr>
<tr class="separator:a2afc39792bc1d8378eb9808274cbf1a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0998cc96792f4821349b789ceb5ea983"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0998cc96792f4821349b789ceb5ea983"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>set_free_count</b> (int)</td></tr>
<tr class="separator:a0998cc96792f4821349b789ceb5ea983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33e73b0aecca812f5afb3bc11daf7bb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae33e73b0aecca812f5afb3bc11daf7bb"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>set_new_handler_count</b> (int)</td></tr>
<tr class="separator:ae33e73b0aecca812f5afb3bc11daf7bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aabea090ed39d6c77cfb30585b1bb0f"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Memory.html#a4aabea090ed39d6c77cfb30585b1bb0f">allocate_remember_size</a> (size_t size)</td></tr>
<tr class="separator:a4aabea090ed39d6c77cfb30585b1bb0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad13f7c7de1995a3bbf438dd275dbe58b"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Memory.html#ad13f7c7de1995a3bbf438dd275dbe58b">allocate_void</a> (size_t <a class="el" href="classDD_1_1Image_1_1Memory_1_1bytes.html">bytes</a>, size_t alignment=0)</td></tr>
<tr class="separator:ad13f7c7de1995a3bbf438dd275dbe58b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5dd98efa00f6ae8e2d5a51c65fd6504"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Memory.html#ae5dd98efa00f6ae8e2d5a51c65fd6504">deallocate_remember_size</a> (void *ptr)</td></tr>
<tr class="separator:ae5dd98efa00f6ae8e2d5a51c65fd6504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d8ab8676a0cd5a57b33ec979e9303d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Memory.html#aa7d8ab8676a0cd5a57b33ec979e9303d">deallocate_void</a> (void *ptr, size_t num=0)</td></tr>
<tr class="separator:aa7d8ab8676a0cd5a57b33ec979e9303d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3b34209a8de3f2177abbe7224c6082"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Memory.html#a2b3b34209a8de3f2177abbe7224c6082">get_allocated_size</a> (void *ptr)</td></tr>
<tr class="separator:a2b3b34209a8de3f2177abbe7224c6082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5437ffe4ac415153161d9f563f6f6f"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Memory.html#a6a5437ffe4ac415153161d9f563f6f6f">clipToCacheLimit</a> (int &amp;width, int &amp;height, const <a class="el" href="classDD_1_1Image_1_1Format.html">DD::Image::Format</a> &amp;format)</td></tr>
<tr class="separator:a6a5437ffe4ac415153161d9f563f6f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a75d01f59bc3acab0b3f6cfb6d363d978"><td class="memTemplParams" colspan="2"><a class="anchor" id="a75d01f59bc3acab0b3f6cfb6d363d978"></a>
template&lt;class MemoryHolderT &gt; </td></tr>
<tr class="memitem:a75d01f59bc3acab0b3f6cfb6d363d978"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MemRegistrant</b></td></tr>
<tr class="separator:a75d01f59bc3acab0b3f6cfb6d363d978"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classDD_1_1Image_1_1Memory.html">Memory</a> manager for cache-like objects that can be freed and recreated if necessary so that their memory can be used for other purposes. The output buffers on <a class="el" href="classDD_1_1Image_1_1Iop.html" title="Iop is the base class for all the image operators. ">Iop</a> and the 8-bit buffers used by the Nuke viewer, and other objects fall into this class.</p>
<p>Each such object should call register_user() in it's constructor and unregister_user() in it's destructor.</p>
<p>Any code that uses allocate() and deallocate() will trigger <a class="el" href="classDD_1_1Image_1_1Memory.html#a95b443b8421ad59a529e36df7f43ba2f">reduce_current_usage()</a> if the total allocated by these calls goes over max_usage(). This will only work well if the majority of large objects allocated by Nuke and plugins calls these functions, so that <a class="el" href="classDD_1_1Image_1_1Memory.html#ae955fdcf9d5119170c9e9a92a281ae88">current_usage()</a> reflects the actual amount of memory being used. Code that uses new/delete (and malloc on Windows) will also trigger <a class="el" href="classDD_1_1Image_1_1Memory.html#a95b443b8421ad59a529e36df7f43ba2f">reduce_current_usage()</a> when the std::new_handler() is called. But this only happens when you run out of memory which may be somewhat late for safe recovery.</p>
<p>allocate() will also be 16-byte aligned to allow use of vector operations.</p>
<p>Nuke has a choice of 3 allocators to use for allocating <a class="el" href="classDD_1_1Image_1_1Memory.html">Memory</a> that can be set by the environment variable <code>NUKE_ALLOCATOR</code> before starting the application. The allocators are:</p>
<ul>
<li><p class="startli">"System" the Operating System allocator.</p>
<p class="startli">The System allocator has been shown to use the least amount of memory as it releases memory to the OS immediately. However, this comes at a cost in performance and has been shown to be the slowest. This is the default allocator for Linux and Apple macOS速.</p>
</li>
<li><p class="startli">"TC" Google速 <a class="el" href="classDD_1_1Image_1_1Thread.html">Thread</a> Cache fast, multi-threaded malloc implementation.</p>
<p class="startli">The TC allocator has been shown to increase the memory usage but not as much as TBB, as well as increase performance but not as much as TBB and is a good middle ground between the System and TBB allocators. This is the default allocator for Microsoft Windows速 where the System allocator has shown itself to be significantly slower in certain circumstances.</p>
</li>
<li><p class="startli">"TBB" Intel速 <a class="el" href="classDD_1_1Image_1_1Thread.html">Thread</a> Building Blocks scalable malloc.</p>
<p class="startli">The TBB allocator has been shown to have the best performance although it uses the most memory compared to the other allocators. If memory is not a concern this allocator may be the best choice.</p>
</li>
</ul>
<p>For example to use the TBB allocator set the environment variable: <code>NUKE_ALLOCATOR="TBB"</code> before launching Nuke. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a5d4396d8e4ef4b95c7989eb2b1d74065"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Memory::count_users </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of register_user() calls that have not had an unregister_user() call done to it. Used for debugging. </p>

</div>
</div>
<a class="anchor" id="a07d0fb90fb54d1cad0116e5a926fefd3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Memory::dump_info </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>format_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>includeNodeInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>restrict_to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prints a report about all the users and the total memory usage to the stream. Also takes a <em>format_bytes</em> argument which, if true, returns the bytes in a human readable format.</p>
<p>If <em>restrict_to</em> is non-zero then only users whose info() command tests and matches the restrict_to() are printed, and no summary information is used. This is currently used to dump only the info about users that belong to a Node. Result may be a zero-length string if no users match.</p>
<p>If <em>includeNodeInfo</em> is true, Node pointers associated with memory objects (eg Ops/Knobs) will be dererenced for name information. This is unsafe during shutdown, where the associated Nodes may have been deleted. </p>

</div>
</div>
<a class="anchor" id="ad1126864d2abb3329fe2ca04f1e23103"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Memory::register_allocator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDD_1_1Image_1_1IAllocator.html">IAllocator</a> *&#160;</td>
          <td class="paramname"><em>pAllocator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Registers an allocator with the <a class="el" href="classDD_1_1Image_1_1Memory.html">Memory</a> system, which allows us to track how much memory a given allocator is using.</p>
<p>An allocator instance can only be registered once, and print an error if added twice. Returns if allocator was successfully registered </p>

<p>References <a class="el" href="classDD_1_1Image_1_1IAllocator.html#a635ead66e83cf4fbbf62ff22608da04b">DD::Image::IAllocator::getName()</a>, and <a class="el" href="namespaceDD_1_1Image.html#a25928f3b58ea1f8190c0b0cfb6711c7d">DD::Image::getName()</a>.</p>

</div>
</div>
<a class="anchor" id="a4df67e1b83f620d0de4ab2d81a7eda45"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Memory::unregister_allocator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDD_1_1Image_1_1IAllocator.html">IAllocator</a> *&#160;</td>
          <td class="paramname"><em>pAllocator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unregisters an allocator from the <a class="el" href="classDD_1_1Image_1_1Memory.html">Memory</a> system Will print an error message if trying to remove an allocator that's already been removed. Returns if allocator was successfully unregistered </p>

<p>References <a class="el" href="namespaceDD_1_1Image.html#a10d4fc69dd43186166d7796e4cc2fb34">DD::Image::end()</a>.</p>

</div>
</div>
<a class="anchor" id="a4452d0e84765694b40c4138b4a999b12"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Memory::get_num_registered_allocators </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the number of allocators currently registered with the memory system </p>

</div>
</div>
<a class="anchor" id="a6e4ab789e72f42eff7b5138e0d65a4ce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDD_1_1Image_1_1IAllocator.html">IAllocator</a> * Memory::get_allocator </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the registered allocator at a given index </p>

</div>
</div>
<a class="anchor" id="a6b63ed122042dc566afdcd88b2ebd208"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDD_1_1Image_1_1IAllocator.html">IAllocator</a> * Memory::find_allocator </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pAllocatorName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds the registered allocator by name and returns the pointer. returns NULL if it can't find one </p>

<p>References <a class="el" href="namespaceDD_1_1Image.html#a10d4fc69dd43186166d7796e4cc2fb34">DD::Image::end()</a>, and <a class="el" href="classDD_1_1Image_1_1IAllocator.html#a635ead66e83cf4fbbf62ff22608da04b">DD::Image::IAllocator::getName()</a>.</p>

</div>
</div>
<a class="anchor" id="a0ea3527abd7d139a92e6a49619d762d7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T* DD::Image::Memory::create_allocator </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pAllocatorName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper function that creates and registers an allocator of type T, or if it already exists returns the allocator pointer. </p>

</div>
</div>
<a class="anchor" id="a657baf3bedd2d47fc4ac56490ccf58ae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Memory::dump_allocatorinfoXML </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>format_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prints and XML report about all registered allocators, including the current memory usage and the highwater mark.</p>
<p>Also takes a <em>format_bytes</em> argument which, if true, returns the bytes in a human readable format. </p>

<p>References <a class="el" href="classDD_1_1Image_1_1IAllocator.html#a8d31ebd1504105ad84f9dc7ec5ab10b6">DD::Image::IAllocator::getAllocatorHighWaterMark()</a>, <a class="el" href="classDD_1_1Image_1_1IAllocator.html#aa15b3544b7686073997ebefe37f1edc4">DD::Image::IAllocator::getAllocatorUsage()</a>, <a class="el" href="classDD_1_1Image_1_1IAllocator.html#a635ead66e83cf4fbbf62ff22608da04b">DD::Image::IAllocator::getName()</a>, <a class="el" href="classDD_1_1Image_1_1IAllocator.html#ac5d36c96554d02e97e5fa9bfc2d11848">DD::Image::IAllocator::getRequestedHighWaterMark()</a>, <a class="el" href="classDD_1_1Image_1_1IAllocator.html#a44c9488ec6377d8c3c0198c8a3ef71d4">DD::Image::IAllocator::getRequestedUsage()</a>, and <a class="el" href="classDD_1_1Image_1_1IAllocator.html#ad45b37879d26f4eaf4b0b59d4b6c1232">DD::Image::IAllocator::getType()</a>.</p>

</div>
</div>
<a class="anchor" id="af8497f783e6df41f727a564deb5c4a4c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Memory::dump_infoXML </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>format_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>includeNodeInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>restrict_to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prints an XML report about all the users and the total memory usage to the stream. Also takes a <em>format_bytes</em> argument which, if true, returns the bytes in a human readable format.</p>
<p>If <em>restrict_to</em> is non-zero then only users whose info() command tests and matches the restrict_to() are printed, and no summary information is used. This is currently used to dump only the info about users that belong to a Node. Result may be a zero-length string if no users match.</p>
<p>If <em>includeNodeInfo</em> is true, Node pointers associated with memory objects (eg Ops/Knobs) will be dererenced for name information. This is unsafe during shutdown, where the associated Nodes may have been deleted. </p>

</div>
</div>
<a class="anchor" id="a0f5b01ca036997ad29718603b65108eb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Memory::print_bytes </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long unsigned&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>metric</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prints a number of bytes in a user-friendly form, for instance 123.4MiB, 1024KiB, or 513B. If <em>metric</em> is true then use powers of 10 rather than powers of 2, and remove the 'i' from the suffixes. </p>

</div>
</div>
<a class="anchor" id="af9c39dd4e8ea5a3f85947ec2dd9e2467"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Memory::format_bytes </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long unsigned&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>metric</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Puts the same result as <a class="el" href="classDD_1_1Image_1_1Memory.html#a0f5b01ca036997ad29718603b65108eb">print_bytes()</a> into the passed buffer, which must be at least 11 bytes long. Returns the number of bytes written, not counting the nul terminator. </p>

</div>
</div>
<a class="anchor" id="afe40905ade0e8b266de4caf0d1ee3d3d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Memory::initialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets total_ram() by asking the system for this information, and sets max_usage() to 50% of that. This is automatically done by many <a class="el" href="classDD_1_1Image_1_1Memory.html">Memory</a> calls, but you should do this if you wish to change the max_usage to some value other than this default.</p>
<p>Also calls std::set_new_handler(). If you don't want this, call this and then call std::set_new_handler() to set the value back. By default running out of memory in new (and in malloc in Windows) will cause it to clean up memory so it will work, and will throw a bad_alloc exception if it does not work. </p>

</div>
</div>
<a class="anchor" id="ae955fdcf9d5119170c9e9a92a281ae88"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Memory::current_usage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return number of bytes allocated by <a class="el" href="classDD_1_1Image_1_1Memory.html#ad13f7c7de1995a3bbf438dd275dbe58b">allocate_void()</a>. This function is not inline in case we need to add a lock around the reference </p>

</div>
</div>
<a class="anchor" id="a3a4152559e78050c2e74fde548c0d086"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Memory::set_current_usage </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>message</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reduce <a class="el" href="classDD_1_1Image_1_1Memory.html#ae955fdcf9d5119170c9e9a92a281ae88">current_usage()</a> to <em>target</em> or smaller. Returns true if it deleted anything (check <a class="el" href="classDD_1_1Image_1_1Memory.html#ae955fdcf9d5119170c9e9a92a281ae88">current_usage()</a> to see if you really hit the target) </p>

</div>
</div>
<a class="anchor" id="a95b443b8421ad59a529e36df7f43ba2f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Memory::reduce_current_usage </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>message</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reduce the amount of memory being used. Returns true if anything is freed. The message, if not zero, should id the caller is used to print debugging info. </p>

</div>
</div>
<a class="anchor" id="a4aabea090ed39d6c77cfb30585b1bb0f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void* DD::Image::Memory::allocate_remember_size </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>TODO: REMOVE THIS FUNCTION! </p>

</div>
</div>
<a class="anchor" id="ad13f7c7de1995a3bbf438dd275dbe58b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * Memory::allocate_void </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>alignment</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocate <em>bytes</em> bytes of memory and return as a void*. Optionally align memory (also rounds up allocated amount to multiple of alignment) </p>

</div>
</div>
<a class="anchor" id="ae5dd98efa00f6ae8e2d5a51c65fd6504"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void DD::Image::Memory::deallocate_remember_size </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>TODO: REMOVE THIS FUNCTION! </p>

</div>
</div>
<a class="anchor" id="aa7d8ab8676a0cd5a57b33ec979e9303d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Memory::deallocate_void </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Free memory created with <a class="el" href="classDD_1_1Image_1_1Memory.html#ad13f7c7de1995a3bbf438dd275dbe58b">allocate_void()</a> TODO: REMOVE num ARG! </p>

</div>
</div>
<a class="anchor" id="a2b3b34209a8de3f2177abbe7224c6082"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Memory::get_allocated_size </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the size actually allocated for a given pointer NOTE: the size returned may be bigger than requested, implementation dependent. This effectively calls the following: Windows: HeapSize() OSX: malloc_size() Linux: malloc_usable_size() </p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1AllocationTracker.html#a3fbe83acd60b0f080264f9dcb5541e2a">DD::Image::AllocationTracker::allocate()</a>.</p>

</div>
</div>
<a class="anchor" id="a6a5437ffe4ac415153161d9f563f6f6f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DD::Image::Memory::clipToCacheLimit </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDD_1_1Image_1_1Format.html">DD::Image::Format</a> &amp;&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reduce width &amp; height to a box so that can be allocated.</p>
<p>Currently an absolute maximum of 1Mb on each dimension, and an absolute maximum of 64k^2 (4Gb) on the area. This has been chosen so that several dozen 1-D arrays of pointers or floats can be allocated without running out of memory.</p>
<p>In addition each dimension is limited to 16k or the size of the format, whichever is larger. This smaller limit has been chosen so that the entire image can probably be allocated at once. But if the user chooses a very large format this limit is ignored and it may try to allocate far more memory than will fit. Many operations in Nuke will still work with these very large operations (especially in 64-bit versions).</p>
<p>Returns true if it changes the width or height. </p>

<p>References <a class="el" href="classDD_1_1Image_1_1Format.html#a980b6d466a580bd75b33799aed2062be">DD::Image::Format::height()</a>, and <a class="el" href="classDD_1_1Image_1_1Format.html#ab56ced90f4a91922438af72f14c08e54">DD::Image::Format::width()</a>.</p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1Iop.html#a5f7a57fc2339f0d84040d017e3f04b00">DD::Image::Iop::request()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<br>
<hr>
<table width="100%"  border="0" cellspacing="0" cellpadding="0">
  <tr>
    <td><span class="legal">&copy;2022 The Foundry Visionmongers, Ltd.  All Rights Reserved. </span></td>
    <td><div align="right"><span class="legal"><a href="http://www.thefoundry.co.uk" target="_blank">www.thefoundry.co.uk</a></span></div></td>
  </tr>
</table>
</body>
</html>
