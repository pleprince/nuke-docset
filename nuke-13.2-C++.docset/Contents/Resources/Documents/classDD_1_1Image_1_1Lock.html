<html><head><link href="doxygen.css" rel="stylesheet" type="text/css">
<title>Nuke Developer Kit (NDK) 13.2.4: DD::Image::Lock Class Reference</title></head><body>
<!-- Generated by Doxygen 1.8.10 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classDD_1_1Image_1_1Lock.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classDD_1_1Image_1_1Lock-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">DD::Image::Lock Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Inherited by <a class="el" href="classDD_1_1Image_1_1RecursiveLock.html">DD::Image::RecursiveLock</a>, and <a class="el" href="classDD_1_1Image_1_1SignalLock.html">DD::Image::SignalLock</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abbe1d525faec191f63b74c75c0edbe80"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Lock.html#abbe1d525faec191f63b74c75c0edbe80">Lock</a> ()</td></tr>
<tr class="separator:abbe1d525faec191f63b74c75c0edbe80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a272b0184e30d856b234176aa618e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97a272b0184e30d856b234176aa618e0"></a>
pthread_mutex_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_mutex</b> ()</td></tr>
<tr class="separator:a97a272b0184e30d856b234176aa618e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b83fc4b5f8b1af270a62e3ab6cfcee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Lock.html#a25b83fc4b5f8b1af270a62e3ab6cfcee">lock</a> ()</td></tr>
<tr class="separator:a25b83fc4b5f8b1af270a62e3ab6cfcee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ef1c13a9bc14987495175c0b7ce910f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Lock.html#a2ef1c13a9bc14987495175c0b7ce910f">spinlock</a> ()</td></tr>
<tr class="separator:a2ef1c13a9bc14987495175c0b7ce910f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcf847566b25465d0491d6b6c1b5b8a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Lock.html#adcf847566b25465d0491d6b6c1b5b8a3">unlock</a> ()</td></tr>
<tr class="separator:adcf847566b25465d0491d6b6c1b5b8a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf5b2610e1830f319b316c856de61dc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4cf5b2610e1830f319b316c856de61dc"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>trylock</b> ()</td></tr>
<tr class="separator:a4cf5b2610e1830f319b316c856de61dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1c9519dbf6b18c2fa03af5df0c5b477"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1c9519dbf6b18c2fa03af5df0c5b477"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>spinsignal</b> ()</td></tr>
<tr class="separator:af1c9519dbf6b18c2fa03af5df0c5b477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a6450827260822916d599289746056"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78a6450827260822916d599289746056"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>spinwait</b> ()</td></tr>
<tr class="separator:a78a6450827260822916d599289746056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03d24d9b83ba2c9df3b97013dac23f06"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Lock.html#a03d24d9b83ba2c9df3b97013dac23f06">~Lock</a> ()</td></tr>
<tr class="separator:a03d24d9b83ba2c9df3b97013dac23f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a0e510f3c39d7e63fa4c87a52a701c156"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e510f3c39d7e63fa4c87a52a701c156"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Lock</b> (const pthread_mutexattr_t *a)</td></tr>
<tr class="separator:a0e510f3c39d7e63fa4c87a52a701c156"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aec01e0e44e54af13ce3fa7fcf167355b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec01e0e44e54af13ce3fa7fcf167355b"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>SignalLock</b></td></tr>
<tr class="separator:aec01e0e44e54af13ce3fa7fcf167355b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classDD_1_1Image_1_1Lock.html">Lock</a> lets multiple threads synchronize the running of critial sections of code or the accessing of shared memory. The object acts as what the pthreads documentation calls a "mutex". </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="abbe1d525faec191f63b74c75c0edbe80"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DD::Image::Lock::Lock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The constructor creates the lock unlocked. </p>

</div>
</div>
<a class="anchor" id="a03d24d9b83ba2c9df3b97013dac23f06"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DD::Image::Lock::~Lock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destroys the lock. It does not matter if it is locked or not. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a25b83fc4b5f8b1af270a62e3ab6cfcee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DD::Image::Lock::lock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>When this returns, the calling thread will "own" the lock.</p>
<p>If no thread owns the lock this will return immediately.</p>
<p>If another thread owns the lock this will block (not return) until that other thread calls <a class="el" href="classDD_1_1Image_1_1Lock.html#adcf847566b25465d0491d6b6c1b5b8a3">unlock()</a>.</p>
<p>If this thread already owns the lock the result is undefined!!! To avoid this, use the class <a class="el" href="classDD_1_1Image_1_1RecursiveLock.html">RecursiveLock</a>. </p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1FileRead.html#ac4ea7a52aed22327659b618e600b8c51">DD::Image::FileRead::closeFile()</a>, <a class="el" href="classDD_1_1Image_1_1Image__Cache.html#a6e99fe6c04d7377bcf6779e838763005">DD::Image::Image_Cache::fileSize()</a>, <a class="el" href="classDD_1_1Image_1_1LUT.html#a97ac218bcf99a5f547e701150da2d035">DD::Image::LUT::Linear()</a>, <a class="el" href="classDD_1_1Image_1_1FileReader.html#a902d82370838011388201db31f6558bc">DD::Image::FileReader::lock()</a>, <a class="el" href="classDD_1_1Image_1_1RecursiveLock.html#afc216811ad301c075637d53132274755">DD::Image::RecursiveLock::lock()</a>, <a class="el" href="classDD_1_1Image_1_1FileReader.html#aede71d8ad78be5f3b6593e0beb611e89">DD::Image::FileReader::read()</a>, <a class="el" href="classDD_1_1Image_1_1Image__Cache.html#aa6d858e09634bb2c4aa23b1cad3f7675">DD::Image::Image_Cache::remove()</a>, <a class="el" href="classDD_1_1Image_1_1Image__Cache.html#a30cff89f6b6f954d1af8037724ee1e0b">DD::Image::Image_Cache::remove_oldest_files()</a>, and <a class="el" href="classDD_1_1Image_1_1FileReader.html#a926796a2a1f5d641fdd6583e2a884f51">DD::Image::FileReader::unlock()</a>.</p>

</div>
</div>
<a class="anchor" id="a2ef1c13a9bc14987495175c0b7ce910f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DD::Image::Lock::spinlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This has the same result as <a class="el" href="classDD_1_1Image_1_1Lock.html#a25b83fc4b5f8b1af270a62e3ab6cfcee">lock()</a>, but it works by spinning. This is faster than doing the system call but it keeps the processor busy looping this thread. You should use this call if and only if:</p><ul>
<li>the lock is held by <em>other</em> threads for very short periods of time (such as a dozen or so assignment statements)</li>
<li>There is high contention (i.e. there is a good chance that an initial attempt to grab the lock will fail, as this is no faster than the normal <a class="el" href="classDD_1_1Image_1_1Lock.html#a25b83fc4b5f8b1af270a62e3ab6cfcee">lock()</a> on immediate success). </li>
</ul>

</div>
</div>
<a class="anchor" id="adcf847566b25465d0491d6b6c1b5b8a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DD::Image::Lock::unlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Release the lock. The calling thread <em>must</em> have called <a class="el" href="classDD_1_1Image_1_1Lock.html#a25b83fc4b5f8b1af270a62e3ab6cfcee">lock()</a> once before this, or the results are undefined! </p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1FileRead.html#ac4ea7a52aed22327659b618e600b8c51">DD::Image::FileRead::closeFile()</a>, <a class="el" href="classDD_1_1Image_1_1Image__Cache.html#a6e99fe6c04d7377bcf6779e838763005">DD::Image::Image_Cache::fileSize()</a>, <a class="el" href="classDD_1_1Image_1_1LUT.html#a97ac218bcf99a5f547e701150da2d035">DD::Image::LUT::Linear()</a>, <a class="el" href="classDD_1_1Image_1_1FileReader.html#a902d82370838011388201db31f6558bc">DD::Image::FileReader::lock()</a>, <a class="el" href="classDD_1_1Image_1_1FileReader.html#aede71d8ad78be5f3b6593e0beb611e89">DD::Image::FileReader::read()</a>, <a class="el" href="classDD_1_1Image_1_1Image__Cache.html#aa6d858e09634bb2c4aa23b1cad3f7675">DD::Image::Image_Cache::remove()</a>, <a class="el" href="classDD_1_1Image_1_1Image__Cache.html#a30cff89f6b6f954d1af8037724ee1e0b">DD::Image::Image_Cache::remove_oldest_files()</a>, <a class="el" href="classDD_1_1Image_1_1FileReader.html#a926796a2a1f5d641fdd6583e2a884f51">DD::Image::FileReader::unlock()</a>, and <a class="el" href="classDD_1_1Image_1_1RecursiveLock.html#ad3d4f28127ae1d9e51c2212fc1388b3f">DD::Image::RecursiveLock::unlock()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<br>
<hr>
<table width="100%"  border="0" cellspacing="0" cellpadding="0">
  <tr>
    <td><span class="legal">&copy;2022 The Foundry Visionmongers, Ltd.  All Rights Reserved. </span></td>
    <td><div align="right"><span class="legal"><a href="http://www.thefoundry.co.uk" target="_blank">www.thefoundry.co.uk</a></span></div></td>
  </tr>
</table>
</body>
</html>
