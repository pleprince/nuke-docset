<html><head><link href="doxygen.css" rel="stylesheet" type="text/css">
<title>Nuke Developer Kit (NDK) 13.2.4: DD::Image::Hash Class Reference</title></head><body>
<!-- Generated by Doxygen 1.8.10 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classDD_1_1Image_1_1Hash.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classDD_1_1Image_1_1Hash-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">DD::Image::Hash Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0637035d3c12510704ccdb967c9ed928"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0637035d3c12510704ccdb967c9ed928"></a>
typedef U64&#160;</td><td class="memItemRight" valign="bottom"><b>HashType</b></td></tr>
<tr class="separator:a0637035d3c12510704ccdb967c9ed928"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aad83075e65c5bb5e74f3feb795813c1b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad83075e65c5bb5e74f3feb795813c1b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Hash</b> (const <a class="el" href="classDD_1_1Image_1_1Hash.html">Hash</a> &amp;h)</td></tr>
<tr class="separator:aad83075e65c5bb5e74f3feb795813c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace9a8b648bcc4f12a76ca56f20ea286e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace9a8b648bcc4f12a76ca56f20ea286e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Hash</b> (U64 v)</td></tr>
<tr class="separator:ace9a8b648bcc4f12a76ca56f20ea286e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2036fab9507b01e77f612d375aab4f67"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2036fab9507b01e77f612d375aab4f67"></a>
const <a class="el" href="classDD_1_1Image_1_1Hash.html">Hash</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classDD_1_1Image_1_1Hash.html">Hash</a> &amp;h)</td></tr>
<tr class="separator:a2036fab9507b01e77f612d375aab4f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7149aff58da4ef79d32f78f22bddacb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Hash.html#a7149aff58da4ef79d32f78f22bddacb1">reset</a> ()</td></tr>
<tr class="separator:a7149aff58da4ef79d32f78f22bddacb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40fd79f2b8e40f707226bdf14427a532"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a40fd79f2b8e40f707226bdf14427a532"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>reset</b> (U64 v)</td></tr>
<tr class="separator:a40fd79f2b8e40f707226bdf14427a532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b8073eeed4b34e44cd1872908a283c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a34b8073eeed4b34e44cd1872908a283c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classDD_1_1Image_1_1Hash.html">Hash</a> &amp;h) const </td></tr>
<tr class="separator:a34b8073eeed4b34e44cd1872908a283c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50a053595a781db2897007c220322553"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50a053595a781db2897007c220322553"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classDD_1_1Image_1_1Hash.html">Hash</a> &amp;h) const </td></tr>
<tr class="separator:a50a053595a781db2897007c220322553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a553b336f3efe6327c221b942d55dbb72"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a553b336f3efe6327c221b942d55dbb72"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="classDD_1_1Image_1_1Hash.html">Hash</a> &amp;h) const </td></tr>
<tr class="separator:a553b336f3efe6327c221b942d55dbb72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac99c9bf76242b16adb5316572ebd3ba2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac99c9bf76242b16adb5316572ebd3ba2"></a>
U64&#160;</td><td class="memItemRight" valign="bottom"><b>value</b> () const </td></tr>
<tr class="separator:ac99c9bf76242b16adb5316572ebd3ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcb2900697075ad3a1baa785f6175ea3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adcb2900697075ad3a1baa785f6175ea3"></a>
U64&#160;</td><td class="memItemRight" valign="bottom"><b>getHash</b> () const </td></tr>
<tr class="separator:adcb2900697075ad3a1baa785f6175ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39864aeaccea0cd6b13180b3d628fb44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Hash.html#a39864aeaccea0cd6b13180b3d628fb44">append</a> (const void *data, size_t length)</td></tr>
<tr class="separator:a39864aeaccea0cd6b13180b3d628fb44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e0413b5d9cd5edde23c3d2c53a359e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Hash.html#a5e0413b5d9cd5edde23c3d2c53a359e3">append</a> (const char *)</td></tr>
<tr class="separator:a5e0413b5d9cd5edde23c3d2c53a359e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3ad6055e522338418c915283f9dbc25"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af3ad6055e522338418c915283f9dbc25"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>append</b> (const std::string &amp;s)</td></tr>
<tr class="separator:af3ad6055e522338418c915283f9dbc25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10710dd6d9699548ef6b00113314700f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Hash.html#a10710dd6d9699548ef6b00113314700f">append</a> (bool)</td></tr>
<tr class="separator:a10710dd6d9699548ef6b00113314700f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b4033dd02c2632dd8f9c40910feaba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Hash.html#ac1b4033dd02c2632dd8f9c40910feaba">append</a> (int)</td></tr>
<tr class="separator:ac1b4033dd02c2632dd8f9c40910feaba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbae44001abb20b62b08c97613be189f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Hash.html#abbae44001abb20b62b08c97613be189f">append</a> (unsigned)</td></tr>
<tr class="separator:abbae44001abb20b62b08c97613be189f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac714ccc412553c7e269e4ffe58541a3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Hash.html#ac714ccc412553c7e269e4ffe58541a3d">append</a> (float)</td></tr>
<tr class="separator:ac714ccc412553c7e269e4ffe58541a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11a397a5f27d1836d22940e82e96fbda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Hash.html#a11a397a5f27d1836d22940e82e96fbda">append</a> (double)</td></tr>
<tr class="separator:a11a397a5f27d1836d22940e82e96fbda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a0717edeee1d4ed00f2dee504ef5bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Hash.html#a88a0717edeee1d4ed00f2dee504ef5bd">append</a> (const <a class="el" href="classDD_1_1Image_1_1Hash.html">Hash</a> &amp;)</td></tr>
<tr class="separator:a88a0717edeee1d4ed00f2dee504ef5bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a122dedc03cae05c282d96a022cacc442"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Hash.html#a122dedc03cae05c282d96a022cacc442">append</a> (const std::set&lt; int &gt; &amp;intset)</td></tr>
<tr class="separator:a122dedc03cae05c282d96a022cacc442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d59c12f2c8acabd6fc60de969962ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Hash.html#aa9d59c12f2c8acabd6fc60de969962ac">append</a> (const std::map&lt; int, int &gt; &amp;iimap)</td></tr>
<tr class="separator:aa9d59c12f2c8acabd6fc60de969962ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe20c3e05b371a1a6ceefe03132adab3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDD_1_1Image_1_1Hash.html#afe20c3e05b371a1a6ceefe03132adab3">append</a> (U64)</td></tr>
<tr class="separator:afe20c3e05b371a1a6ceefe03132adab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa35582bd5d981968b3105a9ff0d2fb12"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa35582bd5d981968b3105a9ff0d2fb12"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aa35582bd5d981968b3105a9ff0d2fb12"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>append</b> (const std::vector&lt; T &gt; &amp;vec)</td></tr>
<tr class="separator:aa35582bd5d981968b3105a9ff0d2fb12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a071fd3f75f1e244bc6ffa382791ecf07"><td class="memTemplParams" colspan="2"><a class="anchor" id="a071fd3f75f1e244bc6ffa382791ecf07"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a071fd3f75f1e244bc6ffa382791ecf07"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDD_1_1Image_1_1Hash.html">Hash</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (const T &amp;v)</td></tr>
<tr class="separator:a071fd3f75f1e244bc6ffa382791ecf07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3123b0206d2464f42ec7a7fd9bdc16ba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3123b0206d2464f42ec7a7fd9bdc16ba"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>newvalue</b> ()</td></tr>
<tr class="separator:a3123b0206d2464f42ec7a7fd9bdc16ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Generates and maintaines a hash sum of data. If the hashes of two pieces of data are equal it is <em>extremely</em> likely the two pieces of data are equal.</p>
<p>To generate a hash, make one of these objects, then <a class="el" href="classDD_1_1Image_1_1Hash.html#a7149aff58da4ef79d32f78f22bddacb1">reset()</a> it, then call append() with each piece of data you want to include. You can then compare it with other hashes, or extract the numerical value with value().</p>
<p>The algorithim used is a 64-bit CRC checksum, using the CRC-64-ECMA-182 polynominal (lsb representation 0x42F0E1EBA9EA3693). Some people worry that this is not a cryptographcally sound checksum, but that is not needed when the data is not being produced by something that is actively trying to subvert the checksum. For random data it is equally strong. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a7149aff58da4ef79d32f78f22bddacb1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DD::Image::Hash::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset the hash to it's initial value. This is not zero. </p>

<p>Referenced by <a class="el" href="classDD_1_1Image_1_1ReadGeo.html#aef6bfba04a696b14fcbae079755b6924">DD::Image::ReadGeo::_validate()</a>, <a class="el" href="classDD_1_1Image_1_1GeometryList.html#a884f92737a7e1cd1254d1e8bc6061d87">DD::Image::GeometryList::add_object()</a>, <a class="el" href="classDD_1_1Image_1_1GeoOp.html#a382c89d2fd4ece23ed5728f4a5c2579d">DD::Image::GeoOp::get_geometry()</a>, <a class="el" href="classDD_1_1Image_1_1GeoOp.html#a17753ecca2ed2a766efd0d17f0635912">DD::Image::GeoOp::get_geometry_hash()</a>, and <a class="el" href="classDD_1_1Image_1_1LUT.html#acdd8fb725fa27a5ebbc3542d95ae0660">DD::Image::LUT::validate()</a>.</p>

</div>
</div>
<a class="anchor" id="a39864aeaccea0cd6b13180b3d628fb44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Hash::append </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add the <em>n</em> bytes starting at <em>pointer</em> to the hash.</p>
<p>Warning: this call is for appending blocks of data together. A zero-length block will not change the hash, and the hash is the same no matter how the same block is split into calls to this. This will cause the hash to fail if you actually care about this, for instance if you have several variable-sized arrays of data. Swapping a zero-length and non-zero-length one, or moving data from the end of one to the start of the next, will not change the hash. The solution is to append the length as well. </p>

</div>
</div>
<a class="anchor" id="a5e0413b5d9cd5edde23c3d2c53a359e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Hash::append </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a null-terminated string or a null pointer to the hash.</p>
<p>The zero-length string and the null pointer hash to different values, and those are different than not calling this. </p>

</div>
</div>
<a class="anchor" id="a10710dd6d9699548ef6b00113314700f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Hash::append </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a bool value to the hash. This is different than any other possible append (as it only adds 1 bit to the hash rather than a multiple of 8) and thus it is also useful for marking where zero-length arrays are. </p>

</div>
</div>
<a class="anchor" id="ac1b4033dd02c2632dd8f9c40910feaba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Hash::append </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add an integer value to the hash. Same as using append(&amp;value, sizeof(int)) on a LSB-first machine. This is intended for hashing enumeration values. </p>

</div>
</div>
<a class="anchor" id="abbae44001abb20b62b08c97613be189f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Hash::append </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add an unsigned value to the hash. Same as using append(&amp;value, sizeof(unsigned)) on a LSB-first machine. This is intended for hashing enumeration or size values. </p>

</div>
</div>
<a class="anchor" id="ac714ccc412553c7e269e4ffe58541a3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Hash::append </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a float value to the hash. Same as using append(&amp;value, sizeof(float)) (this may change on MSB machines). </p>

</div>
</div>
<a class="anchor" id="a11a397a5f27d1836d22940e82e96fbda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Hash::append </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a double value to the hash. Same as using append(&amp;value, sizeof(float)) (this may change on MSB machines). </p>

</div>
</div>
<a class="anchor" id="a88a0717edeee1d4ed00f2dee504ef5bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Hash::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDD_1_1Image_1_1Hash.html">Hash</a> &amp;&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add another hash to this hash. </p>

</div>
</div>
<a class="anchor" id="a122dedc03cae05c282d96a022cacc442"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Hash::append </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>intset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add an intset to the hash. </p>

</div>
</div>
<a class="anchor" id="aa9d59c12f2c8acabd6fc60de969962ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Hash::append </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; int, int &gt; &amp;&#160;</td>
          <td class="paramname"><em>iimap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a std::map&lt;int, int&gt; to the hash. </p>

</div>
</div>
<a class="anchor" id="afe20c3e05b371a1a6ceefe03132adab3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Hash::append </td>
          <td>(</td>
          <td class="paramtype">U64&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a 64 bit value to this hash. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<br>
<hr>
<table width="100%"  border="0" cellspacing="0" cellpadding="0">
  <tr>
    <td><span class="legal">&copy;2022 The Foundry Visionmongers, Ltd.  All Rights Reserved. </span></td>
    <td><div align="right"><span class="legal"><a href="http://www.thefoundry.co.uk" target="_blank">www.thefoundry.co.uk</a></span></div></td>
  </tr>
</table>
</body>
</html>
